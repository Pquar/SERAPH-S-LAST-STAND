<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Seraph's Last Stand</title>
    <style>
        /* CSS Principal - Seraph's Last Stand */

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            height: 100%;
            width: 100%;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: #fff;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            -webkit-touch-callout: none;
            -webkit-tap-highlight-color: transparent;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;

            /* Suporte para viewport seguro em dispositivos com notch */
            height: 100vh;
            height: -webkit-fill-available;
        }

        #gameCanvas {
            background: linear-gradient(45deg, #0f0f23 0%, #1a1a2e 100%);
            border: 2px solid #4a4a8a;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(74, 74, 138, 0.5);
            max-width: 100vw;
            max-height: 100vh;
        }

        /* HUD do jogo - oculto por padrão */
        #gameHUD {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            display: none;
            /* Oculto por padrão - mostrado apenas durante o jogo */
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            background: linear-gradient(180deg, rgba(15, 15, 35, 0.8) 0%, transparent 100%);
        }

        .hud-bottom {
            position: absolute;
            bottom: 20px;
            left: 20px;
        }

        .hp-container {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .hp-bar {
            position: relative;
            width: 200px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid #4a4a8a;
            border-radius: 10px;
            overflow: hidden;
        }

        .hp-fill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff4444 0%, #ff6666 50%, #ff4444 100%);
            transition: width 0.3s ease;
        }

        .hp-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        .wave-counter,
        .timer,
        .soul-orbs {
            background: rgba(15, 15, 35, 0.8);
            padding: 10px 20px;
            border: 2px solid #4a4a8a;
            border-radius: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
        }

        .soul-orbs {
            color: #66ffff;
            border-color: #66ffff;
            box-shadow: 0 0 10px rgba(102, 255, 255, 0.3);
        }

        /* Menus */
        .menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(15, 15, 35, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .menu.hidden {
            display: none;
        }

        .menu-content {
            text-align: center;
            max-width: 400px;
            padding: 40px;
            background: linear-gradient(135deg, rgba(26, 26, 46, 0.9) 0%, rgba(22, 33, 62, 0.9) 100%);
            border: 2px solid #4a4a8a;
            border-radius: 20px;
            box-shadow: 0 0 30px rgba(74, 74, 138, 0.5);
        }

        .menu-content h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #66ffff, #4a4a8a, #66ffff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .menu-content h2 {
            font-size: 2em;
            margin-bottom: 20px;
            color: #66ffff;
        }

        .subtitle {
            font-size: 1.2em;
            margin-bottom: 30px;
            color: #aaa;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .menu-btn {
            padding: 15px 30px;
            font-size: 1.1em;
            font-weight: bold;
            background: linear-gradient(135deg, #4a4a8a 0%, #6a6aaa 100%);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(74, 74, 138, 0.3);
        }

        .menu-btn:hover {
            background: linear-gradient(135deg, #6a6aaa 0%, #8a8aca 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(74, 74, 138, 0.4);
        }

        .menu-btn.primary {
            background: linear-gradient(135deg, #66ffff 0%, #4da6ff 100%);
            color: #0f0f23;
        }

        .menu-btn.primary:hover {
            background: linear-gradient(135deg, #80ffff 0%, #66b3ff 100%);
        }

        /* Controles móveis - FORÇAR ocultação em desktop */
        .mobile-only {
            display: none !important;
            /* Forçar ocultação por padrão */
            visibility: hidden !important;
            pointer-events: none !important;
        }

        /* Apenas mostrar em dispositivos realmente móveis */
        @media (max-width: 768px) and (pointer: coarse) {
            .mobile-only {
                display: block !important;
                visibility: visible !important;
                pointer-events: auto !important;
            }
        }

        /* Fallback para dispositivos móveis sem suporte a pointer: coarse */
        @media (max-width: 768px) and (hover: none) {
            .mobile-only {
                display: block !important;
                visibility: visible !important;
                pointer-events: auto !important;
            }
        }

        #mobileControls {
            display: none;
            /* Oculto por padrão - mostrado apenas em dispositivos móveis durante o jogo */
        }

        .joystick-container {
            position: absolute;
            bottom: 30px;
            left: 30px;
            pointer-events: all;
        }

        .joystick {
            width: 120px;
            height: 120px;
            background: rgba(255, 255, 255, 0.1);
            border: 3px solid #4a4a8a;
            border-radius: 50%;
            position: relative;
            touch-action: none;
        }

        .joystick-knob {
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, #66ffff 0%, #4da6ff 100%);
            border: 2px solid #fff;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s ease;
            box-shadow: 0 0 10px rgba(102, 255, 255, 0.5);
        }

        .mobile-buttons {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: all;
        }

        .action-btn {
            padding: 15px 25px;
            font-size: 1em;
            font-weight: bold;
            background: linear-gradient(135deg, #4a4a8a 0%, #6a6aaa 100%);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px rgba(74, 74, 138, 0.3);
            touch-action: manipulation;
        }

        .action-btn:hover,
        .action-btn:active {
            background: linear-gradient(135deg, #6a6aaa 0%, #8a8aca 100%);
            transform: scale(1.05);
            box-shadow: 0 6px 20px rgba(74, 74, 138, 0.4);
        }

        /* Responsividade */
        @media (max-width: 768px) {
            .hud-top {
                padding: 10px;
                flex-wrap: wrap;
                gap: 10px;
            }

            .hp-bar {
                width: 150px;
                height: 16px;
            }

            .hp-text {
                font-size: 10px;
            }

            .wave-counter,
            .timer,
            .soul-orbs {
                padding: 8px 15px;
                font-size: 0.9em;
            }

            .menu-content {
                padding: 20px;
                max-width: 90vw;
            }

            .menu-content h1 {
                font-size: 2em;
            }

            .menu-btn {
                padding: 12px 25px;
                font-size: 1em;
            }
        }

        @media (max-width: 480px) {
            .hud-top {
                padding: 5px;
            }

            .hp-bar {
                width: 120px;
                height: 14px;
            }

            .wave-counter,
            .timer,
            .soul-orbs {
                padding: 6px 12px;
                font-size: 0.8em;
            }

            .joystick {
                width: 100px;
                height: 100px;
            }

            .joystick-knob {
                width: 35px;
                height: 35px;
            }

            .action-btn {
                padding: 12px 20px;
                font-size: 0.9em;
            }
        }
    </style>
    <style>
        /* CSS Mobile - Otimizações específicas para dispositivos móveis */

        /* Suporte completo para tela cheia em dispositivos móveis */
        @media (max-width: 768px) {

            html,
            body {
                height: 100vh;
                height: -webkit-fill-available;
                width: 100vw;
                position: fixed;
                overflow: hidden;
            }

            #gameContainer {
                width: 100vw;
                height: 100vh;
                height: -webkit-fill-available;
                position: fixed;
                top: 0;
                left: 0;
            }

            #gameCanvas {
                width: 100vw !important;
                height: 100vh !important;
                height: -webkit-fill-available !important;
                border: none !important;
                border-radius: 0 !important;
                max-width: none !important;
                max-height: none !important;
            }
        }

        @media (max-width: 768px) and (orientation: portrait) {
            #gameCanvas {
                width: 100vw;
                height: calc(100vh - 200px);
                height: calc(-webkit-fill-available - 200px);
                border: none;
                border-radius: 0;
            }

            .hud-top {
                background: linear-gradient(180deg, rgba(15, 15, 35, 0.9) 0%, rgba(15, 15, 35, 0.7) 70%, transparent 100%);
                padding: 10px 15px;
                padding-top: max(10px, env(safe-area-inset-top));
            }

            .hp-bar {
                width: 120px;
                height: 14px;
            }

            .wave-counter,
            .timer {
                font-size: 0.8em;
                padding: 6px 12px;
            }

            .joystick-container {
                bottom: max(20px, env(safe-area-inset-bottom));
                left: max(20px, env(safe-area-inset-left));
            }

            .mobile-buttons {
                bottom: max(20px, env(safe-area-inset-bottom));
                right: max(20px, env(safe-area-inset-right));
            }
        }

        @media (max-width: 768px) and (orientation: landscape) {
            #gameCanvas {
                width: 100vw;
                height: 100vh;
                height: -webkit-fill-available;
                border: none;
                border-radius: 0;
            }

            .hud-top {
                padding: 8px 15px;
                padding-top: max(8px, env(safe-area-inset-top));
                padding-left: max(15px, env(safe-area-inset-left));
                padding-right: max(15px, env(safe-area-inset-right));
            }

            .joystick-container {
                bottom: max(20px, env(safe-area-inset-bottom));
                left: max(20px, env(safe-area-inset-left));
            }

            .mobile-buttons {
                bottom: max(20px, env(safe-area-inset-bottom));
                right: max(20px, env(safe-area-inset-right));
                flex-direction: row;
                gap: 10px;
            }

            .action-btn {
                padding: 10px 15px;
                font-size: 0.8em;
            }
        }

        /* Otimizações para telas muito pequenas */
        @media (max-width: 480px) {
            .menu-content h1 {
                font-size: 1.8em;
            }

            .subtitle {
                font-size: 1em;
            }

            .menu-btn {
                padding: 10px 20px;
                font-size: 0.9em;
            }

            .joystick {
                width: 90px;
                height: 90px;
            }

            .joystick-knob {
                width: 30px;
                height: 30px;
            }
        }

        /* Otimizações para iPhone SE e telas similares */
        @media (max-width: 375px) {
            .hud-top {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }

            .hp-bar {
                width: 100px;
                height: 12px;
            }

            .hp-text {
                font-size: 9px;
            }

            .wave-counter,
            .timer,
            .soul-orbs {
                font-size: 0.7em;
                padding: 4px 8px;
            }

            .joystick {
                width: 80px;
                height: 80px;
            }

            .joystick-knob {
                width: 25px;
                height: 25px;
            }

            .action-btn {
                padding: 8px 15px;
                font-size: 0.8em;
            }
        }

        /* Suporte para dispositivos com notch */
        @supports (padding: max(0px)) {
            .hud-top {
                padding-top: max(20px, env(safe-area-inset-top));
                padding-left: max(20px, env(safe-area-inset-left));
                padding-right: max(20px, env(safe-area-inset-right));
            }

            .joystick-container {
                bottom: max(30px, env(safe-area-inset-bottom));
                left: max(30px, env(safe-area-inset-left));
            }

            .mobile-buttons {
                bottom: max(30px, env(safe-area-inset-bottom));
                right: max(30px, env(safe-area-inset-right));
            }
        }

        /* Melhorias de performance para dispositivos móveis */
        .joystick,
        .joystick-knob,
        .action-btn {
            will-change: transform;
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }

        /* Evita zoom acidental em dispositivos móveis */
        input,
        button,
        select,
        textarea {
            font-size: 16px;
        }

        /* Melhora a experiência tátil */
        .action-btn,
        .menu-btn,
        .joystick {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        /* Feedback visual para toques */
        .action-btn:active,
        .menu-btn:active {
            transform: scale(0.95);
            transition: transform 0.1s ease;
        }

        .joystick:active .joystick-knob {
            box-shadow: 0 0 15px rgba(102, 255, 255, 0.8);
        }

        /* Força tela cheia em dispositivos móveis */
        @media (max-width: 768px) {
            html {
                height: 100vh;
                height: -webkit-fill-available;
            }

            body {
                min-height: 100vh;
                min-height: -webkit-fill-available;
            }

            /* Melhor compatibilidade com PWA */
            @media (display-mode: fullscreen) {
                #gameContainer {
                    height: 100vh;
                }
            }

            @media (display-mode: standalone) {
                #gameContainer {
                    height: 100vh;
                }
            }
        }
    </style>
    <meta name="theme-color" content="#1a1a2e">
    <meta name="description" content="Jogo de tiro incremental roguelike inspirado no clássico Heli Attack">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="mobile-web-app-capable" content="yes">
</head>

<body>
    <!-- SVG Definitions - Sprites do Jogo -->
    <svg style="display: none;" xmlns="http://www.w3.org/2000/svg">
        <defs>
            <!-- Player Base - Mago -->
            <g id="mago-sprite">
                <circle cx="32" cy="48" r="16" fill="#1e3a8a" stroke="#3b82f6" stroke-width="2"/>
                <circle cx="32" cy="32" r="12" fill="#fbbf24" stroke="#f59e0b" stroke-width="1"/>
                <circle cx="28" cy="28" r="2" fill="#1f2937"/>
                <circle cx="36" cy="28" r="2" fill="#1f2937"/>
                <path d="M28 36 L36 36" stroke="#dc2626" stroke-width="2" stroke-linecap="round"/>
                <rect x="24" y="48" width="16" height="12" fill="#7c3aed" stroke="#8b5cf6" stroke-width="1"/>
                <rect x="20" y="52" width="8" height="4" fill="#fbbf24"/>
                <rect x="36" y="52" width="8" height="4" fill="#fbbf24"/>
            </g>

            <!-- Chapéus Aprimorados -->
            <g id="chapeu-mago">
                <!-- Base do chapéu com gradiente -->
                <defs>
                    <linearGradient id="wizardHatGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#8b5cf6;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#7c3aed;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#5b21b6;stop-opacity:1" />
                    </linearGradient>
                    <radialGradient id="wizardStarGrad" cx="50%" cy="50%" r="50%">
                        <stop offset="0%" style="stop-color:#fbbf24;stop-opacity:1" />
                        <stop offset="70%" style="stop-color:#f59e0b;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#d97706;stop-opacity:1" />
                    </radialGradient>
                </defs>
                <!-- Sombra do chapéu -->
                <path d="M17 21 L33 5 L49 21 L33 17 Z" fill="#4c1d95" opacity="0.3"/>
                <!-- Chapéu principal -->
                <path d="M16 20 L32 4 L48 20 L32 16 Z" fill="url(#wizardHatGrad)" stroke="#6d28d9" stroke-width="1.5"/>
                <!-- Borda decorativa -->
                <rect x="14" y="19" width="36" height="3" fill="#6366f1" rx="1"/>
                <rect x="15" y="20" width="34" height="1" fill="#a855f7" opacity="0.7"/>
                <!-- Estrela mágica -->
                <polygon points="32,14 33.5,17.5 37,17.5 34.25,19.75 35.75,23.25 32,21 28.25,23.25 29.75,19.75 27,17.5 30.5,17.5" 
                         fill="url(#wizardStarGrad)" stroke="#92400e" stroke-width="0.5"/>
                <!-- Brilhos mágicos -->
                <circle cx="28" cy="12" r="1" fill="#fbbf24" opacity="0.8"/>
                <circle cx="36" cy="10" r="0.5" fill="#fbbf24" opacity="0.6"/>
                <circle cx="25" cy="18" r="0.8" fill="#c084fc" opacity="0.7"/>
            </g>

            <g id="capacete">
                <defs>
                    <linearGradient id="helmetGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#9ca3af;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#6b7280;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#374151;stop-opacity:1" />
                    </linearGradient>
                    <radialGradient id="helmetVisorGrad" cx="50%" cy="30%" r="60%">
                        <stop offset="0%" style="stop-color:#1f2937;stop-opacity:0.3" />
                        <stop offset="100%" style="stop-color:#111827;stop-opacity:0.8" />
                    </radialGradient>
                </defs>
                <!-- Sombra -->
                <ellipse cx="33" cy="21" rx="18" ry="12" fill="#1f2937" opacity="0.2"/>
                <!-- Capacete principal -->
                <ellipse cx="32" cy="20" rx="18" ry="12" fill="url(#helmetGrad)" stroke="#4b5563" stroke-width="2"/>
                <!-- Detalhes de metal -->
                <rect x="22" y="15" width="20" height="2" fill="#d1d5db" rx="1"/>
                <rect x="24" y="18" width="16" height="1" fill="#d1d5db" opacity="0.8"/>
                <!-- Visor -->
                <rect x="24" y="16" width="16" height="8" fill="url(#helmetVisorGrad)" rx="2"/>
                <!-- Olhos vermelhos -->
                <circle cx="27" cy="20" r="2.5" fill="#ef4444" opacity="0.9"/>
                <circle cx="37" cy="20" r="2.5" fill="#ef4444" opacity="0.9"/>
                <circle cx="27" cy="19.5" r="1" fill="#fca5a5"/>
                <circle cx="37" cy="19.5" r="1" fill="#fca5a5"/>
                <!-- Proteções laterais -->
                <rect x="12" y="17" width="10" height="6" fill="#4b5563" rx="2"/>
                <rect x="42" y="17" width="10" height="6" fill="#4b5563" rx="2"/>
                <!-- Detalhes das proteções -->
                <rect x="14" y="18" width="6" height="1" fill="#6b7280"/>
                <rect x="44" y="18" width="6" height="1" fill="#6b7280"/>
                <!-- Respirador central -->
                <rect x="30" y="22" width="4" height="3" fill="#374151" rx="1"/>
                <circle cx="31" cy="23" r="0.5" fill="#6b7280"/>
                <circle cx="33" cy="23" r="0.5" fill="#6b7280"/>
            </g>

            <g id="gorro-helice">
                <defs>
                    <linearGradient id="beanieGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#34d399;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#22c55e;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#16a34a;stop-opacity:1" />
                    </linearGradient>
                    <linearGradient id="propellerGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#fbbf24;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#f59e0b;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#d97706;stop-opacity:1" />
                    </linearGradient>
                </defs>
                <!-- Sombra -->
                <ellipse cx="33" cy="21" rx="16" ry="10" fill="#047857" opacity="0.2"/>
                <!-- Gorro principal -->
                <ellipse cx="32" cy="20" rx="16" ry="10" fill="url(#beanieGrad)" stroke="#16a34a" stroke-width="1"/>
                <!-- Textura do gorro -->
                <ellipse cx="32" cy="18" rx="14" ry="8" fill="none" stroke="#10b981" stroke-width="0.5" opacity="0.6"/>
                <ellipse cx="32" cy="19" rx="12" ry="7" fill="none" stroke="#10b981" stroke-width="0.3" opacity="0.4"/>
                <!-- Haste da hélice -->
                <rect x="30" y="6" width="4" height="10" fill="#dc2626" rx="2"/>
                <circle cx="32" cy="11" r="2" fill="#b91c1c"/>
                <circle cx="32" cy="11" r="1" fill="#ef4444"/>
                <!-- Hélices com movimento implícito -->
                <g transform="rotate(15 32 8)">
                    <ellipse cx="20" cy="8" rx="10" ry="3" fill="url(#propellerGrad)" stroke="#d97706" stroke-width="0.5"/>
                    <ellipse cx="44" cy="8" rx="10" ry="3" fill="url(#propellerGrad)" stroke="#d97706" stroke-width="0.5"/>
                    <!-- Efeito de brilho nas hélices -->
                    <ellipse cx="20" cy="7" rx="8" ry="1" fill="#fef3c7" opacity="0.7"/>
                    <ellipse cx="44" cy="7" rx="8" ry="1" fill="#fef3c7" opacity="0.7"/>
                </g>
                <!-- Partículas de vento -->
                <circle cx="18" cy="12" r="0.5" fill="#a7f3d0" opacity="0.8"/>
                <circle cx="46" cy="10" r="0.3" fill="#a7f3d0" opacity="0.6"/>
                <circle cx="15" cy="15" r="0.4" fill="#a7f3d0" opacity="0.5"/>
                <circle cx="49" cy="13" r="0.6" fill="#a7f3d0" opacity="0.7"/>
            </g>

            <g id="chapeu-incomum">
                <defs>
                    <linearGradient id="luckyHatGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#a855f7;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#8b5cf6;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#7c3aed;stop-opacity:1" />
                    </linearGradient>
                    <radialGradient id="luckyGemGrad" cx="50%" cy="50%" r="50%">
                        <stop offset="0%" style="stop-color:#67e8f9;stop-opacity:1" />
                        <stop offset="70%" style="stop-color:#06b6d4;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#0891b2;stop-opacity:1" />
                    </radialGradient>
                </defs>
                <!-- Sombra -->
                <path d="M21 25 L33 9 L45 25 L41 21 L33 13 L25 21 Z" fill="#581c87" opacity="0.3"/>
                <!-- Chapéu principal com forma única -->
                <path d="M20 24 L32 8 L44 24 L40 20 L32 12 L24 20 Z" fill="url(#luckyHatGrad)" stroke="#7c3aed" stroke-width="1.5"/>
                <!-- Detalhes decorativos -->
                <path d="M22 22 L32 10 L42 22" fill="none" stroke="#c084fc" stroke-width="1" opacity="0.7"/>
                <!-- Gema central da sorte -->
                <circle cx="32" cy="20" r="4.5" fill="url(#luckyGemGrad)" stroke="#0891b2" stroke-width="1"/>
                <circle cx="32" cy="19" r="2" fill="#67e8f9" opacity="0.8"/>
                <circle cx="31" cy="18" r="1" fill="#cffafe"/>
                <!-- Borda dourada -->
                <path d="M28 24 L36 24" stroke="#fbbf24" stroke-width="3" stroke-linecap="round"/>
                <circle cx="26" cy="24" r="1" fill="#fbbf24"/>
                <circle cx="38" cy="24" r="1" fill="#fbbf24"/>
                <!-- Efeitos mágicos de sorte -->
                <g opacity="0.8">
                    <polygon points="25,16 26,17.5 27.5,17.5 26.25,18.75 26.75,20.25 25,19.25 23.25,20.25 23.75,18.75 22.5,17.5 24,17.5" 
                             fill="#fbbf24"/>
                    <polygon points="39,14 39.7,15.2 41,15.2 40.15,16.15 40.5,17.5 39,16.75 37.5,17.5 37.85,16.15 37,15.2 38.3,15.2" 
                             fill="#fbbf24"/>
                    <polygon points="28,11 28.5,12 29.5,12 28.75,12.75 29,13.75 28,13.25 27,13.75 27.25,12.75 26.5,12 27.5,12" 
                             fill="#fbbf24"/>
                </g>
            </g>

            <g id="chapeu-desafiante">
                <defs>
                    <linearGradient id="challengerGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#ef4444;stop-opacity:1" />
                        <stop offset="30%" style="stop-color:#dc2626;stop-opacity:1" />
                        <stop offset="70%" style="stop-color:#b91c1c;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#7f1d1d;stop-opacity:1" />
                    </linearGradient>
                    <radialGradient id="skullGrad" cx="50%" cy="50%" r="50%">
                        <stop offset="0%" style="stop-color:#f9fafb;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#e5e7eb;stop-opacity:1" />
                    </radialGradient>
                </defs>
                <!-- Sombra -->
                <ellipse cx="33" cy="22" rx="20" ry="8" fill="#7f1d1d" opacity="0.3"/>
                <!-- Chapéu principal (estilo pirata/desafiante) -->
                <ellipse cx="32" cy="20" rx="19" ry="7" fill="url(#challengerGrad)" stroke="#991b1b" stroke-width="2"/>
                <!-- Dobra do chapéu -->
                <ellipse cx="32" cy="18" rx="17" ry="6" fill="none" stroke="#dc2626" stroke-width="1" opacity="0.7"/>
                <!-- Caveira central -->
                <ellipse cx="32" cy="16" rx="6" ry="5" fill="url(#skullGrad)" stroke="#9ca3af" stroke-width="1"/>
                <!-- Olhos da caveira -->
                <circle cx="29" cy="15" r="1.5" fill="#1f2937"/>
                <circle cx="35" cy="15" r="1.5" fill="#1f2937"/>
                <!-- Nariz da caveira -->
                <polygon points="32,16.5 31,17.5 33,17.5" fill="#1f2937"/>
                <!-- Boca da caveira -->
                <rect x="30" y="18" width="4" height="0.5" fill="#1f2937" rx="0.25"/>
                <rect x="30.5" y="18.8" width="0.5" height="1" fill="#1f2937"/>
                <rect x="31.5" y="18.8" width="0.5" height="1.2" fill="#1f2937"/>
                <rect x="32.5" y="18.8" width="0.5" height="1" fill="#1f2937"/>
                <rect x="33.5" y="18.8" width="0.5" height="1" fill="#1f2937"/>
                <!-- Ossos cruzados -->
                <g transform="rotate(45 32 16)">
                    <rect x="26" y="15.5" width="12" height="1" fill="#e5e7eb" rx="0.5"/>
                </g>
                <g transform="rotate(-45 32 16)">
                    <rect x="26" y="15.5" width="12" height="1" fill="#e5e7eb" rx="0.5"/>
                </g>
                <!-- Detalhes dourados do desafiante -->
                <circle cx="18" cy="18" r="2" fill="#fbbf24" stroke="#d97706" stroke-width="1"/>
                <circle cx="46" cy="18" r="2" fill="#fbbf24" stroke="#d97706" stroke-width="1"/>
                <polygon points="18,16.5 19,17.5 18,18.5 17,17.5" fill="#f59e0b"/>
                <polygon points="46,16.5 47,17.5 46,18.5 45,17.5" fill="#f59e0b"/>
                <!-- Plumas -->
                <g opacity="0.9">
                    <ellipse cx="14" cy="15" rx="3" ry="8" fill="#065f46" stroke="#047857" stroke-width="0.5" transform="rotate(-30 14 15)"/>
                    <ellipse cx="50" cy="15" rx="3" ry="8" fill="#065f46" stroke="#047857" stroke-width="0.5" transform="rotate(30 50 15)"/>
                    <ellipse cx="12" cy="13" rx="2" ry="6" fill="#064e3b" stroke="#047857" stroke-width="0.3" transform="rotate(-45 12 13)"/>
                    <ellipse cx="52" cy="13" rx="2" ry="6" fill="#064e3b" stroke="#047857" stroke-width="0.3" transform="rotate(45 52 13)"/>
                </g>
            </g>

            <g id="fedora">
                <defs>
                    <linearGradient id="fedoraGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#4b5563;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#374151;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#1f2937;stop-opacity:1" />
                    </linearGradient>
                    <linearGradient id="fedoraBandGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#7c2d12;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#92400e;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#a16207;stop-opacity:1" />
                    </linearGradient>
                </defs>
                <!-- Sombra -->
                <ellipse cx="33" cy="25" rx="22" ry="3" fill="#111827" opacity="0.4"/>
                <!-- Aba do chapéu -->
                <ellipse cx="32" cy="22" rx="20" ry="5" fill="url(#fedoraGrad)" stroke="#1f2937" stroke-width="1"/>
                <!-- Copa do chapéu -->
                <ellipse cx="32" cy="15" rx="12" ry="9" fill="url(#fedoraGrad)" stroke="#374151" stroke-width="1"/>
                <!-- Vinco central -->
                <ellipse cx="32" cy="13" rx="8" ry="6" fill="none" stroke="#6b7280" stroke-width="0.5" opacity="0.6"/>
                <line x1="32" y1="8" x2="32" y2="18" stroke="#6b7280" stroke-width="0.8" opacity="0.7"/>
                <!-- Faixa decorativa -->
                <rect x="22" y="16" width="20" height="3" fill="url(#fedoraBandGrad)" rx="1.5"/>
                <rect x="23" y="16.5" width="18" height="2" fill="#b45309" opacity="0.7" rx="1"/>
                <!-- Detalhes da faixa -->
                <rect x="25" y="17" width="2" height="1" fill="#fbbf24" rx="0.5"/>
                <rect x="29" y="17" width="2" height="1" fill="#fbbf24" rx="0.5"/>
                <rect x="33" y="17" width="2" height="1" fill="#fbbf24" rx="0.5"/>
                <rect x="37" y="17" width="2" height="1" fill="#fbbf24" rx="0.5"/>
                <!-- Pluma elegante -->
                <ellipse cx="38" cy="12" rx="2" ry="7" fill="#7c3aed" stroke="#6d28d9" stroke-width="0.5" transform="rotate(20 38 12)"/>
                <ellipse cx="39" cy="10" rx="1.5" ry="5" fill="#8b5cf6" stroke="#7c3aed" stroke-width="0.3" transform="rotate(25 39 10)"/>
                <!-- Brilho sutil -->
                <ellipse cx="28" cy="12" rx="6" ry="4" fill="#6b7280" opacity="0.3" transform="rotate(-15 28 12)"/>
                <!-- Reroll symbol (dado) -->
                <rect x="40" y="18" width="4" height="4" fill="#1f2937" stroke="#6b7280" stroke-width="0.5" rx="0.5"/>
                <circle cx="41" cy="19" r="0.3" fill="#d1d5db"/>
                <circle cx="43" cy="19" r="0.3" fill="#d1d5db"/>
                <circle cx="41" cy="21" r="0.3" fill="#d1d5db"/>
                <circle cx="43" cy="21" r="0.3" fill="#d1d5db"/>
                <circle cx="42" cy="20" r="0.3" fill="#d1d5db"/>
            </g>

            <!-- Cajados Aprimorados -->
            <g id="cajado-mago">
                <defs>
                    <linearGradient id="staffWoodGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#a16207;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#92400e;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#78350f;stop-opacity:1" />
                    </linearGradient>
                    <radialGradient id="wizardOrbGrad" cx="50%" cy="50%" r="50%">
                        <stop offset="0%" style="stop-color:#93c5fd;stop-opacity:1" />
                        <stop offset="30%" style="stop-color:#60a5fa;stop-opacity:1" />
                        <stop offset="70%" style="stop-color:#3b82f6;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#1d4ed8;stop-opacity:1" />
                    </radialGradient>
                </defs>
                <!-- Sombra do cajado -->
                <rect x="31" y="9" width="4" height="48" fill="#451a03" opacity="0.3"/>
                <!-- Haste do cajado com textura -->
                <rect x="30" y="8" width="4" height="48" fill="url(#staffWoodGrad)" stroke="#78350f" stroke-width="1" rx="2"/>
                <!-- Detalhes de madeira -->
                <rect x="30.5" y="16" width="3" height="1" fill="#a16207" opacity="0.7"/>
                <rect x="30.5" y="24" width="3" height="1" fill="#a16207" opacity="0.7"/>
                <rect x="30.5" y="32" width="3" height="1" fill="#a16207" opacity="0.7"/>
                <rect x="30.5" y="40" width="3" height="1" fill="#a16207" opacity="0.7"/>
                <rect x="30.5" y="48" width="3" height="1" fill="#a16207" opacity="0.7"/>
                <!-- Orbe mágico principal -->
                <circle cx="32" cy="12" r="7" fill="url(#wizardOrbGrad)" stroke="#1d4ed8" stroke-width="2"/>
                <circle cx="32" cy="12" r="4" fill="#60a5fa" opacity="0.8"/>
                <circle cx="32" cy="10" r="2" fill="#93c5fd"/>
                <circle cx="31" cy="9" r="1" fill="#dbeafe"/>
                <!-- Runas mágicas ao redor -->
                <g opacity="0.7">
                    <text x="26" y="8" font-family="serif" font-size="4" fill="#3b82f6">✦</text>
                    <text x="38" y="8" font-family="serif" font-size="4" fill="#3b82f6">✦</text>
                    <text x="24" y="16" font-family="serif" font-size="3" fill="#60a5fa">◊</text>
                    <text x="40" y="16" font-family="serif" font-size="3" fill="#60a5fa">◊</text>
                </g>
                <!-- Base do cajado -->
                <path d="M26 52 L32 60 L38 52" fill="url(#staffWoodGrad)" stroke="#78350f" stroke-width="1"/>
                <circle cx="32" cy="54" r="1" fill="#92400e"/>
            </g>

            <g id="cajado-esmeralda">
                <defs>
                    <linearGradient id="emeraldStaffGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#047857;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#065f46;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#064e3b;stop-opacity:1" />
                    </linearGradient>
                    <linearGradient id="emeraldGemGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#6ee7b7;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#10b981;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#059669;stop-opacity:1" />
                    </linearGradient>
                </defs>
                <!-- Sombra -->
                <rect x="31" y="9" width="4" height="48" fill="#022c22" opacity="0.3"/>
                <!-- Haste esmeralda -->
                <rect x="30" y="8" width="4" height="48" fill="url(#emeraldStaffGrad)" stroke="#047857" stroke-width="1" rx="2"/>
                <!-- Veios de esmeralda na haste -->
                <line x1="31" y1="16" x2="31" y2="48" stroke="#10b981" stroke-width="0.5" opacity="0.7"/>
                <line x1="33" y1="16" x2="33" y2="48" stroke="#10b981" stroke-width="0.5" opacity="0.7"/>
                <!-- Gema esmeralda no topo -->
                <polygon points="32,4 28,8 30,12 32,10 34,12 36,8" fill="url(#emeraldGemGrad)" stroke="#059669" stroke-width="1.5"/>
                <!-- Facetas da gema -->
                <polygon points="32,5 30,7 32,9 34,7" fill="#6ee7b7" opacity="0.8"/>
                <polygon points="32,6 31,7 32,8 33,7" fill="#a7f3d0"/>
                <!-- Cristais menores -->
                <circle cx="29" cy="10" r="1.5" fill="#10b981" opacity="0.8"/>
                <circle cx="35" cy="10" r="1.5" fill="#10b981" opacity="0.8"/>
                <circle cx="32" cy="7" r="1" fill="#6ee7b7"/>
                <!-- Partículas mágicas -->
                <g opacity="0.6">
                    <circle cx="26" cy="12" r="0.5" fill="#34d399"/>
                    <circle cx="38" cy="14" r="0.3" fill="#34d399"/>
                    <circle cx="28" cy="16" r="0.4" fill="#6ee7b7"/>
                    <circle cx="36" cy="18" r="0.6" fill="#6ee7b7"/>
                    <circle cx="24" cy="20" r="0.3" fill="#10b981"/>
                    <circle cx="40" cy="22" r="0.4" fill="#10b981"/>
                </g>
                <!-- Base -->
                <path d="M26 52 L32 60 L38 52" fill="url(#emeraldStaffGrad)" stroke="#047857" stroke-width="1"/>
                <circle cx="32" cy="54" r="1" fill="#10b981"/>
            </g>

            <g id="tridente">
                <defs>
                    <linearGradient id="tridentGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#0ea5e9;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#0284c7;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#0369a1;stop-opacity:1" />
                    </linearGradient>
                </defs>
                <!-- Sombra -->
                <rect x="31" y="17" width="4" height="44" fill="#0c4a6e" opacity="0.3"/>
                <!-- Haste aquática -->
                <rect x="30" y="16" width="4" height="44" fill="url(#tridentGrad)" stroke="#0369a1" stroke-width="1" rx="2"/>
                <!-- Detalhes aquáticos na haste -->
                <g opacity="0.7">
                    <ellipse cx="32" cy="24" rx="3" ry="1" fill="#38bdf8"/>
                    <ellipse cx="32" cy="32" rx="3" ry="1" fill="#38bdf8"/>
                    <ellipse cx="32" cy="40" rx="3" ry="1" fill="#38bdf8"/>
                    <ellipse cx="32" cy="48" rx="3" ry="1" fill="#38bdf8"/>
                </g>
                <!-- Pontas do tridente -->
                <!-- Ponta central -->
                <polygon points="32,4 30,14 34,14" fill="url(#tridentGrad)" stroke="#0369a1" stroke-width="1"/>
                <polygon points="32,6 31,12 33,12" fill="#7dd3fc"/>
                <!-- Ponta esquerda -->
                <polygon points="24,8 26,16 28,14" fill="url(#tridentGrad)" stroke="#0369a1" stroke-width="1"/>
                <polygon points="24,9 26,14 27,13" fill="#7dd3fc" opacity="0.8"/>
                <!-- Ponta direita -->
                <polygon points="40,8 38,16 36,14" fill="url(#tridentGrad)" stroke="#0369a1" stroke-width="1"/>
                <polygon points="40,9 38,14 37,13" fill="#7dd3fc" opacity="0.8"/>
                <!-- Conectores -->
                <line x1="28" y1="14" x2="30" y2="14" stroke="#0369a1" stroke-width="2"/>
                <line x1="34" y1="14" x2="36" y2="14" stroke="#0369a1" stroke-width="2"/>
                <!-- Efeitos aquáticos -->
                <g opacity="0.5">
                    <circle cx="24" cy="12" r="1" fill="#67e8f9"/>
                    <circle cx="40" cy="12" r="1" fill="#67e8f9"/>
                    <circle cx="32" cy="8" r="1" fill="#67e8f9"/>
                    <circle cx="32" cy="6" r="0.5" fill="#a5f3fc"/>
                </g>
                <!-- Base -->
                <path d="M26 56 L32 64 L38 56" fill="url(#tridentGrad)" stroke="#0369a1" stroke-width="1"/>
                <circle cx="32" cy="58" r="1" fill="#38bdf8"/>
            </g>

            <g id="boomstaff">
                <defs>
                    <linearGradient id="boomStaffGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#dc2626;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#b91c1c;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#7f1d1d;stop-opacity:1" />
                    </linearGradient>
                    <radialGradient id="explosiveOrbGrad" cx="50%" cy="50%" r="50%">
                        <stop offset="0%" style="stop-color:#fde047;stop-opacity:1" />
                        <stop offset="30%" style="stop-color:#fbbf24;stop-opacity:1" />
                        <stop offset="70%" style="stop-color:#f59e0b;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#d97706;stop-opacity:1" />
                    </radialGradient>
                </defs>
                <!-- Sombra -->
                <rect x="31" y="9" width="4" height="48" fill="#450a0a" opacity="0.3"/>
                <!-- Haste explosiva -->
                <rect x="30" y="8" width="4" height="48" fill="url(#boomStaffGrad)" stroke="#92400e" stroke-width="1" rx="2"/>
                <!-- Detalhes explosivos na haste -->
                <g opacity="0.6">
                    <rect x="29" y="20" width="6" height="2" fill="#f59e0b" rx="1"/>
                    <rect x="29" y="28" width="6" height="2" fill="#f59e0b" rx="1"/>
                    <rect x="29" y="36" width="6" height="2" fill="#f59e0b" rx="1"/>
                    <rect x="29" y="44" width="6" height="2" fill="#f59e0b" rx="1"/>
                </g>
                <!-- Orbe explosivo principal -->
                <circle cx="32" cy="12" r="9" fill="url(#explosiveOrbGrad)" stroke="#b91c1c" stroke-width="2"/>
                <circle cx="32" cy="12" r="6" fill="#fbbf24" opacity="0.8"/>
                <circle cx="32" cy="11" r="3" fill="#fde047"/>
                <circle cx="31" cy="10" r="1.5" fill="#fef3c7"/>
                <!-- Mecânica explosiva no topo -->
                <rect x="28" y="6" width="8" height="6" fill="#374151" stroke="#1f2937" stroke-width="1" rx="1"/>
                <rect x="29" y="7" width="6" height="4" fill="#4b5563" rx="0.5"/>
                <!-- Botão detonador -->
                <circle cx="32" cy="9" r="1.5" fill="#ef4444" stroke="#dc2626" stroke-width="0.5"/>
                <circle cx="32" cy="9" r="0.8" fill="#fca5a5"/>
                <!-- Luzes de aviso -->
                <circle cx="29" cy="8" r="0.5" fill="#ef4444" opacity="0.8"/>
                <circle cx="35" cy="8" r="0.5" fill="#ef4444" opacity="0.8"/>
                <!-- Fagulhas -->
                <g opacity="0.7">
                    <circle cx="26" cy="10" r="0.3" fill="#fde047"/>
                    <circle cx="38" cy="14" r="0.4" fill="#f59e0b"/>
                    <circle cx="24" cy="16" r="0.2" fill="#fbbf24"/>
                    <circle cx="40" cy="18" r="0.5" fill="#fde047"/>
                    <circle cx="22" cy="20" r="0.3" fill="#f59e0b"/>
                    <circle cx="42" cy="22" r="0.2" fill="#fbbf24"/>
                </g>
                <!-- Base -->
                <path d="M26 52 L32 60 L38 52" fill="url(#boomStaffGrad)" stroke="#7c2d12" stroke-width="1"/>
                <circle cx="32" cy="54" r="1" fill="#f59e0b"/>
            </g>

            <g id="cajado-trovao">
                <defs>
                    <linearGradient id="thunderStaffGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#3b82f6;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#1e40af;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#1e3a8a;stop-opacity:1" />
                    </linearGradient>
                    <linearGradient id="lightningGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#fef3c7;stop-opacity:1" />
                        <stop offset="30%" style="stop-color:#fde047;stop-opacity:1" />
                        <stop offset="70%" style="stop-color:#fbbf24;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#f59e0b;stop-opacity:1" />
                    </linearGradient>
                </defs>
                <!-- Sombra -->
                <rect x="31" y="9" width="4" height="48" fill="#1e3a8a" opacity="0.3"/>
                <!-- Haste elétrica -->
                <rect x="30" y="8" width="4" height="48" fill="url(#thunderStaffGrad)" stroke="#1d4ed8" stroke-width="1" rx="2"/>
                <!-- Circuitos elétricos -->
                <g opacity="0.7">
                    <line x1="29" y1="18" x2="35" y2="18" stroke="#60a5fa" stroke-width="0.5"/>
                    <line x1="29" y1="26" x2="35" y2="26" stroke="#60a5fa" stroke-width="0.5"/>
                    <line x1="29" y1="34" x2="35" y2="34" stroke="#60a5fa" stroke-width="0.5"/>
                    <line x1="29" y1="42" x2="35" y2="42" stroke="#60a5fa" stroke-width="0.5"/>
                    <circle cx="29" cy="18" r="1" fill="#93c5fd"/>
                    <circle cx="35" cy="26" r="1" fill="#93c5fd"/>
                    <circle cx="29" cy="34" r="1" fill="#93c5fd"/>
                    <circle cx="35" cy="42" r="1" fill="#93c5fd"/>
                </g>
                <!-- Raio principal -->
                <path d="M28 4 L36 12 L30 12 L34 20 L26 12 L32 12 Z" fill="url(#lightningGrad)" stroke="#f59e0b" stroke-width="1.5"/>
                <!-- Detalhes do raio -->
                <path d="M29 6 L34 10 L31 10 L33 16 L28 10 L31 10 Z" fill="#fef3c7" opacity="0.8"/>
                <!-- Centro energético -->
                <circle cx="32" cy="12" r="3" fill="#ffffff" opacity="0.9"/>
                <circle cx="32" cy="12" r="2" fill="#fde047"/>
                <circle cx="32" cy="11.5" r="1" fill="#fef3c7"/>
                <!-- Descargas elétricas -->
                <g opacity="0.6">
                    <line x1="26" y1="8" x2="24" y2="6" stroke="#fbbf24" stroke-width="1"/>
                    <line x1="38" y1="8" x2="40" y2="6" stroke="#fbbf24" stroke-width="1"/>
                    <line x1="26" y1="16" x2="22" y2="14" stroke="#fbbf24" stroke-width="0.8"/>
                    <line x1="38" y1="16" x2="42" y2="14" stroke="#fbbf24" stroke-width="0.8"/>
                    <circle cx="24" cy="6" r="0.5" fill="#fde047"/>
                    <circle cx="40" cy="6" r="0.5" fill="#fde047"/>
                    <circle cx="22" cy="14" r="0.3" fill="#fbbf24"/>
                    <circle cx="42" cy="14" r="0.3" fill="#fbbf24"/>
                </g>
                <!-- Base -->
                <path d="M26 52 L32 60 L38 52" fill="url(#thunderStaffGrad)" stroke="#1e40af" stroke-width="1"/>
                <circle cx="32" cy="54" r="1" fill="#60a5fa"/>
            </g>

            <g id="ponta-congelada">
                <defs>
                    <linearGradient id="iceStaffGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#22d3ee;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#0891b2;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#0e7490;stop-opacity:1" />
                    </linearGradient>
                    <radialGradient id="iceGemGrad" cx="50%" cy="50%" r="50%">
                        <stop offset="0%" style="stop-color:#cffafe;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#67e8f9;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#06b6d4;stop-opacity:1" />
                    </radialGradient>
                </defs>
                <!-- Sombra -->
                <rect x="31" y="9" width="4" height="48" fill="#164e63" opacity="0.3"/>
                <!-- Haste gelada -->
                <rect x="30" y="8" width="4" height="48" fill="url(#iceStaffGrad)" stroke="#0d9488" stroke-width="1" rx="2"/>
                <!-- Cristais de gelo na haste -->
                <g opacity="0.7">
                    <polygon points="29,20 31,18 33,20 31,22" fill="#a5f3fc"/>
                    <polygon points="33,28 35,26 35,30 33,32" fill="#a5f3fc"/>
                    <polygon points="29,36 31,34 33,36 31,38" fill="#a5f3fc"/>
                    <polygon points="33,44 35,42 35,46 33,48" fill="#a5f3fc"/>
                </g>
                <!-- Cristal de gelo principal -->
                <path d="M32 4 L28 8 L30 12 L32 10 L34 12 L36 8 Z" fill="url(#iceGemGrad)" stroke="#0891b2" stroke-width="1.5"/>
                <!-- Facetas internas -->
                <path d="M32 5 L29 8 L31 10 L32 9 L33 10 L35 8 Z" fill="#cffafe" opacity="0.8"/>
                <path d="M32 6 L30 8 L32 9 L34 8 Z" fill="#ffffff" opacity="0.9"/>
                <!-- Núcleo gelado -->
                <circle cx="32" cy="8" r="3.5" fill="url(#iceGemGrad)" opacity="0.8"/>
                <circle cx="32" cy="8" r="2" fill="#67e8f9"/>
                <circle cx="32" cy="7.5" r="1" fill="#cffafe"/>
                <!-- Cristais flutuantes -->
                <circle cx="29" cy="10" r="1.5" fill="#67e8f9" opacity="0.8"/>
                <circle cx="35" cy="10" r="1.5" fill="#67e8f9" opacity="0.8"/>
                <polygon points="29,9 30,8 29,7 28,8" fill="#cffafe"/>
                <polygon points="35,9 36,8 35,7 34,8" fill="#cffafe"/>
                <!-- Partículas de neve -->
                <g opacity="0.6">
                    <circle cx="26" cy="12" r="0.3" fill="#ffffff"/>
                    <circle cx="38" cy="14" r="0.4" fill="#ffffff"/>
                    <circle cx="24" cy="16" r="0.2" fill="#cffafe"/>
                    <circle cx="40" cy="18" r="0.5" fill="#ffffff"/>
                    <circle cx="22" cy="20" r="0.3" fill="#cffafe"/>
                    <circle cx="42" cy="22" r="0.2" fill="#ffffff"/>
                    <polygon points="25,14 25.5,14.5 25,15 24.5,14.5" fill="#cffafe"/>
                    <polygon points="39,16 39.5,16.5 39,17 38.5,16.5" fill="#cffafe"/>
                </g>
                <!-- Base -->
                <path d="M26 52 L32 60 L38 52" fill="url(#iceStaffGrad)" stroke="#0f766e" stroke-width="1"/>
                <circle cx="32" cy="54" r="1" fill="#67e8f9"/>
            </g>

            <g id="cajado-arco-iris">
                <defs>
                    <linearGradient id="rainbowStaffGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#fbbf24;stop-opacity:1" />
                        <stop offset="16%" style="stop-color:#f59e0b;stop-opacity:1" />
                        <stop offset="33%" style="stop-color:#ef4444;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#8b5cf6;stop-opacity:1" />
                        <stop offset="66%" style="stop-color:#3b82f6;stop-opacity:1" />
                        <stop offset="83%" style="stop-color:#10b981;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#22c55e;stop-opacity:1" />
                    </linearGradient>
                    <linearGradient id="rainbowHandleGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#a855f7;stop-opacity:1" />
                        <stop offset="50%" style="stop-color:#7c3aed;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#5b21b6;stop-opacity:1" />
                    </linearGradient>
                    <radialGradient id="rainbowOrbGrad" cx="50%" cy="50%" r="50%">
                        <stop offset="0%" style="stop-color:#ffffff;stop-opacity:1" />
                        <stop offset="20%" style="stop-color:#fde047;stop-opacity:1" />
                        <stop offset="40%" style="stop-color:#f97316;stop-opacity:1" />
                        <stop offset="60%" style="stop-color:#ef4444;stop-opacity:1" />
                        <stop offset="80%" style="stop-color:#8b5cf6;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#3b82f6;stop-opacity:1" />
                    </radialGradient>
                    <linearGradient id="rainbowSpiralGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#ef4444;stop-opacity:0.8" />
                        <stop offset="25%" style="stop-color:#f97316;stop-opacity:0.8" />
                        <stop offset="50%" style="stop-color:#22c55e;stop-opacity:0.8" />
                        <stop offset="75%" style="stop-color:#3b82f6;stop-opacity:0.8" />
                        <stop offset="100%" style="stop-color:#8b5cf6;stop-opacity:0.8" />
                    </linearGradient>
                </defs>
                <!-- Sombra mágica -->
                <rect x="31" y="9" width="4" height="48" fill="#581c87" opacity="0.4"/>
                <circle cx="33" cy="13" r="10" fill="#1e1b4b" opacity="0.3"/>
                
                <!-- Haste cristalina com cores do arco-íris -->
                <rect x="30" y="8" width="4" height="48" fill="url(#rainbowHandleGrad)" stroke="#4c1d95" stroke-width="1" rx="2"/>
                
                <!-- Segmentos coloridos na haste -->
                <rect x="29" y="16" width="6" height="4" fill="#ef4444" opacity="0.6" rx="1"/>
                <rect x="29" y="22" width="6" height="4" fill="#f97316" opacity="0.6" rx="1"/>
                <rect x="29" y="28" width="6" height="4" fill="#eab308" opacity="0.6" rx="1"/>
                <rect x="29" y="34" width="6" height="4" fill="#22c55e" opacity="0.6" rx="1"/>
                <rect x="29" y="40" width="6" height="4" fill="#3b82f6" opacity="0.6" rx="1"/>
                <rect x="29" y="46" width="6" height="4" fill="#8b5cf6" opacity="0.6" rx="1"/>
                
                <!-- Orbe principal do arco-íris -->
                <circle cx="32" cy="12" r="11" fill="url(#rainbowOrbGrad)" stroke="#fbbf24" stroke-width="2"/>
                <circle cx="32" cy="12" r="8" fill="url(#rainbowSpiralGrad)" opacity="0.9"/>
                <circle cx="32" cy="12" r="5" fill="#ffffff" opacity="0.9"/>
                <circle cx="32" cy="11" r="2" fill="#fde047"/>
                
                <!-- Cristais arco-íris flutuantes -->
                <g opacity="0.8">
                    <polygon points="22,8 24,10 22,12 20,10" fill="#ef4444"/>
                    <polygon points="42,8 44,10 42,12 40,10" fill="#f97316"/>
                    <polygon points="18,14 20,16 18,18 16,16" fill="#eab308"/>
                    <polygon points="46,14 48,16 46,18 44,16" fill="#22c55e"/>
                    <polygon points="20,20 22,22 20,24 18,22" fill="#3b82f6"/>
                    <polygon points="44,20 46,22 44,24 42,22" fill="#8b5cf6"/>
                </g>
                
                <!-- Espiral mágica ao redor do orbe -->
                <g opacity="0.7">
                    <circle cx="32" cy="12" r="14" fill="none" stroke="url(#rainbowStaffGrad)" stroke-width="1.5" stroke-dasharray="2,2"/>
                    <circle cx="32" cy="12" r="16" fill="none" stroke="url(#rainbowStaffGrad)" stroke-width="1" stroke-dasharray="3,3" opacity="0.6"/>
                    <circle cx="32" cy="12" r="18" fill="none" stroke="url(#rainbowStaffGrad)" stroke-width="0.5" stroke-dasharray="4,4" opacity="0.4"/>
                </g>
                
                <!-- Anéis mágicos coloridos -->
                <g transform="rotate(15 32 12)" opacity="0.6">
                    <ellipse cx="32" cy="4" rx="20" ry="4" fill="none" stroke="#ef4444" stroke-width="1.5" opacity="0.7"/>
                    <ellipse cx="32" cy="20" rx="20" ry="4" fill="none" stroke="#3b82f6" stroke-width="1.5" opacity="0.7"/>
                </g>
                <g transform="rotate(-15 32 12)" opacity="0.6">
                    <ellipse cx="12" cy="12" rx="4" ry="16" fill="none" stroke="#22c55e" stroke-width="1.5" opacity="0.7"/>
                    <ellipse cx="52" cy="12" rx="4" ry="16" fill="none" stroke="#8b5cf6" stroke-width="1.5" opacity="0.7"/>
                </g>
                
                <!-- Pontos de luz mágica flutuantes -->
                <g opacity="0.8">
                    <circle cx="26" cy="6" r="1" fill="#fde047"/>
                    <circle cx="38" cy="6" r="0.8" fill="#ef4444"/>
                    <circle cx="24" cy="18" r="1.2" fill="#22c55e"/>
                    <circle cx="40" cy="18" r="0.6" fill="#3b82f6"/>
                    <circle cx="22" cy="12" r="0.7" fill="#f97316"/>
                    <circle cx="42" cy="12" r="1.1" fill="#8b5cf6"/>
                    <circle cx="26" cy="24" r="0.5" fill="#eab308"/>
                    <circle cx="38" cy="24" r="0.9" fill="#10b981"/>
                </g>
                
                <!-- Trilhos de energia colorida -->
                <g opacity="0.5">
                    <line x1="32" y1="23" x2="28" y2="30" stroke="#ef4444" stroke-width="2" stroke-linecap="round"/>
                    <line x1="32" y1="23" x2="36" y2="30" stroke="#3b82f6" stroke-width="2" stroke-linecap="round"/>
                    <line x1="32" y1="23" x2="32" y2="35" stroke="#22c55e" stroke-width="2" stroke-linecap="round"/>
                    <line x1="32" y1="23" x2="25" y2="28" stroke="#f97316" stroke-width="1.5" stroke-linecap="round"/>
                    <line x1="32" y1="23" x2="39" y2="28" stroke="#8b5cf6" stroke-width="1.5" stroke-linecap="round"/>
                </g>
                
                <!-- Runas místicas do arco-íris -->
                <g opacity="0.7" font-family="serif" font-size="3">
                    <text x="28" y="3" fill="#ef4444">✦</text>
                    <text x="36" y="3" fill="#f97316">✧</text>
                    <text x="22" y="10" fill="#eab308">◈</text>
                    <text x="42" y="10" fill="#22c55e">◇</text>
                    <text x="26" y="26" fill="#3b82f6">✧</text>
                    <text x="38" y="26" fill="#8b5cf6">✦</text>
                </g>
                
                <!-- Base com cristal arco-íris -->
                <path d="M26 52 L32 60 L38 52" fill="url(#rainbowHandleGrad)" stroke="#4c1d95" stroke-width="1"/>
                <polygon points="32,54 30,56 32,58 34,56" fill="url(#rainbowOrbGrad)" stroke="#fbbf24" stroke-width="0.5"/>
                <circle cx="32" cy="56" r="1.5" fill="#fde047"/>
            </g>

            <!-- Cards/Upgrade Icons -->
            <g id="catalyst-icon">
                <circle cx="32" cy="32" r="24" fill="#7c3aed" stroke="#8b5cf6" stroke-width="2"/>
                <path d="M20 28 L32 16 L44 28 L32 40 Z" fill="#fbbf24" stroke="#f59e0b" stroke-width="1"/>
                <circle cx="32" cy="28" r="4" fill="#06b6d4"/>
                <path d="M28 32 L36 32 M32 28 L32 36" stroke="#ffffff" stroke-width="2"/>
            </g>

            <g id="eyesight-icon">
                <circle cx="32" cy="32" r="24" fill="#059669" stroke="#10b981" stroke-width="2"/>
                <ellipse cx="32" cy="32" rx="12" ry="8" fill="#ffffff" stroke="#1f2937" stroke-width="2"/>
                <circle cx="32" cy="32" r="6" fill="#1e40af"/>
                <circle cx="32" cy="32" r="3" fill="#1f2937"/>
                <circle cx="34" cy="30" r="1" fill="#ffffff"/>
            </g>

            <g id="growth-icon">
                <circle cx="32" cy="32" r="24" fill="#22c55e" stroke="#16a34a" stroke-width="2"/>
                <path d="M32 16 L28 24 L32 20 L36 24 Z" fill="#065f46"/>
                <rect x="30" y="20" width="4" height="20" fill="#16a34a"/>
                <ellipse cx="20" cy="44" rx="6" ry="3" fill="#22c55e"/>
                <ellipse cx="44" cy="44" rx="6" ry="3" fill="#22c55e"/>
                <path d="M18 40 L22 36 M46 40 L42 36" stroke="#16a34a" stroke-width="2"/>
            </g>

            <g id="impulse-icon">
                <circle cx="32" cy="32" r="24" fill="#dc2626" stroke="#b91c1c" stroke-width="2"/>
                <path d="M16 32 L24 28 L24 36 Z" fill="#fbbf24"/>
                <path d="M28 32 L36 28 L36 36 Z" fill="#fbbf24"/>
                <path d="M40 32 L48 28 L48 36 Z" fill="#fbbf24"/>
                <circle cx="32" cy="32" r="3" fill="#ffffff"/>
            </g>

            <g id="renew-icon">
                <circle cx="32" cy="32" r="24" fill="#06b6d4" stroke="#0891b2" stroke-width="2"/>
                <path d="M24 24 Q32 16 40 24 Q32 32 24 24" fill="none" stroke="#ffffff" stroke-width="3"/>
                <circle cx="28" cy="28" r="2" fill="#ffffff"/>
                <circle cx="36" cy="28" r="2" fill="#ffffff"/>
                <path d="M20 20 L28 28 L20 36" fill="#22c55e"/>
                <path d="M44 20 L36 28 L44 36" fill="#22c55e"/>
            </g>

            <!-- Ícones de cartas comuns -->
            <g id="resist-icon">
                <circle cx="32" cy="32" r="24" fill="#374151" stroke="#4b5563" stroke-width="2"/>
                <rect x="22" y="22" width="20" height="20" rx="2" fill="none" stroke="#ffffff" stroke-width="3"/>
                <circle cx="32" cy="32" r="8" fill="#ef4444" stroke="#dc2626" stroke-width="2"/>
                <path d="M28 28 L36 36 M36 28 L28 36" stroke="#ffffff" stroke-width="2"/>
            </g>

            <g id="resonance-icon">
                <circle cx="32" cy="32" r="24" fill="#7c3aed" stroke="#8b5cf6" stroke-width="2"/>
                <circle cx="32" cy="32" r="16" fill="none" stroke="#ffffff" stroke-width="2"/>
                <circle cx="32" cy="32" r="12" fill="none" stroke="#ffffff" stroke-width="2"/>
                <circle cx="32" cy="32" r="8" fill="none" stroke="#ffffff" stroke-width="2"/>
                <circle cx="32" cy="32" r="4" fill="#ffffff"/>
            </g>

            <g id="souls-icon">
                <circle cx="32" cy="32" r="24" fill="#1e1b4b" stroke="#3730a3" stroke-width="2"/>
                <path d="M32 12 L24 20 L24 32 L32 40 L40 32 L40 20 Z" fill="#8b5cf6" stroke="#7c3aed" stroke-width="2"/>
                <circle cx="32" cy="28" r="6" fill="#ffffff" stroke="#7c3aed" stroke-width="1"/>
                <circle cx="32" cy="28" r="3" fill="#7c3aed"/>
                <path d="M28 24 L36 24 M28 32 L36 32" stroke="#ffffff" stroke-width="1"/>
            </g>

            <g id="stability-icon">
                <circle cx="32" cy="32" r="24" fill="#0f766e" stroke="#14b8a6" stroke-width="2"/>
                <path d="M16 32 L48 32 M20 28 L44 28 M20 36 L44 36" stroke="#ffffff" stroke-width="3"/>
                <circle cx="24" cy="32" r="3" fill="#fbbf24"/>
                <circle cx="32" cy="32" r="3" fill="#fbbf24"/>
                <circle cx="40" cy="32" r="3" fill="#fbbf24"/>
            </g>

            <g id="swift-icon">
                <circle cx="32" cy="32" r="24" fill="#059669" stroke="#10b981" stroke-width="2"/>
                <path d="M16 32 L24 28 L24 36 Z" fill="#ffffff"/>
                <path d="M28 32 L36 28 L36 36 Z" fill="#ffffff"/>
                <path d="M40 32 L48 28 L48 36 Z" fill="#ffffff"/>
                <circle cx="20" cy="32" r="2" fill="#fbbf24"/>
                <circle cx="32" cy="32" r="2" fill="#fbbf24"/>
                <circle cx="44" cy="32" r="2" fill="#fbbf24"/>
            </g>

            <!-- Ícones de cartas incomuns -->
            <g id="charge-icon">
                <circle cx="32" cy="32" r="24" fill="#1d4ed8" stroke="#2563eb" stroke-width="2"/>
                <circle cx="32" cy="32" r="16" fill="none" stroke="#ffffff" stroke-width="3"/>
                <circle cx="32" cy="32" r="10" fill="#fbbf24" stroke="#f59e0b" stroke-width="2"/>
                <path d="M28 32 L32 28 L36 32 L32 36 Z" fill="#ffffff"/>
            </g>

            <g id="clock-icon">
                <circle cx="32" cy="32" r="24" fill="#7c2d12" stroke="#ea580c" stroke-width="2"/>
                <circle cx="32" cy="32" r="18" fill="none" stroke="#ffffff" stroke-width="3"/>
                <circle cx="32" cy="32" r="2" fill="#ffffff"/>
                <path d="M32 32 L32 20" stroke="#ffffff" stroke-width="3"/>
                <path d="M32 32 L40 32" stroke="#ffffff" stroke-width="2"/>
                <path d="M32 16 L32 14 M48 32 L50 32 M32 48 L32 50 M16 32 L14 32" stroke="#ffffff" stroke-width="1"/>
            </g>

            <g id="fragmentation-icon">
                <circle cx="32" cy="32" r="24" fill="#dc2626" stroke="#b91c1c" stroke-width="2"/>
                <polygon points="32,20 36,28 32,32 28,28" fill="#fbbf24" stroke="#f59e0b" stroke-width="1"/>
                <circle cx="20" cy="20" r="3" fill="#ef4444"/>
                <circle cx="44" cy="20" r="3" fill="#ef4444"/>
                <circle cx="20" cy="44" r="3" fill="#ef4444"/>
                <circle cx="44" cy="44" r="3" fill="#ef4444"/>
                <path d="M32 32 L20 20 M32 32 L44 20 M32 32 L20 44 M32 32 L44 44" stroke="#ffffff" stroke-width="1"/>
            </g>

            <g id="friction-icon">
                <circle cx="32" cy="32" r="24" fill="#7c2d12" stroke="#ea580c" stroke-width="2"/>
                <path d="M20 44 L32 20 L44 44" fill="none" stroke="#ffffff" stroke-width="3"/>
                <circle cx="24" cy="40" r="2" fill="#fbbf24"/>
                <circle cx="32" cy="24" r="2" fill="#fbbf24"/>
                <circle cx="40" cy="40" r="2" fill="#fbbf24"/>
                <path d="M28 36 L32 20 L36 36" stroke="#ef4444" stroke-width="2"/>
            </g>

            <g id="growth-plus-icon">
                <circle cx="32" cy="32" r="24" fill="#22c55e" stroke="#16a34a" stroke-width="2"/>
                <path d="M32 16 L28 24 L32 20 L36 24 Z" fill="#065f46"/>
                <rect x="30" y="20" width="4" height="20" fill="#16a34a"/>
                <ellipse cx="20" cy="44" rx="6" ry="3" fill="#22c55e"/>
                <ellipse cx="44" cy="44" rx="6" ry="3" fill="#22c55e"/>
                <path d="M18 40 L22 36 M46 40 L42 36" stroke="#16a34a" stroke-width="2"/>
                <text x="32" y="52" text-anchor="middle" fill="#ffffff" font-size="8" font-weight="bold">+</text>
            </g>

            <g id="leech-icon">
                <circle cx="32" cy="32" r="24" fill="#7f1d1d" stroke="#dc2626" stroke-width="2"/>
                <path d="M24 28 Q32 20 40 28 Q32 36 24 28" fill="#ef4444" stroke="#dc2626" stroke-width="1"/>
                <circle cx="28" cy="28" r="2" fill="#ffffff"/>
                <circle cx="36" cy="28" r="2" fill="#ffffff"/>
                <path d="M26 36 Q32 42 38 36" stroke="#ffffff" stroke-width="2" fill="none"/>
                <circle cx="32" cy="32" r="1" fill="#22c55e"/>
            </g>

            <g id="luck-icon">
                <circle cx="32" cy="32" r="24" fill="#7c3aed" stroke="#8b5cf6" stroke-width="2"/>
                <path d="M32 16 L28 28 L16 28 L24 36 L20 48 L32 40 L44 48 L40 36 L48 28 L36 28 Z" fill="#fbbf24" stroke="#f59e0b" stroke-width="2"/>
                <circle cx="32" cy="32" r="4" fill="#ffffff"/>
                <circle cx="32" cy="32" r="2" fill="#7c3aed"/>
            </g>

            <g id="orb-icon">
                <circle cx="32" cy="32" r="24" fill="#059669" stroke="#10b981" stroke-width="2"/>
                <circle cx="32" cy="32" r="16" fill="#22c55e" stroke="#16a34a" stroke-width="2"/>
                <circle cx="32" cy="32" r="10" fill="#ffffff" stroke="#059669" stroke-width="1"/>
                <circle cx="32" cy="32" r="6" fill="#22c55e"/>
                <circle cx="30" cy="30" r="2" fill="#ffffff"/>
            </g>

            <g id="precision-icon">
                <circle cx="32" cy="32" r="24" fill="#dc2626" stroke="#b91c1c" stroke-width="2"/>
                <circle cx="32" cy="32" r="16" fill="none" stroke="#ffffff" stroke-width="2"/>
                <circle cx="32" cy="32" r="10" fill="none" stroke="#ffffff" stroke-width="2"/>
                <circle cx="32" cy="32" r="4" fill="none" stroke="#ffffff" stroke-width="2"/>
                <circle cx="32" cy="32" r="2" fill="#fbbf24"/>
                <path d="M32 16 L32 20 M48 32 L44 32 M32 48 L32 44 M16 32 L20 32" stroke="#ffffff" stroke-width="2"/>
            </g>

            <g id="regrowth-icon">
                <circle cx="32" cy="32" r="24" fill="#059669" stroke="#10b981" stroke-width="2"/>
                <path d="M24 40 Q32 32 40 40" fill="none" stroke="#ffffff" stroke-width="3"/>
                <circle cx="24" cy="40" r="3" fill="#22c55e"/>
                <circle cx="32" cy="36" r="3" fill="#22c55e"/>
                <circle cx="40" cy="40" r="3" fill="#22c55e"/>
                <path d="M28 24 L32 16 L36 24 L32 20 Z" fill="#16a34a"/>
                <rect x="30" y="20" width="4" height="16" fill="#16a34a"/>
            </g>

            <g id="resonance-plus-icon">
                <circle cx="32" cy="32" r="24" fill="#7c3aed" stroke="#8b5cf6" stroke-width="2"/>
                <circle cx="32" cy="32" r="16" fill="none" stroke="#ffffff" stroke-width="2"/>
                <circle cx="32" cy="32" r="12" fill="none" stroke="#ffffff" stroke-width="2"/>
                <circle cx="32" cy="32" r="8" fill="none" stroke="#ffffff" stroke-width="2"/>
                <circle cx="32" cy="32" r="4" fill="#ffffff"/>
                <text x="32" y="52" text-anchor="middle" fill="#ffffff" font-size="8" font-weight="bold">+</text>
            </g>

            <g id="shrink-icon">
                <circle cx="32" cy="32" r="24" fill="#1e40af" stroke="#2563eb" stroke-width="2"/>
                <circle cx="32" cy="32" r="18" fill="none" stroke="#ffffff" stroke-width="2"/>
                <circle cx="32" cy="32" r="12" fill="none" stroke="#ffffff" stroke-width="2"/>
                <circle cx="32" cy="32" r="6" fill="#ffffff"/>
                <path d="M20 20 L26 26 M44 20 L38 26 M44 44 L38 38 M20 44 L26 38" stroke="#ffffff" stroke-width="2"/>
            </g>

            <g id="swift-plus-icon">
                <circle cx="32" cy="32" r="24" fill="#059669" stroke="#10b981" stroke-width="2"/>
                <path d="M16 32 L24 28 L24 36 Z" fill="#ffffff"/>
                <path d="M28 32 L36 28 L36 36 Z" fill="#ffffff"/>
                <path d="M40 32 L48 28 L48 36 Z" fill="#ffffff"/>
                <circle cx="20" cy="32" r="2" fill="#fbbf24"/>
                <circle cx="32" cy="32" r="2" fill="#fbbf24"/>
                <circle cx="44" cy="32" r="2" fill="#fbbf24"/>
                <text x="32" y="52" text-anchor="middle" fill="#ffffff" font-size="8" font-weight="bold">+</text>
            </g>

            <g id="thunderbolt-icon">
                <circle cx="32" cy="32" r="24" fill="#1e40af" stroke="#2563eb" stroke-width="2"/>
                <path d="M28 16 L36 16 L30 32 L38 32 L26 48 L34 32 L26 32 L32 16" fill="#fbbf24" stroke="#f59e0b" stroke-width="1"/>
                <circle cx="20" cy="20" r="2" fill="#ffffff"/>
                <circle cx="44" cy="24" r="2" fill="#ffffff"/>
                <circle cx="18" cy="40" r="2" fill="#ffffff"/>
                <circle cx="46" cy="44" r="2" fill="#ffffff"/>
            </g>

            <!-- Ícones de cartas épicas -->
            <g id="appraisal-icon">
                <circle cx="32" cy="32" r="24" fill="#7c3aed" stroke="#8b5cf6" stroke-width="2"/>
                <rect x="20" y="20" width="24" height="16" rx="2" fill="#ffffff" stroke="#7c3aed" stroke-width="2"/>
                <path d="M24 28 L28 32 L24 36 M32 28 L36 32 L32 36 M40 28 L44 32 L40 36" stroke="#7c3aed" stroke-width="2" fill="none"/>
                <circle cx="32" cy="44" r="3" fill="#fbbf24"/>
            </g>

            <g id="barrier-icon">
                <circle cx="32" cy="32" r="24" fill="#1e40af" stroke="#2563eb" stroke-width="2"/>
                <circle cx="32" cy="32" r="18" fill="none" stroke="#ffffff" stroke-width="4"/>
                <circle cx="32" cy="32" r="12" fill="none" stroke="#fbbf24" stroke-width="3"/>
                <circle cx="32" cy="32" r="6" fill="#ffffff"/>
                <path d="M24 24 L40 40 M40 24 L24 40" stroke="#2563eb" stroke-width="1"/>
            </g>

            <g id="cold-icon">
                <circle cx="32" cy="32" r="24" fill="#0ea5e9" stroke="#0284c7" stroke-width="2"/>
                <path d="M32 16 L32 48 M20 24 L44 40 M44 24 L20 40" stroke="#ffffff" stroke-width="3"/>
                <circle cx="32" cy="32" r="6" fill="#ffffff"/>
                <circle cx="32" cy="32" r="3" fill="#0ea5e9"/>
                <circle cx="28" cy="20" r="2" fill="#ffffff"/>
                <circle cx="36" cy="20" r="2" fill="#ffffff"/>
                <circle cx="28" cy="44" r="2" fill="#ffffff"/>
                <circle cx="36" cy="44" r="2" fill="#ffffff"/>
            </g>

            <g id="focus-icon">
                <circle cx="32" cy="32" r="24" fill="#dc2626" stroke="#b91c1c" stroke-width="2"/>
                <circle cx="32" cy="32" r="16" fill="none" stroke="#ffffff" stroke-width="2"/>
                <circle cx="32" cy="32" r="10" fill="none" stroke="#ffffff" stroke-width="2"/>
                <circle cx="32" cy="32" r="4" fill="#ffffff"/>
                <path d="M26 26 L30 30 M38 26 L34 30 M38 38 L34 34 M26 38 L30 34" stroke="#fbbf24" stroke-width="2"/>
            </g>

            <g id="immortal-icon">
                <circle cx="32" cy="32" r="24" fill="#7c2d12" stroke="#ea580c" stroke-width="2"/>
                <path d="M32 16 L28 24 L20 20 L24 28 L16 32 L24 36 L20 44 L28 40 L32 48 L36 40 L44 44 L40 36 L48 32 L40 28 L44 20 L36 24 Z" fill="#fbbf24" stroke="#f59e0b" stroke-width="2"/>
                <circle cx="32" cy="32" r="8" fill="#ffffff"/>
                <circle cx="32" cy="32" r="4" fill="#dc2626"/>
                <circle cx="32" cy="32" r="2" fill="#ffffff"/>
            </g>

            <g id="overheat-icon">
                <circle cx="32" cy="32" r="24" fill="#dc2626" stroke="#b91c1c" stroke-width="2"/>
                <circle cx="32" cy="32" r="16" fill="#ef4444" stroke="#dc2626" stroke-width="2"/>
                <circle cx="32" cy="32" r="10" fill="#f97316" stroke="#ea580c" stroke-width="2"/>
                <circle cx="32" cy="32" r="4" fill="#fbbf24"/>
                <path d="M24 24 L40 40 M40 24 L24 40" stroke="#ffffff" stroke-width="2"/>
                <circle cx="32" cy="32" r="2" fill="#ffffff"/>
            </g>

            <g id="tome-icon">
                <circle cx="32" cy="32" r="24" fill="#7c3aed" stroke="#8b5cf6" stroke-width="2"/>
                <rect x="22" y="18" width="20" height="28" rx="2" fill="#ffffff" stroke="#7c3aed" stroke-width="2"/>
                <path d="M26 26 L38 26 M26 30 L38 30 M26 34 L38 34 M26 38 L32 38" stroke="#7c3aed" stroke-width="1"/>
                <circle cx="32" cy="42" r="2" fill="#fbbf24"/>
            </g>

            <g id="will-o-wisp-icon">
                <circle cx="32" cy="32" r="24" fill="#1e1b4b" stroke="#3730a3" stroke-width="2"/>
                <circle cx="32" cy="32" r="12" fill="#8b5cf6" stroke="#7c3aed" stroke-width="2"/>
                <circle cx="32" cy="32" r="6" fill="#ffffff"/>
                <circle cx="32" cy="32" r="3" fill="#7c3aed"/>
                <circle cx="20" cy="20" r="4" fill="#a855f7" opacity="0.7"/>
                <circle cx="44" cy="24" r="3" fill="#a855f7" opacity="0.7"/>
                <circle cx="20" cy="44" r="3" fill="#a855f7" opacity="0.7"/>
                <circle cx="44" cy="40" r="4" fill="#a855f7" opacity="0.7"/>
            </g>

            <g id="wound-icon">
                <circle cx="32" cy="32" r="24" fill="#7f1d1d" stroke="#dc2626" stroke-width="2"/>
                <path d="M24 28 L40 28 L36 36 L28 36 Z" fill="#ef4444" stroke="#dc2626" stroke-width="2"/>
                <circle cx="28" cy="24" r="2" fill="#dc2626"/>
                <circle cx="36" cy="24" r="2" fill="#dc2626"/>
                <circle cx="24" cy="40" r="2" fill="#dc2626"/>
                <circle cx="40" cy="40" r="2" fill="#dc2626"/>
                <path d="M28 32 L36 32" stroke="#ffffff" stroke-width="2"/>
            </g>

            <!-- Ícones de cartas adicionais -->
            <g id="gush-icon">
                <circle cx="32" cy="32" r="24" fill="#059669" stroke="#10b981" stroke-width="2"/>
                <path d="M16 40 L32 24 L48 40" fill="none" stroke="#ffffff" stroke-width="3"/>
                <path d="M20 36 L32 28 L44 36" fill="none" stroke="#ffffff" stroke-width="2"/>
                <circle cx="32" cy="32" r="4" fill="#fbbf24"/>
                <path d="M32 20 L28 16 L32 12 L36 16 Z" fill="#ffffff"/>
            </g>

            <g id="rage-icon">
                <circle cx="32" cy="32" r="24" fill="#dc2626" stroke="#b91c1c" stroke-width="2"/>
                <path d="M24 28 L32 20 L40 28 L36 32 L40 36 L32 44 L24 36 L28 32 Z" fill="#ef4444" stroke="#dc2626" stroke-width="2"/>
                <circle cx="32" cy="32" r="6" fill="#ffffff"/>
                <circle cx="32" cy="32" r="3" fill="#dc2626"/>
                <path d="M20 20 L24 24 M44 20 L40 24 M44 44 L40 40 M20 44 L24 40" stroke="#fbbf24" stroke-width="2"/>
            </g>
        </defs>
    </svg>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <!-- HUD do jogo -->
        <div id="gameHUD">
            <div class="hud-top">
                <div class="hp-container">
                    <div class="hp-bar">
                        <div class="hp-fill" id="hpFill"></div>
                        <span class="hp-text" id="hpText">100/100</span>
                    </div>
                </div>
                <div class="wave-counter">
                    <span id="waveText">Onda: 1</span>
                </div>
                <div class="timer">
                    <span id="timerText">00:00</span>
                </div>
            </div>
            <div class="hud-bottom">
                <div class="soul-orbs">
                    <span id="soulOrbsText">Orbes: 0</span>
                </div>
            </div>
        </div>

        <!-- Controles móveis -->
        <div id="mobileControls" class="mobile-only">
            <div class="joystick-container">
                <div class="joystick" id="movementJoystick">
                    <div class="joystick-knob" id="joystickKnob"></div>
                </div>
            </div>
            <div class="mobile-buttons">
                <button class="action-btn" id="shootBtn">ATIRAR</button>
                <button class="action-btn" id="jumpBtn">PULAR</button>
                <button class="action-btn" id="pauseBtn">PAUSA</button>
            </div>
        </div>

        <!-- Menu principal -->
        <div id="mainMenu" class="main-menu">
            <div class="menu-container">
                <h1 class="game-title">SERAPH'S LAST STAND</h1>
                <div class="game-subtitle">Wizard's Final Battle</div>
                <div class="menu-buttons">
                    <button class="menu-btn start-game" id="startGameBtn">🎮 Novo Jogo</button>
                    <button class="menu-btn start-game" id="loadGameBtn">💾 Carregar Jogo</button>
                    <button class="menu-btn shop" id="shopBtn">🛒 Loja</button>
                    <button class="menu-btn ranking" id="rankingBtn">🏆 Ranking</button>
                    <button class="menu-btn settings" id="settingsBtn">⚙️ Configurações</button>
                </div>
                <div class="menu-stats">
                    <div class="stat-item">
                        <div class="stat-label">Soul Orbs</div>
                        <div class="stat-value" id="menuSoulOrbs">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Melhor Score</div>
                        <div class="stat-value" id="menuBestScore">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">Jogadas</div>
                        <div class="stat-value" id="menuGamesPlayed">0</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Menu de pausa -->
        <div id="pauseMenu" class="menu hidden">
            <div class="menu-content">
                <h2>JOGO PAUSADO</h2>
                <button class="menu-btn" id="resumeBtn">CONTINUAR</button>
                <button class="menu-btn" id="restartBtn">REINICIAR</button>
                <button class="menu-btn" id="mainMenuBtn">MENU PRINCIPAL</button>
            </div>
        </div>

        <!-- Menu da loja -->
        <div id="shopMenu" class="menu hidden">
            <div class="menu-content">
                <h2>LOJA DE EQUIPAMENTOS</h2>
                <div id="shopContent" class="shop-content">
                    <!-- Conteúdo da loja será gerado dinamicamente -->
                </div>
                <button class="menu-btn" id="closeShopBtn">FECHAR</button>
            </div>
        </div>

        <!-- Menu de ranking -->
        <div id="rankingMenu" class="menu hidden">
            <div class="menu-content">
                <h2>RANKING</h2>
                <div id="rankingContent" class="ranking-content">
                    <!-- Conteúdo do ranking será gerado dinamicamente -->
                </div>
                <button class="menu-btn" id="closeRankingBtn">FECHAR</button>
            </div>
        </div>

        <!-- Menu de configurações -->
        <div id="settingsMenu" class="menu hidden">
            <div class="menu-content">
                <h2>CONFIGURAÇÕES</h2>
                <div id="settingsContent" class="settings-content">
                    <div class="setting-item">
                        <label>Nome do Jogador:</label>
                        <input type="text" id="playerNameInput" maxlength="20" />
                    </div>
                </div>
                <div class="menu-buttons">
                    <button class="menu-btn" id="saveSettingsBtn">SALVAR</button>
                    <button class="menu-btn" id="closeSettingsBtn">FECHAR</button>
                </div>
            </div>
        </div>

        <!-- Menu de game over -->
        <div id="gameOverMenu" class="menu hidden">
            <div class="menu-content">
                <h2>GAME OVER</h2>
                <div id="gameOverStats" class="game-over-stats">
                    <!-- Estatísticas serão preenchidas dinamicamente -->
                </div>
                <div class="menu-buttons">
                    <button class="menu-btn" id="playAgainBtn">JOGAR NOVAMENTE</button>
                    <button class="menu-btn" id="backToMenuBtn">MENU PRINCIPAL</button>
                </div>
            </div>
        </div>

        <!-- Menu de upgrades -->
        <div id="upgradeMenu" class="menu hidden">
            <div class="menu-content">
                <h2>ESCOLHA UM UPGRADE</h2>
                <div id="upgradeOptions" class="upgrade-options">
                    <!-- Opções de upgrade serão geradas dinamicamente -->
                </div>
            </div>
        </div>
    </div>

    <!-- Scripts do jogo -->
    <!-- utils -->
    <script>
        // utils.js - Funções utilitárias para o jogo

        // Utilitários matemáticos
        const Math2D = {
            // Distância entre dois pontos
            distance(x1, y1, x2, y2) {
                return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            },

            // Ângulo entre dois pontos
            angle(x1, y1, x2, y2) {
                return Math.atan2(y2 - y1, x2 - x1);
            },

            // Normalizar ângulo para 0-2π
            normalizeAngle(angle) {
                while (angle < 0) angle += Math.PI * 2;
                while (angle >= Math.PI * 2) angle -= Math.PI * 2;
                return angle;
            },

            // Interpolar entre dois valores
            lerp(a, b, t) {
                return a + (b - a) * t;
            },

            // Clampar valor entre min e max
            clamp(value, min, max) {
                return Math.min(Math.max(value, min), max);
            },

            // Número aleatório entre min e max
            random(min, max) {
                return Math.random() * (max - min) + min;
            },

            // Número aleatório inteiro
            randomInt(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }
        };

        // Utilitários de colisão
        const Collision = {
            // Colisão círculo-círculo
            circleCircle(x1, y1, r1, x2, y2, r2) {
                const distance = Math2D.distance(x1, y1, x2, y2);
                return distance < r1 + r2;
            },

            // Colisão ponto-círculo
            pointCircle(px, py, cx, cy, r) {
                const distance = Math2D.distance(px, py, cx, cy);
                return distance < r;
            },

            // Colisão retângulo-retângulo
            rectRect(x1, y1, w1, h1, x2, y2, w2, h2) {
                return x1 < x2 + w2 && x1 + w1 > x2 && y1 < y2 + h2 && y1 + h1 > y2;
            },

            // Colisão círculo-retângulo
            circleRect(cx, cy, r, rx, ry, rw, rh) {
                const xDist = Math.abs(cx - (rx + rw / 2));
                const yDist = Math.abs(cy - (ry + rh / 2));

                if (xDist > (rw / 2 + r) || yDist > (rh / 2 + r)) {
                    return false;
                }

                if (xDist <= (rw / 2) || yDist <= (rh / 2)) {
                    return true;
                }

                const cornerDist = (xDist - rw / 2) ** 2 + (yDist - rh / 2) ** 2;
                return cornerDist <= r ** 2;
            }
        };

        // Utilitários de canvas
        const CanvasUtils = {
            // Desenhar círculo
            drawCircle(ctx, x, y, radius, color, fill = true) {
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                if (fill) {
                    ctx.fillStyle = color;
                    ctx.fill();
                } else {
                    ctx.strokeStyle = color;
                    ctx.stroke();
                }
            },

            // Desenhar retângulo
            drawRect(ctx, x, y, width, height, color, fill = true) {
                if (fill) {
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, width, height);
                } else {
                    ctx.strokeStyle = color;
                    ctx.strokeRect(x, y, width, height);
                }
            },

            // Desenhar linha
            drawLine(ctx, x1, y1, x2, y2, color, width = 1) {
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = color;
                ctx.lineWidth = width;
                ctx.stroke();
            },

            // Desenhar projétil mágico aprimorado
            drawMagicalProjectile(ctx, x, y, radius, color, type = 'basic') {
                const time = Date.now() * 0.005;
                ctx.save();
                
                switch(type) {
                    case 'basic':
                        // Núcleo brilhante
                        const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius * 2);
                        gradient.addColorStop(0, color);
                        gradient.addColorStop(0.4, color + '80');
                        gradient.addColorStop(1, color + '00');
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(x, y, radius * 2, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Núcleo sólido
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(x, y, radius * 0.6, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Brilho central
                        ctx.fillStyle = '#ffffff80';
                        ctx.beginPath();
                        ctx.arc(x - radius * 0.2, y - radius * 0.2, radius * 0.3, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'homing':
                        // Projétil teleguiado com trilha
                        const trailGrad = ctx.createLinearGradient(x - radius, y, x + radius, y);
                        trailGrad.addColorStop(0, '#10b98100');
                        trailGrad.addColorStop(0.5, '#10b981');
                        trailGrad.addColorStop(1, '#10b98100');
                        
                        ctx.fillStyle = trailGrad;
                        ctx.fillRect(x - radius * 2, y - radius * 0.3, radius * 4, radius * 0.6);
                        
                        // Núcleo esmeralda
                        ctx.fillStyle = '#10b981';
                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Brilho esmeralda
                        ctx.fillStyle = '#6ee7b780';
                        ctx.beginPath();
                        ctx.arc(x, y, radius * 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'explosive':
                        // Projétil explosivo com faíscas
                        ctx.fillStyle = '#f59e0b';
                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Faíscas rotativas
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI / 3) + time;
                            const sparkX = x + Math.cos(angle) * radius * 1.8;
                            const sparkY = y + Math.sin(angle) * radius * 1.8;
                            
                            ctx.fillStyle = '#fde047';
                            ctx.beginPath();
                            ctx.arc(sparkX, sparkY, radius * 0.3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Núcleo quente
                        ctx.fillStyle = '#fef3c7';
                        ctx.beginPath();
                        ctx.arc(x, y, radius * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'lightning':
                        // Projétil elétrico
                        ctx.strokeStyle = '#fbbf24';
                        ctx.lineWidth = radius * 0.5;
                        ctx.lineCap = 'round';
                        
                        // Raios aleatórios
                        for (let i = 0; i < 4; i++) {
                            const angle = (i * Math.PI / 2) + time * 2;
                            const length = radius * (1.5 + Math.sin(time * 5 + i) * 0.5);
                            
                            ctx.beginPath();
                            ctx.moveTo(x, y);
                            ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
                            ctx.stroke();
                        }
                        
                        // Núcleo elétrico
                        ctx.fillStyle = '#fef3c7';
                        ctx.beginPath();
                        ctx.arc(x, y, radius * 0.8, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'piercing':
                        // Projétil perfurante
                        ctx.fillStyle = '#67e8f9';
                        ctx.beginPath();
                        ctx.arc(x, y, radius, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Trilha de gelo
                        const iceGrad = ctx.createLinearGradient(x - radius * 3, y, x, y);
                        iceGrad.addColorStop(0, '#cffafe00');
                        iceGrad.addColorStop(1, '#67e8f980');
                        
                        ctx.fillStyle = iceGrad;
                        ctx.fillRect(x - radius * 3, y - radius * 0.5, radius * 3, radius);
                        
                        // Cristais de gelo
                        for (let i = 0; i < 3; i++) {
                            const offset = (i - 1) * radius * 0.8;
                            ctx.fillStyle = '#ffffff';
                            ctx.fillRect(x + offset - 1, y - radius * 0.3, 2, radius * 0.6);
                            ctx.fillRect(x + offset - radius * 0.3, y - 1, radius * 0.6, 2);
                        }
                        break;
                        
                    case 'random':
                        // Projétil arco-íris
                        const rainbowGrad = ctx.createRadialGradient(x, y, 0, x, y, radius * 2);
                        const hue = (time * 100) % 360;
                        rainbowGrad.addColorStop(0, `hsl(${hue}, 100%, 70%)`);
                        rainbowGrad.addColorStop(0.5, `hsl(${(hue + 60) % 360}, 100%, 60%)`);
                        rainbowGrad.addColorStop(1, `hsl(${(hue + 120) % 360}, 100%, 50%)`);
                        
                        ctx.fillStyle = rainbowGrad;
                        ctx.beginPath();
                        ctx.arc(x, y, radius * 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Partículas arco-íris
                        for (let i = 0; i < 8; i++) {
                            const angle = (i * Math.PI / 4) + time;
                            const sparkX = x + Math.cos(angle) * radius * 2;
                            const sparkY = y + Math.sin(angle) * radius * 2;
                            
                            ctx.fillStyle = `hsl(${(hue + i * 45) % 360}, 100%, 80%)`;
                            ctx.beginPath();
                            ctx.arc(sparkX, sparkY, radius * 0.2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        // Núcleo branco
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(x, y, radius * 0.4, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                }
                
                ctx.restore();
            },

            // Desenhar texto
            drawText(ctx, text, x, y, color, font = '16px Arial', align = 'left') {
                ctx.fillStyle = color;
                ctx.font = font;
                ctx.textAlign = align;
                ctx.fillText(text, x, y);
            },

            // Desenhar texto com contorno
            drawTextOutlined(ctx, text, x, y, fillColor, strokeColor, font = '16px Arial', strokeWidth = 2) {
                ctx.font = font;
                ctx.textAlign = 'center';
                ctx.lineWidth = strokeWidth;
                ctx.strokeStyle = strokeColor;
                ctx.strokeText(text, x, y);
                ctx.fillStyle = fillColor;
                ctx.fillText(text, x, y);
            },

            // Converter SVG para Image (versão simples e síncrona)
            svgToImage(svgId, width = 64, height = 64) {
                const svgElement = document.getElementById(svgId);
                if (!svgElement) {
                    console.warn(`SVG com ID '${svgId}' não encontrado`);
                    return null;
                }

                // Obter o SVG como string
                const svgString = new XMLSerializer().serializeToString(svgElement);
                const svgBlob = new Blob([`<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 64 64">${svgString}</svg>`], 
                    { type: 'image/svg+xml' });
                
                const img = new Image();
                img.width = width;
                img.height = height;
                
                // Criar URL do blob de forma síncrona
                const url = URL.createObjectURL(svgBlob);
                img.src = url;
                
                // Programar limpeza da URL
                setTimeout(() => URL.revokeObjectURL(url), 1000);
                
                return img;
            },

            // Cache de imagens SVG
            svgImageCache: new Map(),

            // Obter imagem SVG (com cache) - versão síncrona
            getSvgImage(svgId, width = 64, height = 64) {
                const cacheKey = `${svgId}_${width}_${height}`;
                
                if (this.svgImageCache.has(cacheKey)) {
                    return this.svgImageCache.get(cacheKey);
                }

                const img = this.svgToImage(svgId, width, height);
                if (img) {
                    this.svgImageCache.set(cacheKey, img);
                }
                
                return img;
            }
        };

        // Utilitários de tempo
        const TimeUtils = {
            // Converter milissegundos para string de tempo
            formatTime(ms) {
                const totalSeconds = Math.floor(ms / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            },

            // Debounce function
            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            },

            // Throttle function
            throttle(func, limit) {
                let inThrottle;
                return function (...args) {
                    if (!inThrottle) {
                        func.apply(this, args);
                        inThrottle = true;
                        setTimeout(() => inThrottle = false, limit);
                    }
                };
            }
        };

        // Utilitários de localStorage
        const Storage = {
            // Salvar dados
            save(key, data) {
                try {
                    localStorage.setItem(key, JSON.stringify(data));
                    return true;
                } catch (e) {
                    console.warn('Erro ao salvar dados:', e);
                    return false;
                }
            },

            // Carregar dados
            load(key, defaultValue = null) {
                try {
                    const data = localStorage.getItem(key);
                    return data ? JSON.parse(data) : defaultValue;
                } catch (e) {
                    console.warn('Erro ao carregar dados:', e);
                    return defaultValue;
                }
            },

            // Remover dados
            remove(key) {
                try {
                    localStorage.removeItem(key);
                    return true;
                } catch (e) {
                    console.warn('Erro ao remover dados:', e);
                    return false;
                }
            }
        };

        // Utilitários de dispositivo
        const DeviceUtils = {
            // Verificar se é dispositivo móvel
            isMobile() {
                return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            },

            // Verificar se é tablet
            isTablet() {
                return /iPad|Android/i.test(navigator.userAgent) && window.innerWidth >= 768;
            },

            // Verificar se suporte a touch
            hasTouch() {
                return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            },

            // Get viewport size
            getViewportSize() {
                return {
                    width: Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0),
                    height: Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0)
                };
            }
        };

        // Pool de objetos para performance
        class ObjectPool {
            constructor(createFn, resetFn, initialSize = 10) {
                this.createFn = createFn;
                this.resetFn = resetFn;
                this.pool = [];

                // Pré-criar objetos
                for (let i = 0; i < initialSize; i++) {
                    this.pool.push(this.createFn());
                }
            }

            get() {
                if (this.pool.length > 0) {
                    return this.pool.pop();
                }
                return this.createFn();
            }

            release(obj) {
                this.resetFn(obj);
                this.pool.push(obj);
            }

            clear() {
                this.pool.length = 0;
            }
        }

        // Sistema de eventos simples
        class EventEmitter {
            constructor() {
                this.events = {};
            }

            on(event, callback) {
                if (!this.events[event]) {
                    this.events[event] = [];
                }
                this.events[event].push(callback);
            }

            off(event, callback) {
                if (!this.events[event]) return;
                this.events[event] = this.events[event].filter(cb => cb !== callback);
            }

            emit(event, ...args) {
                if (!this.events[event]) return;
                this.events[event].forEach(callback => callback(...args));
            }

            once(event, callback) {
                const onceCallback = (...args) => {
                    callback(...args);
                    this.off(event, onceCallback);
                };
                this.on(event, onceCallback);
            }
        }

        // Exportar utilitários globalmente
        window.Math2D = Math2D;
        window.Collision = Collision;
        window.CanvasUtils = CanvasUtils;
        window.TimeUtils = TimeUtils;
        window.Storage = Storage;
        window.DeviceUtils = DeviceUtils;
        window.ObjectPool = ObjectPool;
        window.EventEmitter = EventEmitter;
    </script>
    <!-- audio.js -->
    <script>
        // audio.js - Sistema de áudio e efeitos sonoros

        class AudioSystem extends EventEmitter {
            constructor() {
                super();

                this.context = null;
                this.masterVolume = 0.7;
                this.sfxVolume = 0.8;
                this.musicVolume = 0.5;

                this.sounds = {};
                this.music = null;
                this.currentMusic = null;

                this.initialized = false;
                this.muted = false;

                // Sistema de throttling para evitar spam de sons
                this.soundThrottling = new Map();
                this.throttleSettings = {
                    'hit': 150,      // Máximo 1 som de hit a cada 150ms
                    'playerShot': 50, // Máximo 1 som de tiro a cada 50ms
                    'enemyHit': 100,  // Máximo 1 som de acerto em inimigo a cada 100ms
                    'soulOrb': 200    // Máximo 1 som de soul orb a cada 200ms
                };

                // Tentar inicializar (requer interação do usuário)
                this.init();

                // Carregar configurações salvas
                this.loadSettings();
            }

            async init() {
                try {
                    // AudioContext requer interação do usuário
                    document.addEventListener('click', () => this.initializeAudioContext(), { once: true });
                    document.addEventListener('touchstart', () => this.initializeAudioContext(), { once: true });
                    document.addEventListener('keydown', () => this.initializeAudioContext(), { once: true });

                    // Pré-carregar sons básicos
                    this.preloadSounds();

                } catch (error) {
                    console.warn('Erro ao inicializar sistema de áudio:', error);
                }
            }

            async initializeAudioContext() {
                if (this.initialized) return;

                try {
                    // Criar AudioContext
                    this.context = new (window.AudioContext || window.webkitAudioContext)();

                    // Resolver estado suspended
                    if (this.context.state === 'suspended') {
                        await this.context.resume();
                    }

                    this.initialized = true;
                    this.emit('initialized');

                    console.log('Sistema de áudio inicializado');

                } catch (error) {
                    console.warn('Erro ao inicializar AudioContext:', error);
                }
            }

            preloadSounds() {
                // Criar sons procedurais básicos
                this.createProceduralSounds();
            }

            createProceduralSounds() {
                // Definições de sons procedurais
                const soundDefinitions = {
                    shot: {
                        type: 'noise',
                        frequency: 800,
                        duration: 0.1,
                        volume: 0.3,
                        fadeOut: true
                    },
                    hit: {
                        type: 'tone',
                        frequency: 400,
                        duration: 0.15,
                        volume: 0.4,
                        distortion: true
                    },
                    enemyDeath: {
                        type: 'sweep',
                        startFreq: 800,
                        endFreq: 200,
                        duration: 0.3,
                        volume: 0.5
                    },
                    soulOrb: {
                        type: 'chime',
                        frequency: 660,
                        duration: 0.4,
                        volume: 0.6,
                        echo: true
                    },
                    playerDamage: {
                        type: 'noise',
                        frequency: 200,
                        duration: 0.2,
                        volume: 0.7,
                        lowpass: true
                    },
                    waveStart: {
                        type: 'fanfare',
                        frequencies: [523, 659, 784], // C, E, G
                        duration: 1.0,
                        volume: 0.4
                    },
                    waveComplete: {
                        type: 'success',
                        frequencies: [523, 659, 784, 1047], // C, E, G, C
                        duration: 1.2,
                        volume: 0.5
                    },
                    critical: {
                        type: 'sparkle',
                        frequency: 1200,
                        duration: 0.3,
                        volume: 0.6,
                        shimmer: true
                    },
                    levelUp: {
                        type: 'fanfare',
                        frequencies: [440, 554, 659, 880], // A, C#, E, A
                        duration: 1.5,
                        volume: 0.7
                    },
                    upgradeSelected: {
                        type: 'success',
                        frequencies: [659, 784, 988], // E, G, B
                        duration: 0.8,
                        volume: 0.5
                    }
                };

                // Armazenar definições para criação sob demanda
                this.soundDefinitions = soundDefinitions;
            }

            // Criar som procedural
            createSound(definition) {
                if (!this.context) return null;

                const { type, duration, volume } = definition;

                switch (type) {
                    case 'tone':
                        return this.createTone(definition);
                    case 'noise':
                        return this.createNoise(definition);
                    case 'sweep':
                        return this.createSweep(definition);
                    case 'chime':
                        return this.createChime(definition);
                    case 'fanfare':
                        return this.createFanfare(definition);
                    case 'success':
                        return this.createSuccess(definition);
                    case 'sparkle':
                        return this.createSparkle(definition);
                    default:
                        return this.createTone(definition);
                }
            }

            createTone(def) {
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.context.destination);

                oscillator.type = 'square';
                oscillator.frequency.setValueAtTime(def.frequency, this.context.currentTime);

                const volume = (def.volume || 0.5) * this.sfxVolume * this.masterVolume;
                gainNode.gain.setValueAtTime(volume, this.context.currentTime);

                if (def.fadeOut) {
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + def.duration);
                } else {
                    gainNode.gain.setValueAtTime(0, this.context.currentTime + def.duration);
                }

                return { oscillator, gainNode };
            }

            createNoise(def) {
                const bufferSize = this.context.sampleRate * def.duration;
                const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
                const output = buffer.getChannelData(0);

                // Gerar ruído filtrado
                for (let i = 0; i < bufferSize; i++) {
                    output[i] = (Math.random() * 2 - 1) * Math.sin(i / bufferSize * Math.PI);
                }

                const source = this.context.createBufferSource();
                const gainNode = this.context.createGain();
                const filter = this.context.createBiquadFilter();

                source.buffer = buffer;
                source.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(this.context.destination);

                filter.type = 'bandpass';
                filter.frequency.setValueAtTime(def.frequency, this.context.currentTime);
                filter.Q.setValueAtTime(10, this.context.currentTime);

                const volume = (def.volume || 0.5) * this.sfxVolume * this.masterVolume;
                gainNode.gain.setValueAtTime(volume, this.context.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + def.duration);

                return { source, gainNode, filter };
            }

            createSweep(def) {
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.context.destination);

                oscillator.type = 'sawtooth';
                oscillator.frequency.setValueAtTime(def.startFreq, this.context.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(def.endFreq, this.context.currentTime + def.duration);

                const volume = (def.volume || 0.5) * this.sfxVolume * this.masterVolume;
                gainNode.gain.setValueAtTime(volume, this.context.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + def.duration);

                return { oscillator, gainNode };
            }

            createChime(def) {
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.context.destination);

                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(def.frequency, this.context.currentTime);

                const volume = (def.volume || 0.5) * this.sfxVolume * this.masterVolume;
                gainNode.gain.setValueAtTime(0, this.context.currentTime);
                gainNode.gain.linearRampToValueAtTime(volume, this.context.currentTime + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + def.duration);

                return { oscillator, gainNode };
            }

            createFanfare(def) {
                const nodes = [];

                def.frequencies.forEach((freq, index) => {
                    const oscillator = this.context.createOscillator();
                    const gainNode = this.context.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(this.context.destination);

                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(freq, this.context.currentTime);

                    const volume = (def.volume || 0.5) * this.sfxVolume * this.masterVolume / def.frequencies.length;
                    const delay = index * 0.1;

                    gainNode.gain.setValueAtTime(0, this.context.currentTime + delay);
                    gainNode.gain.linearRampToValueAtTime(volume, this.context.currentTime + delay + 0.1);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + def.duration);

                    nodes.push({ oscillator, gainNode, delay });
                });

                return { nodes };
            }

            createSuccess(def) {
                return this.createFanfare(def);
            }

            createSparkle(def) {
                const nodes = [];
                const sparkleCount = 5;

                for (let i = 0; i < sparkleCount; i++) {
                    const oscillator = this.context.createOscillator();
                    const gainNode = this.context.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(this.context.destination);

                    oscillator.type = 'sine';
                    const freq = def.frequency + (Math.random() - 0.5) * 400;
                    oscillator.frequency.setValueAtTime(freq, this.context.currentTime);

                    const volume = (def.volume || 0.5) * this.sfxVolume * this.masterVolume / sparkleCount;
                    const delay = Math.random() * 0.2;

                    gainNode.gain.setValueAtTime(0, this.context.currentTime + delay);
                    gainNode.gain.linearRampToValueAtTime(volume, this.context.currentTime + delay + 0.02);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + delay + 0.2);

                    nodes.push({ oscillator, gainNode, delay });
                }

                return { nodes };
            }

            // Tocar som
            playSound(soundName) {
                if (!this.initialized || this.muted) return;

                // Verificar throttling para este som
                const now = Date.now();
                const throttleTime = this.throttleSettings[soundName];

                if (throttleTime) {
                    const lastPlayed = this.soundThrottling.get(soundName);
                    if (lastPlayed && (now - lastPlayed) < throttleTime) {
                        // Som ainda está em throttling, não tocar
                        return;
                    }
                    // Atualizar timestamp do último som tocado
                    this.soundThrottling.set(soundName, now);
                }

                const definition = this.soundDefinitions[soundName];
                if (!definition) {
                    console.warn(`Som não encontrado: ${soundName}`);
                    return;
                }

                try {
                    const sound = this.createSound(definition);
                    if (!sound) return;

                    const startTime = this.context.currentTime;

                    if (sound.nodes) {
                        // Som com múltiplos nós (fanfare, sparkle)
                        sound.nodes.forEach(node => {
                            node.oscillator.start(startTime + node.delay);
                            node.oscillator.stop(startTime + definition.duration);
                        });
                    } else if (sound.source) {
                        // Som baseado em buffer (noise)
                        sound.source.start(startTime);
                    } else if (sound.oscillator) {
                        // Som simples (tone, sweep, chime)
                        sound.oscillator.start(startTime);
                        sound.oscillator.stop(startTime + definition.duration);
                    }

                } catch (error) {
                    console.warn(`Erro ao tocar som ${soundName}:`, error);
                }
            }

            // Música de fundo (placeholder para implementação futura)
            playMusic(musicName) {
                if (!this.initialized || this.muted) return;

                // TODO: Implementar música procedural ou carregar arquivos
                console.log(`Tocando música: ${musicName}`);
            }

            stopMusic() {
                if (this.currentMusic) {
                    // TODO: Parar música atual
                    this.currentMusic = null;
                }
            }
            // Controles de volume
            setMasterVolume(volume) {
                this.masterVolume = Math.max(0, Math.min(1, volume));
                this.emit('volumeChanged', 'master', this.masterVolume);
                console.log('Master volume definido para:', this.masterVolume);
            }

            setSfxVolume(volume) {
                this.sfxVolume = Math.max(0, Math.min(1, volume));
                this.emit('volumeChanged', 'sfx', this.sfxVolume);
                console.log('SFX volume definido para:', this.sfxVolume);
            }

            setMusicVolume(volume) {
                this.musicVolume = Math.max(0, Math.min(1, volume));
                this.emit('volumeChanged', 'music', this.musicVolume);
                console.log('Music volume definido para:', this.musicVolume);
            }

            // Mute/Unmute
            mute() {
                this.muted = true;
                this.emit('muted');
            }

            unmute() {
                this.muted = false;
                this.emit('unmuted');
            }

            toggleMute() {
                if (this.muted) {
                    this.unmute();
                } else {
                    this.mute();
                }
            }

            // Getters
            isMuted() {
                return this.muted;
            }

            isInitialized() {
                return this.initialized;
            }

            getVolumes() {
                return {
                    master: this.masterVolume,
                    sfx: this.sfxVolume,
                    music: this.musicVolume
                };
            }

            // Carregar configurações do localStorage
            loadSettings() {
                const settings = Storage.load('seraphsLastStand_audio', {});

                if (settings.masterVolume !== undefined) {
                    this.setMasterVolume(settings.masterVolume);
                }

                if (settings.sfxVolume !== undefined) {
                    this.setSfxVolume(settings.sfxVolume);
                }

                if (settings.musicVolume !== undefined) {
                    this.setMusicVolume(settings.musicVolume);
                }

                if (settings.muted !== undefined) {
                    this.muted = settings.muted;
                }
            }

            // Salvar configurações no localStorage
            saveSettings() {
                const settings = {
                    masterVolume: this.masterVolume,
                    sfxVolume: this.sfxVolume,
                    musicVolume: this.musicVolume,
                    muted: this.muted
                };

                console.log('Salvando configurações de áudio:', settings); // Debug
                Storage.save('seraphsLastStand_audio', settings);
                console.log('Configurações de áudio salvas com sucesso'); // Debug
            }

            // Cleanup
            destroy() {
                if (this.context) {
                    this.context.close();
                }

                this.sounds = {};
                this.currentMusic = null;
                this.initialized = false;
            }
        }

        // Sistema de música procedural simples (para implementação futura)
        class ProceduralMusic extends EventEmitter {
            constructor(audioContext) {
                super();

                this.context = audioContext;
                this.isPlaying = false;
                this.currentPattern = null;
                this.bpm = 120;
                this.nextNoteTime = 0;
                this.noteIndex = 0;

                // Escalas musicais
                this.scales = {
                    minor: [0, 2, 3, 5, 7, 8, 10], // A minor
                    major: [0, 2, 4, 5, 7, 9, 11], // C major
                    pentatonic: [0, 2, 5, 7, 9] // Pentatonic
                };

                this.baseFreq = 220; // A3
            }

            start(intensity = 1) {
                if (!this.context || this.isPlaying) return;

                this.isPlaying = true;
                this.nextNoteTime = this.context.currentTime;
                this.generatePattern(intensity);
                this.scheduleNotes();
            }

            stop() {
                this.isPlaying = false;
                this.currentPattern = null;
            }

            generatePattern(intensity) {
                const scale = this.scales.minor;
                const pattern = [];

                // Gerar padrão baseado na intensidade
                const noteCount = Math.floor(8 + intensity * 8);

                for (let i = 0; i < noteCount; i++) {
                    const noteIndex = Math.floor(Math.random() * scale.length);
                    const octave = Math.floor(Math.random() * 2) + 1;
                    const duration = 0.5 + Math.random() * 0.5;

                    pattern.push({
                        note: scale[noteIndex],
                        octave: octave,
                        duration: duration,
                        volume: 0.1 + Math.random() * 0.2
                    });
                }

                this.currentPattern = pattern;
            }

            scheduleNotes() {
                if (!this.isPlaying || !this.currentPattern) return;

                const secondsPerBeat = 60.0 / this.bpm;

                while (this.nextNoteTime < this.context.currentTime + 0.1) {
                    const note = this.currentPattern[this.noteIndex];

                    if (note) {
                        this.playNote(note, this.nextNoteTime);
                    }

                    this.nextNoteTime += secondsPerBeat;
                    this.noteIndex = (this.noteIndex + 1) % this.currentPattern.length;
                }

                if (this.isPlaying) {
                    requestAnimationFrame(() => this.scheduleNotes());
                }
            }

            playNote(note, time) {
                const oscillator = this.context.createOscillator();
                const gainNode = this.context.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(this.context.destination);

                // Calcular frequência
                const frequency = this.baseFreq * Math.pow(2, note.octave + note.note / 12);

                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(frequency, time);

                gainNode.gain.setValueAtTime(0, time);
                gainNode.gain.linearRampToValueAtTime(note.volume, time + 0.05);
                gainNode.gain.exponentialRampToValueAtTime(0.01, time + note.duration);

                oscillator.start(time);
                oscillator.stop(time + note.duration);
            }

            // Configurar throttling para um som específico
            setThrottling(soundName, milliseconds) {
                this.throttleSettings[soundName] = milliseconds;
            }

            // Remover throttling para um som específico
            removeThrottling(soundName) {
                delete this.throttleSettings[soundName];
                this.soundThrottling.delete(soundName);
            }

            // Limpar todos os throttlings (útil para reiniciar o jogo)
            clearThrottling() {
                this.soundThrottling.clear();
            }
        }
    </script>
    <!-- ranking.js -->
    <script>
        // ranking.js - Sistema de ranking e leaderboard

        class RankingSystem extends EventEmitter {
            constructor() {
                super();

                this.storageKey = 'seraphsLastStand_ranking';
                this.maxRankingEntries = 10; // Top 10
                this.rankings = this.loadRankings();
            }

            // Carregar rankings do localStorage
            loadRankings() {
                try {
                    const stored = localStorage.getItem(this.storageKey);
                    return stored ? JSON.parse(stored) : [];
                } catch (error) {
                    console.warn('Erro ao carregar rankings:', error);
                    return [];
                }
            }

            // Salvar rankings no localStorage
            saveRankings() {
                try {
                    localStorage.setItem(this.storageKey, JSON.stringify(this.rankings));
                    this.emit('rankingsSaved');
                } catch (error) {
                    console.error('Erro ao salvar rankings:', error);
                }
            }

            // Adicionar nova entrada no ranking
            addScore(stats) {
                const entry = {
                    playerName: stats.playerName || 'Anonymous',
                    score: stats.score || 0,
                    level: stats.level || 1,
                    enemiesKilled: stats.enemiesKilled || 0,
                    survivalTime: stats.survivalTime || 0,
                    accuracy: stats.accuracy || 0,
                    criticalHits: stats.criticalHits || 0,
                    totalDamageDealt: stats.totalDamageDealt || 0,
                    soulOrbs: stats.soulOrbs || 0,
                    build: stats.build || [], // Armazenar build (cartas escolhidas)
                    timestamp: stats.timestamp || Date.now(),
                    date: new Date(stats.timestamp || Date.now()).toLocaleDateString()
                };

                // Adicionar à lista
                this.rankings.push(entry);

                // Ordenar por pontuação (maior primeiro)
                this.rankings.sort((a, b) => b.score - a.score);

                // Manter apenas o top 10
                this.rankings = this.rankings.slice(0, this.maxRankingEntries);

                // Salvar
                this.saveRankings();

                // Verificar se entrou no ranking
                const position = this.rankings.findIndex(r =>
                    r.timestamp === entry.timestamp && r.playerName === entry.playerName
                );

                if (position !== -1) {
                    this.emit('newRecord', entry, position + 1);
                    return position + 1;
                }

                return -1;
            }

            // Obter rankings
            getRankings() {
                return [...this.rankings]; // Retornar cópia
            }

            // Verificar se pontuação entraria no ranking
            wouldMakeRanking(score) {
                if (this.rankings.length < this.maxRankingEntries) {
                    return true;
                }

                const lowestScore = this.rankings[this.rankings.length - 1].score;
                return score > lowestScore;
            }

            // Obter posição que uma pontuação teria
            getScorePosition(score) {
                let position = 1;
                for (let entry of this.rankings) {
                    if (score > entry.score) {
                        break;
                    }
                    position++;
                }
                return position;
            }

            // Limpar rankings
            clearRankings() {
                this.rankings = [];
                this.saveRankings();
                this.emit('rankingsCleared');
            }

            // Obter estatísticas gerais
            getOverallStats() {
                if (this.rankings.length === 0) {
                    return {
                        totalGames: 0,
                        highestScore: 0,
                        totalEnemiesKilled: 0,
                        bestAccuracy: 0,
                        longestSurvival: 0
                    };
                }

                return {
                    totalGames: this.rankings.length,
                    highestScore: Math.max(...this.rankings.map(r => r.score)),
                    totalEnemiesKilled: this.rankings.reduce((sum, r) => sum + r.enemiesKilled, 0),
                    bestAccuracy: Math.max(...this.rankings.map(r => r.accuracy)),
                    longestSurvival: Math.max(...this.rankings.map(r => r.survivalTime))
                };
            }

            // Formatar tempo de sobrevivência
            static formatSurvivalTime(milliseconds) {
                const seconds = Math.floor(milliseconds / 1000);
                const minutes = Math.floor(seconds / 60);
                const remainingSeconds = seconds % 60;

                if (minutes > 0) {
                    return `${minutes}m ${remainingSeconds}s`;
                }
                return `${remainingSeconds}s`;
            }

            // Formatar pontuação
            static formatScore(score) {
                if (score >= 1000000) {
                    return `${(score / 1000000).toFixed(1)}M`;
                } else if (score >= 1000) {
                    return `${(score / 1000).toFixed(1)}K`;
                }
                return score.toString();
            }
        }

        // Sistema de prompt para nome do jogador
        class PlayerNamePrompt extends EventEmitter {
            constructor() {
                super();

                this.isOpen = false;
                this.playerName = this.loadPlayerName();
            }
            // Carregar nome salvo
            loadPlayerName() {
                try {
                    const name = localStorage.getItem('seraphsLastStand_playerName') || '';
                    console.log('Nome carregado do localStorage:', name); // Debug
                    return name;
                } catch (error) {
                    console.error('Erro ao carregar nome do jogador:', error);
                    return '';
                }
            }

            // Salvar nome
            savePlayerName(name) {
                try {
                    const trimmedName = name.trim() || 'Player';
                    localStorage.setItem('seraphsLastStand_playerName', trimmedName);
                    this.playerName = trimmedName;
                    console.log('Nome salvo no localStorage:', trimmedName); // Debug
                } catch (error) {
                    console.warn('Erro ao salvar nome do jogador:', error);
                }
            }

            // Mostrar prompt para nome
            showNamePrompt(callback) {
                if (this.playerName) {
                    // Se já tem nome salvo, perguntar se quer manter
                    const keepName = confirm(`Usar o nome "${this.playerName}"?\nClique Cancel para inserir um novo nome.`);
                    if (keepName) {
                        callback(this.playerName);
                        return;
                    }
                }

                // Mostrar prompt para novo nome
                const name = prompt('Digite seu nome para o ranking:', this.playerName || 'Player');

                if (name !== null) {
                    const trimmedName = name.trim() || 'Player';
                    this.savePlayerName(trimmedName);
                    callback(trimmedName);
                } else {
                    callback(this.playerName || 'Player');
                }
            }

            // Mostrar prompt de configurações
            showSettingsPrompt() {
                const newName = prompt('Digite seu nome:', this.playerName || 'Player');

                if (newName !== null) {
                    const trimmedName = newName.trim() || 'Player';
                    this.savePlayerName(trimmedName);
                    this.emit('nameChanged', trimmedName);
                    return trimmedName;
                }

                return this.playerName;
            }

            // Obter nome atual
            getCurrentName() {
                return this.playerName || 'Player';
            }
        }

    </script>
    <!-- terrain.js -->
    <script>
        // terrain.js - Sistema de terreno e plataformas em degraus

        class Terrain {
            constructor(canvasWidth, canvasHeight) {
                this.canvasWidth = canvasWidth;
                this.canvasHeight = canvasHeight;
                this.platforms = [];

                this.createTerrain();
            }

            createTerrain() {
                // Criar terreno em formato de degraus baseado na descrição
                const stepWidth = 120;
                const stepHeight = 80;
                const numSteps = Math.floor(this.canvasWidth / stepWidth);
                const baseY = this.canvasHeight - 60; // altura do chão

                // Chão principal (base)
                this.platforms.push({
                    x: 0,
                    y: baseY,
                    width: this.canvasWidth,
                    height: 60,
                    type: 'ground'
                });

                // Criar degraus em ambos os lados
                // Lado esquerdo - degraus ascendentes
                for (let i = 0; i < Math.floor(numSteps / 2); i++) {
                    const x = i * stepWidth;
                    const y = baseY - (i + 1) * stepHeight;

                    if (y > 100) { // não criar muito alto
                        this.platforms.push({
                            x: x,
                            y: y,
                            width: stepWidth + 20,
                            height: 20,
                            type: 'platform'
                        });
                    }
                }

                // Lado direito - degraus ascendentes (espelhado)
                for (let i = 0; i < Math.floor(numSteps / 2); i++) {
                    const x = this.canvasWidth - (i + 1) * stepWidth;
                    const y = baseY - (i + 1) * stepHeight;

                    if (y > 100 && x > 0) { // não criar muito alto nem fora da tela
                        this.platforms.push({
                            x: x,
                            y: y,
                            width: stepWidth + 20,
                            height: 20,
                            type: 'platform'
                        });
                    }
                }

                // Plataforma central elevada
                const centerX = this.canvasWidth / 2 - stepWidth / 2;
                const centerY = baseY - stepHeight * 2;

                if (centerY > 150) {
                    this.platforms.push({
                        x: centerX,
                        y: centerY,
                        width: stepWidth,
                        height: 20,
                        type: 'platform'
                    });
                }
            }

            // Verificar colisão de um objeto com as plataformas
            checkCollision(x, y, width, height, velocityY) {
                for (let platform of this.platforms) {
                    // Verificar se está caindo na plataforma (apenas de cima)
                    if (velocityY >= 0 &&
                        y + height >= platform.y &&
                        y + height <= platform.y + platform.height + 10 &&
                        x + width > platform.x &&
                        x < platform.x + platform.width) {

                        return {
                            collided: true,
                            platform: platform,
                            newY: platform.y - height
                        };
                    }
                }

                return { collided: false };
            }

            // Encontrar a plataforma mais próxima abaixo de uma posição
            findGroundBelow(x, y) {
                let closestPlatform = null;
                let closestDistance = Infinity;

                for (let platform of this.platforms) {
                    if (platform.y > y &&
                        x >= platform.x &&
                        x <= platform.x + platform.width) {

                        const distance = platform.y - y;
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestPlatform = platform;
                        }
                    }
                }

                // Se não encontrou plataforma específica, usar o chão
                if (!closestPlatform) {
                    const ground = this.platforms.find(p => p.type === 'ground');
                    if (ground) {
                        return ground.y;
                    }
                }

                return closestPlatform ? closestPlatform.y : this.canvasHeight - 60;
            }

            // Renderizar o terreno com gráficos melhorados
            render(ctx) {
                const time = Date.now() * 0.001;
                
                for (let platform of this.platforms) {
                    if (platform.type === 'ground') {
                        this.renderGround(ctx, platform, time);
                    } else {
                        this.renderPlatform(ctx, platform, time);
                    }
                }
            }
            
            // Renderizar chão principal com textura detalhada
            renderGround(ctx, platform, time) {
                // Base de terra/pedra
                const groundGradient = ctx.createLinearGradient(
                    platform.x, platform.y, 
                    platform.x, platform.y + platform.height
                );
                groundGradient.addColorStop(0, '#8B4513'); // marrom claro no topo
                groundGradient.addColorStop(0.3, '#654321'); // marrom médio
                groundGradient.addColorStop(1, '#2F1B14'); // marrom escuro na base
                
                ctx.fillStyle = groundGradient;
                ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                
                // Textura de pedras/terra
                ctx.fillStyle = 'rgba(139, 69, 19, 0.3)';
                for (let i = 0; i < platform.width; i += 20) {
                    for (let j = 0; j < platform.height; j += 15) {
                        if (Math.random() < 0.4) {
                            const stoneX = platform.x + i + (Math.sin(time + i * 0.01) * 3);
                            const stoneY = platform.y + j + (Math.cos(time + j * 0.01) * 2);
                            ctx.beginPath();
                            ctx.arc(stoneX, stoneY, 2 + Math.random() * 3, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }
                
                // Grama no topo
                this.renderGrass(ctx, platform, time);
                
                // Contorno do chão
                ctx.strokeStyle = '#2F1B14';
                ctx.lineWidth = 3;
                ctx.strokeRect(platform.x, platform.y, platform.width, platform.height);
            }
            
            // Renderizar plataformas flutuantes com cristais mágicos
            renderPlatform(ctx, platform, time) {
                // Base da plataforma (pedra mágica)
                const platformGradient = ctx.createLinearGradient(
                    platform.x, platform.y,
                    platform.x, platform.y + platform.height
                );
                platformGradient.addColorStop(0, '#9370DB'); // púrpura claro
                platformGradient.addColorStop(0.5, '#663399'); // púrpura médio
                platformGradient.addColorStop(1, '#4B0082'); // índigo escuro
                
                // Forma mais orgânica da plataforma
                ctx.fillStyle = platformGradient;
                ctx.beginPath();
                ctx.moveTo(platform.x + 5, platform.y);
                ctx.lineTo(platform.x + platform.width - 5, platform.y);
                ctx.quadraticCurveTo(platform.x + platform.width, platform.y, platform.x + platform.width, platform.y + 5);
                ctx.lineTo(platform.x + platform.width, platform.y + platform.height - 5);
                ctx.quadraticCurveTo(platform.x + platform.width, platform.y + platform.height, platform.x + platform.width - 5, platform.y + platform.height);
                ctx.lineTo(platform.x + 5, platform.y + platform.height);
                ctx.quadraticCurveTo(platform.x, platform.y + platform.height, platform.x, platform.y + platform.height - 5);
                ctx.lineTo(platform.x, platform.y + 5);
                ctx.quadraticCurveTo(platform.x, platform.y, platform.x + 5, platform.y);
                ctx.closePath();
                ctx.fill();
                
                // Cristais mágicos na superfície
                this.renderMagicalCrystals(ctx, platform, time);
                
                // Runas mágicas
                this.renderMagicalRunes(ctx, platform, time);
                
                // Aura mágica pulsante
                const auraAlpha = (Math.sin(time * 2 + platform.x * 0.01) + 1) * 0.15;
                ctx.globalAlpha = auraAlpha;
                ctx.fillStyle = '#66CCFF';
                ctx.fillRect(platform.x - 2, platform.y - 2, platform.width + 4, platform.height + 4);
                ctx.globalAlpha = 1.0;
                
                // Borda brilhante
                ctx.strokeStyle = '#E6E6FA';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Partículas mágicas flutuando
                this.renderFloatingParticles(ctx, platform, time);
            }
            
            // Renderizar grama no topo do chão
            renderGrass(ctx, platform, time) {
                ctx.strokeStyle = '#228B22'; // verde floresta
                ctx.lineWidth = 2;
                
                for (let x = platform.x; x < platform.x + platform.width; x += 8) {
                    const grassHeight = 8 + Math.sin(time * 2 + x * 0.1) * 3;
                    const grassX = x + Math.sin(time + x * 0.05) * 1;
                    
                    // Hastes de grama
                    ctx.beginPath();
                    ctx.moveTo(grassX, platform.y);
                    ctx.lineTo(grassX + Math.sin(time + x * 0.1) * 2, platform.y - grassHeight);
                    ctx.stroke();
                    
                    // Folhas pequenas
                    if (Math.random() < 0.3) {
                        ctx.fillStyle = '#32CD32'; // verde lima
                        ctx.beginPath();
                        ctx.ellipse(grassX + 1, platform.y - grassHeight * 0.7, 2, 3, Math.PI / 6, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            // Renderizar cristais mágicos nas plataformas
            renderMagicalCrystals(ctx, platform, time) {
                const numCrystals = Math.floor(platform.width / 30);
                
                for (let i = 0; i < numCrystals; i++) {
                    const crystalX = platform.x + 15 + i * 30 + Math.sin(time + i) * 3;
                    const crystalY = platform.y - 5;
                    const crystalSize = 3 + Math.sin(time * 1.5 + i) * 1;
                    
                    // Cristal principal
                    const crystalColors = ['#66CCFF', '#9966FF', '#FF66CC', '#66FF99'];
                    const color = crystalColors[i % crystalColors.length];
                    
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    // Formato de cristal (losango)
                    ctx.moveTo(crystalX, crystalY - crystalSize);
                    ctx.lineTo(crystalX + crystalSize * 0.7, crystalY);
                    ctx.lineTo(crystalX, crystalY + crystalSize);
                    ctx.lineTo(crystalX - crystalSize * 0.7, crystalY);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Brilho do cristal
                    ctx.fillStyle = '#FFFFFF';
                    ctx.globalAlpha = 0.7;
                    ctx.beginPath();
                    ctx.moveTo(crystalX - crystalSize * 0.3, crystalY - crystalSize * 0.7);
                    ctx.lineTo(crystalX, crystalY - crystalSize * 0.3);
                    ctx.lineTo(crystalX - crystalSize * 0.1, crystalY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    
                    // Aura do cristal
                    const auraSize = crystalSize * (1.5 + Math.sin(time * 3 + i) * 0.5);
                    ctx.globalAlpha = 0.3;
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(crystalX, crystalY, auraSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                }
            }
            
            // Renderizar runas mágicas nas plataformas
            renderMagicalRunes(ctx, platform, time) {
                if (platform.width < 60) return; // Só em plataformas maiores
                
                const runeX = platform.x + platform.width / 2;
                const runeY = platform.y + platform.height / 2;
                const runeSize = 6;
                
                // Círculo mágico principal
                ctx.strokeStyle = `rgba(255, 215, 0, ${0.6 + Math.sin(time * 2) * 0.3})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(runeX, runeY, runeSize, 0, Math.PI * 2);
                ctx.stroke();
                
                // Símbolos internos rotativos
                ctx.save();
                ctx.translate(runeX, runeY);
                ctx.rotate(time * 0.5);
                
                // Triangulo interno
                ctx.beginPath();
                ctx.moveTo(0, -runeSize * 0.5);
                ctx.lineTo(runeSize * 0.4, runeSize * 0.3);
                ctx.lineTo(-runeSize * 0.4, runeSize * 0.3);
                ctx.closePath();
                ctx.stroke();
                
                // Linhas cruzadas
                ctx.beginPath();
                ctx.moveTo(-runeSize * 0.7, 0);
                ctx.lineTo(runeSize * 0.7, 0);
                ctx.moveTo(0, -runeSize * 0.7);
                ctx.lineTo(0, runeSize * 0.7);
                ctx.stroke();
                
                ctx.restore();
            }
            
            // Renderizar partículas mágicas flutuando
            renderFloatingParticles(ctx, platform, time) {
                const numParticles = Math.floor(platform.width / 40);
                
                for (let i = 0; i < numParticles; i++) {
                    const particleX = platform.x + 20 + i * 40 + Math.sin(time + i * 2) * 15;
                    const particleY = platform.y - 10 + Math.cos(time * 1.5 + i) * 8;
                    const particleSize = 1 + Math.sin(time * 3 + i) * 0.5;
                    
                    // Partícula principal
                    ctx.fillStyle = '#66CCFF';
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Trilha da partícula
                    ctx.fillStyle = 'rgba(102, 204, 255, 0.3)';
                    for (let j = 1; j <= 3; j++) {
                        const trailX = particleX - Math.sin(time + i * 2) * j * 3;
                        const trailY = particleY - Math.cos(time * 1.5 + i) * j * 2;
                        ctx.beginPath();
                        ctx.arc(trailX, trailY, particleSize * (1 - j * 0.2), 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.globalAlpha = 1.0;
                }
            }

            // Atualizar tamanho quando canvas redimensionar
            resize(newWidth, newHeight) {
                this.canvasWidth = newWidth;
                this.canvasHeight = newHeight;
                this.platforms = [];
                this.createTerrain();
            }

            // Obter todas as plataformas (para uso pelo player)
            getPlatforms() {
                return this.platforms;
            }
        }

    </script>
    <!-- equipament.js -->
    <script>
        // equipment.js - Sistema de equipamentos (Chapéus e Cajados)

        // Enum para tipos de equipamentos
        const EquipmentType = {
            HAT: 'hat',
            STAFF: 'staff'
        };

        // Enum para raridades dos equipamentos
        const EquipmentRarity = {
            COMMON: 'common',
            UNCOMMON: 'uncommon',
            RARE: 'rare',
            LEGENDARY: 'legendary'
        };

        // Definições dos Chapéus
        const HAT_DEFINITIONS = {
            wizardHat: {
                id: 'wizardHat',
                name: 'Chapéu de Mago',
                description: 'Clássico pontudo, efeito básico balanceado',
                image: 'chapeu-mago',
                type: EquipmentType.HAT,
                rarity: EquipmentRarity.COMMON,
                cost: 50,
                unlocked: true, // Disponível desde o início
                effects: {
                    damage: 5,
                    expMultiplier: 1.1
                },
                apply: (player) => {
                    player.expMultiplier = (player.expMultiplier || 1) * 1.1;
                    player.damage += 5;
                }
            },

            helmet: {
                id: 'helmet',
                name: 'Capacete de Batalha',
                description: '+Defesa e HP, -Velocidade de movimento',
                image: 'capacete',
                type: EquipmentType.HAT,
                rarity: EquipmentRarity.COMMON,
                cost: 75,
                unlocked: false,
                unlockCondition: 'Take 1000 damage in a single run',
                effects: {
                    defense: 15,
                    maxHp: 25
                },
                apply: (player) => {
                    player.defense += 15;
                    player.maxHp += 25;
                    player.speed *= 0.9; // -10% velocidade
                }
            },

            propellerBeanie: {
                id: 'propellerBeanie',
                name: 'Gorro Hélice',
                description: 'Melhora velocidade de movimento e ataque',
                image: 'gorro-helice',
                type: EquipmentType.HAT,
                rarity: EquipmentRarity.UNCOMMON,
                cost: 150,
                unlocked: false,
                unlockCondition: 'Jump 500 times in a single run',
                effects: {
                    attackSpeed: 0.5,
                    critChance: 0.05
                },
                apply: (player) => {
                    player.attackSpeed += 0.5;
                    player.critChance += 0.05;
                    player.speed *= 1.2; // +20% velocidade
                }
            },

            uncommonHat: {
                id: 'uncommonHat',
                name: 'Chapéu da Sorte',
                description: 'Aumenta chance de crítico e drop de soul orbs',
                image: 'chapeu-incomum',
                type: EquipmentType.HAT,
                rarity: EquipmentRarity.RARE,
                cost: 300,
                unlocked: false,
                unlockCondition: 'Get 50 uncommon cards',
                effects: {
                    critChance: 0.1,
                    critMultiplier: 0.5
                },
                apply: (player) => {
                    player.critChance += 0.1;
                    player.critMultiplier += 0.5;
                }
            },

            challengerHat: {
                id: 'challengerHat',
                name: 'Chapéu do Desafiante',
                description: '20% chance de double loot, dobra inimigos',
                image: 'chapeu-desafiante',
                type: EquipmentType.HAT,
                rarity: EquipmentRarity.LEGENDARY,
                cost: 500,
                unlocked: false,
                unlockCondition: 'Reach level 50',
                effects: {
                    doubleLootChance: 0.2,
                    doubleEnemies: true
                },
                apply: (player) => {
                    player.abilities = player.abilities || {};
                    player.abilities.doubleLootChance = 0.2;
                    player.abilities.doubleEnemySpawn = true;
                }
            },

            fedora: {
                id: 'fedora',
                name: 'Fedora',
                description: 'Reroll gratuito infinito, desabilita ranking online',
                image: 'fedora',
                type: EquipmentType.HAT,
                rarity: EquipmentRarity.LEGENDARY,
                cost: 750,
                unlocked: false,
                unlockCondition: 'Reroll cards 100 times',
                effects: {
                    infiniteRerolls: true,
                    disableRanking: true
                },
                apply: (player) => {
                    player.abilities = player.abilities || {};
                    player.abilities.infiniteRerolls = true;
                    player.abilities.rankingDisabled = true;
                }
            }
        };

        // Definições dos Cajados
        const STAFF_DEFINITIONS = {
            wizardStaff: {
                id: 'wizardStaff',
                name: 'Cajado do Mago',
                description: 'Projétil único em linha reta (padrão)',
                image: 'cajado-mago',
                type: EquipmentType.STAFF,
                rarity: EquipmentRarity.COMMON,
                cost: 0, // Grátis - item inicial
                unlocked: true,
                shootingPattern: 'single',
                effects: {
                    // Padrão - sem modificadores
                },
                apply: (player) => {
                    player.shootingPattern = 'single';
                }
            },

            emeraldStaff: {
                id: 'emeraldStaff',
                name: 'Cajado de Esmeralda',
                description: 'Projéteis teleguiados, +velocidade de ataque, -50% dano',
                image: 'cajado-esmeralda',
                type: EquipmentType.STAFF,
                rarity: EquipmentRarity.UNCOMMON,
                cost: 100,
                unlocked: false,
                unlockCondition: 'Kill 1000 enemies',
                shootingPattern: 'homing',
                effects: {
                    homingProjectiles: true,
                    attackSpeedBonus: 0.5,
                    damagePenalty: -0.5
                },
                apply: (player) => {
                    player.shootingPattern = 'homing';
                    player.attackSpeed *= 1.5;
                    player.damage *= 0.5;
                    player.abilities = player.abilities || {};
                    player.abilities.homingProjectiles = true;
                }
            },

            trident: {
                id: 'trident',
                name: 'Tridente',
                description: 'Disparo triplo em leque',
                image: 'tridente',
                type: EquipmentType.STAFF,
                rarity: EquipmentRarity.UNCOMMON,
                cost: 120,
                unlocked: false,
                unlockCondition: 'Fire 10000 projectiles',
                shootingPattern: 'triple',
                effects: {
                    projectileCount: 3,
                    spreadAngle: 30
                },
                apply: (player) => {
                    player.shootingPattern = 'triple';
                    player.projectileCount = 3;
                    player.spreadAngle = 30; // graus
                }
            },

            boomstaff: {
                id: 'boomstaff',
                name: 'Boomstaff',
                description: 'Projéteis explosivos com área de dano',
                image: 'boomstaff',
                type: EquipmentType.STAFF,
                rarity: EquipmentRarity.RARE,
                cost: 200,
                unlocked: false,
                unlockCondition: 'Deal 50000 damage in a single run',
                shootingPattern: 'explosive',
                effects: {
                    explosiveProjectiles: true,
                    explosionRadius: 50,
                    explosionDamage: 0.7 // 70% do dano base
                },
                apply: (player) => {
                    player.shootingPattern = 'explosive';
                    player.abilities = player.abilities || {};
                    player.abilities.explosiveProjectiles = true;
                    player.abilities.explosionRadius = 50;
                    player.abilities.explosionDamage = player.damage * 0.7;
                }
            },

            thunderStaff: {
                id: 'thunderStaff',
                name: 'Cajado do Trovão',
                description: 'Invoca raios do céu em área aleatória',
                image: 'cajado-trovao',
                type: EquipmentType.STAFF,
                rarity: EquipmentRarity.RARE,
                cost: 250,
                unlocked: false,
                unlockCondition: 'Get Thunderbolt card 10 times',
                shootingPattern: 'lightning',
                effects: {
                    lightningStrikes: true,
                    lightningInterval: 2000,
                    lightningCount: 3
                },
                apply: (player) => {
                    player.shootingPattern = 'lightning';
                    player.abilities = player.abilities || {};
                    player.abilities.lightningStrikes = true;
                    player.abilities.lightningInterval = 2000;
                    player.abilities.lightningCount = 3;
                    player.lastLightning = 0;
                }
            },

            frozenTip: {
                id: 'frozenTip',
                name: 'Ponta Congelada',
                description: 'Projéteis perfuram múltiplos inimigos',
                image: 'ponta-congelada',
                type: EquipmentType.STAFF,
                rarity: EquipmentRarity.RARE,
                cost: 180,
                unlocked: false,
                unlockCondition: 'Kill 3 enemies with one projectile',
                shootingPattern: 'piercing',
                effects: {
                    piercingProjectiles: true,
                    maxPierces: 5
                },
                apply: (player) => {
                    player.shootingPattern = 'piercing';
                    player.abilities = player.abilities || {};
                    player.abilities.piercingProjectiles = true;
                    player.abilities.maxPierces = 5;
                }
            },

            rainbowStaff: {
                id: 'rainbowStaff',
                name: 'Cajado Arco-Íris',
                description: 'Efeito aleatório a cada tiro',
                image: 'cajado-arco-iris',
                type: EquipmentType.STAFF,
                rarity: EquipmentRarity.LEGENDARY,
                cost: 500,
                unlocked: false,
                unlockCondition: 'Use all other staffs at least once',
                shootingPattern: 'random',
                effects: {
                    randomEffects: true
                },
                apply: (player) => {
                    player.shootingPattern = 'random';
                    player.abilities = player.abilities || {};
                    player.abilities.randomEffects = true;
                }
            }
        };

        // Combinar todas as definições de equipamentos
        const EQUIPMENT_DEFINITIONS = {
            ...HAT_DEFINITIONS,
            ...STAFF_DEFINITIONS
        };

        // Classe para gerenciar equipamentos do jogador
        class EquipmentManager {
            constructor() {
                this.equippedHat = 'wizardHat';
                this.equippedStaff = 'wizardStaff';
                this.unlockedEquipment = ['wizardHat', 'wizardStaff'];
            }

            // Equipar item
            equip(equipmentId) {
                const equipment = EQUIPMENT_DEFINITIONS[equipmentId];
                if (!equipment || !this.isUnlocked(equipmentId)) {
                    return false;
                }

                if (equipment.type === EquipmentType.HAT) {
                    this.equippedHat = equipmentId;
                } else if (equipment.type === EquipmentType.STAFF) {
                    this.equippedStaff = equipmentId;
                }

                return true;
            }

            // Verificar se equipamento está desbloqueado
            isUnlocked(equipmentId) {
                return this.unlockedEquipment.includes(equipmentId);
            }

            // Desbloquear equipamento
            unlock(equipmentId) {
                if (!this.unlockedEquipment.includes(equipmentId)) {
                    this.unlockedEquipment.push(equipmentId);
                    return true;
                }
                return false;
            }

            // Obter equipamento atual
            getEquippedHat() {
                return EQUIPMENT_DEFINITIONS[this.equippedHat];
            }

            getEquippedStaff() {
                return EQUIPMENT_DEFINITIONS[this.equippedStaff];
            }

            // Aplicar efeitos dos equipamentos ao jogador
            applyEquipmentEffects(player) {
                const hat = this.getEquippedHat();
                const staff = this.getEquippedStaff();

                if (hat && hat.apply) {
                    hat.apply(player);
                }

                if (staff && staff.apply) {
                    staff.apply(player);
                }

                // Verificar sinergias especiais
                this.checkSynergies(player, hat, staff);
            }

            // Verificar sinergias entre chapéu e cajado
            checkSynergies(player, hat, staff) {
                // Exemplo: Chapéu de Mago + Cajado do Trovão = Raios mais frequentes
                if (hat.id === 'wizardHat' && staff.id === 'thunderStaff') {
                    player.abilities = player.abilities || {};
                    player.abilities.lightningInterval *= 0.7; // 30% mais rápido
                }

                // Capacete + Boomstaff = Explosões absorvem parte do dano
                if (hat.id === 'helmet' && staff.id === 'boomstaff') {
                    player.abilities = player.abilities || {};
                    player.abilities.explosionHealing = true;
                }

                // Gorro Hélice + Cajado de Esmeralda = Projéteis perseguem mais agressivamente
                if (hat.id === 'propellerBeanie' && staff.id === 'emeraldStaff') {
                    player.abilities = player.abilities || {};
                    player.abilities.aggressiveHoming = true;
                }
            }

            // Salvar estado
            save() {
                return {
                    equippedHat: this.equippedHat,
                    equippedStaff: this.equippedStaff,
                    unlockedEquipment: [...this.unlockedEquipment]
                };
            }

            // Carregar estado
            load(data) {
                if (data) {
                    this.equippedHat = data.equippedHat || 'wizardHat';
                    this.equippedStaff = data.equippedStaff || 'wizardStaff';
                    this.unlockedEquipment = data.unlockedEquipment || ['wizardHat', 'wizardStaff'];
                }
            }

            // Métodos para integração com a loja
            getAllEquipment() {
                return {
                    hats: HAT_DEFINITIONS,
                    staffs: STAFF_DEFINITIONS
                };
            }

            getEquipment(type, itemId) {
                if (type === 'hats') {
                    return HAT_DEFINITIONS[itemId];
                } else if (type === 'staffs') {
                    return STAFF_DEFINITIONS[itemId];
                }
                return null;
            }

            applyEquipmentEffects(player, type, itemId) {
                const equipment = this.getEquipment(type, itemId);
                if (!equipment || !equipment.effects) return;

                console.log(`Aplicando efeitos de ${equipment.name}:`, equipment.effects);

                // Aplicar cada efeito
                Object.entries(equipment.effects).forEach(([effect, value]) => {
                    switch (effect) {
                        case 'damage':
                            player.damage += value;
                            break;
                        case 'defense':
                            player.defense += value;
                            break;
                        case 'speed':
                            player.speed += value;
                            break;
                        case 'critChance':
                            player.critChance += value / 100; // converter porcentagem
                            break;
                        case 'hp':
                        case 'maxHp':
                            player.maxHp += value;
                            if (player.hp < player.maxHp) {
                                player.hp = Math.min(player.hp + value, player.maxHp);
                            }
                            break;
                        case 'xpBonus':
                        case 'expMultiplier':
                            player.expMultiplier = (player.expMultiplier || 1) * (1 + value / 100);
                            break;
                        case 'specialCooldown':
                            // Reduzir cooldown de habilidades especiais
                            if (player.abilities) {
                                Object.keys(player.abilities).forEach(ability => {
                                    if (ability.includes('Cooldown') || ability.includes('cooldown')) {
                                        player.abilities[ability] *= (1 - value / 100);
                                    }
                                });
                            }
                            break;
                        case 'fireRate':
                        case 'attackSpeed':
                            player.attackSpeed *= (1 + value / 100);
                            break;
                    }
                });
            }

            unapplyEquipmentEffects(player, type, itemId) {
                const equipment = this.getEquipment(type, itemId);
                if (!equipment || !equipment.effects) return;

                console.log(`Removendo efeitos de ${equipment.name}:`, equipment.effects);

                // Remover cada efeito (operação inversa)
                Object.entries(equipment.effects).forEach(([effect, value]) => {
                    switch (effect) {
                        case 'damage':
                            player.damage -= value;
                            break;
                        case 'defense':
                            player.defense -= value;
                            break;
                        case 'speed':
                            player.speed -= value;
                            break;
                        case 'critChance':
                            player.critChance -= value / 100;
                            break;
                        case 'maxHp':
                            player.maxHp -= value;
                            if (player.hp > player.maxHp) {
                                player.hp = player.maxHp;
                            }
                            break;
                        case 'xpBonus':
                        case 'expMultiplier':
                            player.expMultiplier = (player.expMultiplier || 1) / (1 + value / 100);
                            break;
                        case 'fireRate':
                        case 'attackSpeed':
                            player.attackSpeed /= (1 + value / 100);
                            break;
                    }
                });
            }
        }

        // Função para verificar condições de desbloqueio
        function checkUnlockConditions(player, stats) {
            const unlocked = [];

            Object.values(EQUIPMENT_DEFINITIONS).forEach(equipment => {
                if (equipment.unlocked || equipment.unlockCondition === undefined) {
                    return; // Já desbloqueado ou sem condição
                }

                let shouldUnlock = false;

                // Verificar diferentes tipos de condições
                const condition = equipment.unlockCondition.toLowerCase();

                if (condition.includes('damage') && condition.includes('1000')) {
                    shouldUnlock = stats.totalDamageTaken >= 1000;
                } else if (condition.includes('jump') && condition.includes('500')) {
                    shouldUnlock = stats.totalJumps >= 500;
                } else if (condition.includes('level') && condition.includes('50')) {
                    shouldUnlock = player.level >= 50;
                } else if (condition.includes('enemies') && condition.includes('1000')) {
                    shouldUnlock = stats.totalKills >= 1000;
                } else if (condition.includes('projectiles') && condition.includes('10000')) {
                    shouldUnlock = stats.totalProjectilesFired >= 10000;
                } else if (condition.includes('damage') && condition.includes('50000')) {
                    shouldUnlock = stats.totalDamageDealt >= 50000;
                }

                if (shouldUnlock) {
                    unlocked.push(equipment.id);
                }
            });

            return unlocked;
        }

        // Export das funcionalidades principais
        if (typeof module !== 'undefined' && module.exports) {
            module.exports = {
                EQUIPMENT_DEFINITIONS,
                HAT_DEFINITIONS,
                STAFF_DEFINITIONS,
                EquipmentType,
                EquipmentRarity,
                EquipmentManager,
                checkUnlockConditions
            };
        }
    </script>
    <!-- Player Scripts -->
    <script>
        // player.js - Sistema do jogador com mecânicas de plataforma

        // Importar definições de equipamentos se não estiverem disponíveis globalmente
        if (typeof EQUIPMENT_DEFINITIONS === 'undefined') {
            console.warn('EQUIPMENT_DEFINITIONS não está disponível. Sprites de equipamentos não funcionarão.');
        }

        class Player extends EventEmitter {
            constructor(x, y) {
                super();

                // Posição e movimento (plataforma)
                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.speed = 200; // pixels por segundo horizontal
                this.size = 20;

                // Física de plataforma
                this.onGround = false;
                this.jumpSpeed = 400; // velocidade inicial do pulo
                this.gravity = 1200; // acelereção da gravidade
                this.jumpsAvailable = 1;
                this.maxJumps = 1;
                this.groundY = 0; // será definido pela plataforma atual

                // Estatísticas base
                this.maxHp = 100;
                this.hp = this.maxHp;
                this.damage = 15;
                this.attackSpeed = 3.0; // tiros por segundo
                this.critChance = 0.05; // 5%
                this.critMultiplier = 1.5;
                this.defense = 0;

                // Sistema de experiência e nível
                this.level = 1;
                this.exp = 0;
                this.expToNext = 100; // EXP necessária para próximo nível
                this.expGrowthRate = 1.5; // multiplicador de EXP por nível

                // Soul Orbs (moeda do jogo)
                this.soulOrbs = 0;

                // Sistema de equipamentos
                this.ownedEquipment = {
                    hats: [],
                    staffs: []
                };
                this.equippedEquipment = {
                    hats: null,
                    staffs: null
                };

                // Sistema de sprites
                this.sprites = {
                    base: null,
                    hat: null,
                    staff: null
                };
                this.facingRight = true;
                this.spriteSize = 64; // tamanho do sprite base

                // Carregar sprites
                this.loadSprites();

                // Sistema de pontuação e estatísticas
                this.score = 0;
                this.enemiesKilled = 0;
                this.totalDamageDealt = 0;
                this.shotsHit = 0;
                this.shotsFired = 0;
                this.criticalHits = 0;
                this.survivalTime = 0;
                this.playerName = 'Player'; // Nome padrão

                // Sistema de build/cartas escolhidas
                this.selectedCards = []; // Array das cartas escolhidas durante a partida
                this.cardEffects = {}; // Efeitos ativos das cartas
                this.onKillEffects = []; // Efeitos que ativam quando um inimigo morre
                this.cardStacks = {}; // Contador de stacks das cartas

                // Sistema de tiro (mouse aim)
                this.lastShotTime = 0;
                this.mouseX = 0;
                this.mouseY = 0;
                this.isShooting = false; // para disparo automático ao segurar
                this.projectiles = [];
                this.projectileSpeed = 500;
                this.projectileSize = 6;

                // Estados especiais
                this.invulnerable = false;
                this.invulnerabilityTime = 0;
                this.invulnerabilityDuration = 1000; // 1 segundo

                // Visual
                this.color = '#66ffff';

                // Input (apenas A/D/Space)
                this.input = {
                    left: false,   // A
                    right: false,  // D
                    jump: false    // Space
                };

                // Mobile controls
                this.mobileControls = {
                    left: false,
                    right: false,
                    jump: false,
                    shooting: false,
                    aimX: 0,
                    aimY: 0
                };

                // Plataformas para colisão
                this.platforms = [];
            }

            update(deltaTime, enemies, canvas, platforms = []) {
                this.platforms = platforms;
                this.handleMovement(deltaTime, canvas);
                this.handleShooting(deltaTime, enemies);
                this.updateProjectiles(deltaTime, enemies, canvas);
                this.updateInvulnerability(deltaTime);
                this.updateCardEffects(deltaTime, enemies, canvas);
                this.updateCastingParticles(deltaTime); // Atualizar partículas mágicas
                this.updateLevelUpParticles(deltaTime); // Atualizar partículas de level up

                // Manter dentro do canvas horizontalmente
                this.constrainToCanvas(canvas);
            }

            handleMovement(deltaTime, canvas) {
                const dt = deltaTime / 1000;

                // Só processar movimento se o jogo estiver ativo
                if (window.game && window.game.state !== 'playing') {
                    this.vx = 0;
                    return;
                }

                // Verificar se é desktop
                const isDesktop = !window.DeviceUtils || !DeviceUtils.isMobile();

                // Movimento horizontal (apenas A/D)
                let moveX = 0;

                // DESKTOP: usar APENAS input de teclado, ignorar completamente mobile controls
                if (isDesktop) {
                    // Limpar mobile controls em desktop para evitar conflitos
                    this.mobileControls.left = false;
                    this.mobileControls.right = false;

                    // Apenas teclado
                    if (this.input.left && !this.input.right) {
                        moveX -= 1;
                        this.facingRight = false;
                    } else if (this.input.right && !this.input.left) {
                        moveX += 1;
                        this.facingRight = true;
                    }
                } else {
                    // MOBILE: prioridade para teclado, fallback para mobile
                    if (this.input.left || this.input.right) {
                        // Usar apenas input de teclado
                        if (this.input.left && !this.input.right) {
                            moveX -= 1;
                            this.facingRight = false;
                        } else if (this.input.right && !this.input.left) {
                            moveX += 1;
                            this.facingRight = true;
                        }
                    } else {
                        // Fallback para mobile controls
                        if (this.mobileControls.left && !this.mobileControls.right) {
                            moveX -= 1;
                            this.facingRight = false;
                        } else if (this.mobileControls.right && !this.mobileControls.left) {
                            moveX += 1;
                            this.facingRight = true;
                        }
                    }
                }

                // Aplicar velocidade horizontal
                this.vx = moveX * this.speed;

                // Sistema de pulo (Space)
                if ((this.input.jump || this.mobileControls.jump) && this.jumpsAvailable > 0) {
                    this.vy = -this.jumpSpeed;
                    this.jumpsAvailable--;
                    this.onGround = false;
                    this.input.jump = false; // Evita salto contínuo
                    this.mobileControls.jump = false;
                }

                // Aplicar gravidade
                if (!this.onGround) {
                    this.vy += this.gravity * dt;
                }

                // Atualizar posição
                const oldY = this.y;
                this.x += this.vx * dt;
                this.y += this.vy * dt;

                // Verificar colisão com plataformas
                this.checkPlatformCollisions(oldY, canvas);
            }

            checkPlatformCollisions(oldY, canvas) {
                // Colisão com o chão (bottom do canvas)
                const groundLevel = canvas.height - 40; // espaço para o chão
                if (this.y + this.size >= groundLevel) {
                    this.y = groundLevel - this.size;
                    this.vy = 0;
                    this.onGround = true;
                    this.jumpsAvailable = this.maxJumps;
                    return;
                }

                // Colisão com plataformas (degraus)
                this.onGround = false;

                for (let platform of this.platforms) {
                    // Verificar se está caindo na plataforma
                    if (this.vy >= 0 && oldY + this.size <= platform.y &&
                        this.y + this.size >= platform.y &&
                        this.x + this.size > platform.x &&
                        this.x < platform.x + platform.width) {

                        this.y = platform.y - this.size;
                        this.vy = 0;
                        this.onGround = true;
                        this.jumpsAvailable = this.maxJumps;
                        break;
                    }
                }
            }

            handleShooting(deltaTime, enemies) {
                if (!this.isShooting && !this.mobileControls.shooting) return;

                const now = Date.now();
                const shotInterval = 1000 / this.attackSpeed;

                if (now - this.lastShotTime >= shotInterval) {
                    let aimX = this.mouseX;
                    let aimY = this.mouseY;

                    // Verificar se é dispositivo móvel
                    const isMobile = window.DeviceUtils && DeviceUtils.isMobile();

                    if (isMobile && this.mobileControls.shooting) {
                        // Mobile: atirar no inimigo mais próximo
                        const nearestEnemy = this.findNearestEnemy(enemies);

                        if (nearestEnemy) {
                            // Atirar no inimigo mais próximo
                            aimX = nearestEnemy.x;
                            aimY = nearestEnemy.y;
                        } else {
                            // Se não há inimigos próximos, atirar na direção que está andando
                            const movingLeft = this.input.left || this.mobileControls.left;
                            const movingRight = this.input.right || this.mobileControls.right;

                            if (movingLeft) {
                                this.facingRight = false;
                                aimX = this.x - 150;
                                aimY = this.y;
                            } else if (movingRight) {
                                this.facingRight = true;
                                aimX = this.x + 150;
                                aimY = this.y;
                            } else {
                                // Se não está se movendo, atirar na direção que está olhando
                                aimX = this.x + (this.facingRight ? 150 : -150);
                                aimY = this.y;
                            }
                        }
                    } else if (!isMobile) {
                        // Desktop/Web: continuar usando posição do mouse
                        // Se o mouse não foi movido ainda, atirar na direção que está olhando
                        if (this.mouseX === 0 && this.mouseY === 0) {
                            aimX = this.x + (this.facingRight ? 150 : -150);
                            aimY = this.y;
                        }
                    }

                    this.shootAt(aimX, aimY);
                    this.lastShotTime = now;
                }
            }

            shootAt(targetX, targetY) {
                const angle = Math.atan2(targetY - this.y, targetX - this.x);
                
                // Determinar tipo de projétil baseado no padrão de tiro
                let projectileType = 'basic';
                if (this.shootingPattern) {
                    switch(this.shootingPattern) {
                        case 'homing': projectileType = 'homing'; break;
                        case 'explosive': projectileType = 'explosive'; break;
                        case 'lightning': projectileType = 'lightning'; break;
                        case 'piercing': projectileType = 'piercing'; break;
                        case 'random': projectileType = 'random'; break;
                        default: projectileType = 'basic'; break;
                    }
                }
                
                const projectile = {
                    x: this.x,
                    y: this.y - this.size / 2, // sair do centro do player
                    vx: Math.cos(angle) * this.projectileSpeed,
                    vy: Math.sin(angle) * this.projectileSpeed,
                    size: this.projectileSize,
                    damage: this.calculateDamage(),
                    lifetime: 3000, // 3 segundos
                    createdAt: Date.now(),
                    color: this.color,
                    type: projectileType
                };

                this.projectiles.push(projectile);
                this.emit('shot', projectile);
                this.playShotSound(); // Toca som de tiro
                
                // Criar partículas mágicas ao atirar
                this.createCastingParticles(angle);
            }
            
            // Método para criar partículas mágicas quando atira
            createCastingParticles(angle) {
                if (!this.castingParticles) {
                    this.castingParticles = [];
                }
                
                // Criar várias partículas na direção do tiro
                for (let i = 0; i < 8; i++) {
                    const spreadAngle = angle + (Math.random() - 0.5) * 0.8; // Espalhar um pouco
                    const speed = 100 + Math.random() * 100;
                    const lifetime = 500 + Math.random() * 500;
                    
                    const particle = {
                        x: this.x + Math.cos(angle) * this.size * 0.5, // Começar na frente do mago
                        y: this.y + Math.sin(angle) * this.size * 0.5,
                        vx: Math.cos(spreadAngle) * speed,
                        vy: Math.sin(spreadAngle) * speed,
                        size: 2 + Math.random() * 4,
                        color: `hsl(${180 + Math.random() * 60}, 70%, ${60 + Math.random() * 30}%)`,
                        alpha: 1.0,
                        lifetime: lifetime,
                        maxLifetime: lifetime,
                        createdAt: Date.now()
                    };
                    
                    this.castingParticles.push(particle);
                }
            }
            
            // Atualizar e renderizar partículas de magia
            updateCastingParticles(deltaTime) {
                if (!this.castingParticles) return;
                
                const dt = deltaTime / 1000;
                const now = Date.now();
                
                this.castingParticles = this.castingParticles.filter(particle => {
                    // Atualizar posição
                    particle.x += particle.vx * dt;
                    particle.y += particle.vy * dt;
                    
                    // Aplicar fricção
                    particle.vx *= 0.98;
                    particle.vy *= 0.98;
                    
                    // Fade out baseado no tempo de vida
                    const age = now - particle.createdAt;
                    particle.alpha = Math.max(0, 1 - (age / particle.lifetime));
                    
                    // Remover se expirou
                    return age < particle.lifetime;
                });
            }
            
            renderCastingParticles(ctx) {
                if (!this.castingParticles) return;
                
                ctx.save();
                
                this.castingParticles.forEach(particle => {
                    ctx.globalAlpha = particle.alpha;
                    
                    // Criar efeito de brilho mágico
                    const gradient = ctx.createRadialGradient(
                        particle.x, particle.y, 0,
                        particle.x, particle.y, particle.size * 3
                    );
                    
                    // Converter cor para formato que aceita alpha
                    const baseColor = particle.color;
                    let colorWithAlpha50, colorWithAlpha0;
                    
                    if (baseColor.startsWith('hsl')) {
                        // Para cores HSL, converter para hsla
                        const hslMatch = baseColor.match(/hsl\(([^)]+)\)/);
                        if (hslMatch) {
                            colorWithAlpha50 = `hsla(${hslMatch[1]}, 0.5)`;
                            colorWithAlpha0 = `hsla(${hslMatch[1]}, 0)`;
                        } else {
                            colorWithAlpha50 = 'rgba(102, 204, 255, 0.5)';
                            colorWithAlpha0 = 'rgba(102, 204, 255, 0)';
                        }
                    } else if (baseColor.startsWith('#')) {
                        // Para cores hex, adicionar alpha
                        colorWithAlpha50 = baseColor + '80';
                        colorWithAlpha0 = baseColor + '00';
                    } else {
                        // Fallback para cores nomeadas
                        colorWithAlpha50 = 'rgba(102, 204, 255, 0.5)';
                        colorWithAlpha0 = 'rgba(102, 204, 255, 0)';
                    }
                    
                    gradient.addColorStop(0, baseColor);
                    gradient.addColorStop(0.5, colorWithAlpha50);
                    gradient.addColorStop(1, colorWithAlpha0);
                    
                    // Brilho externo
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size * 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Núcleo da partícula
                    ctx.fillStyle = particle.color;
                    ctx.beginPath();
                    ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Brilho central
                    ctx.fillStyle = `rgba(255, 255, 255, ${particle.alpha * 0.8})`;
                    ctx.beginPath();
                    ctx.arc(particle.x - particle.size * 0.2, particle.y - particle.size * 0.2, particle.size * 0.4, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Efeito de trilha cintilante
                    if (particle.alpha > 0.5) {
                        for (let i = 1; i <= 3; i++) {
                            const trailX = particle.x - particle.vx * 0.01 * i;
                            const trailY = particle.y - particle.vy * 0.01 * i;
                            const trailAlpha = particle.alpha * (1 - i * 0.3);
                            const trailSize = particle.size * (1 - i * 0.2);
                            
                            ctx.globalAlpha = trailAlpha;
                            ctx.fillStyle = particle.color;
                            ctx.beginPath();
                            ctx.arc(trailX, trailY, trailSize, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                });
                
                ctx.restore();
            }

            // Métodos para controle de mira
            setMousePosition(x, y) {
                this.mouseX = x;
                this.mouseY = y;
            }

            // Métodos para controle de tiro (compatibilidade com mouse e mobile)
            startShooting() {
                this.isShooting = true;
                this.mobileControls.shooting = true;
            }

            stopShooting() {
                this.isShooting = false;
                this.mobileControls.shooting = false;
            }

            // Métodos para controle de experiência
            gainExp(amount) {
                // Aplicar multiplicador de XP
                const xpMultiplier = window.game ? window.game.getXpMultiplier() : 1.0;
                const finalAmount = Math.floor(amount * xpMultiplier);

                this.exp += finalAmount;

                // Verificar se subiu de nível
                if (this.exp >= this.expToNext) {
                    this.levelUp();
                }

                this.emit('expGained', finalAmount, this.exp, this.expToNext);
            }

            levelUp() {
                this.level++;
                this.exp -= this.expToNext;
                this.expToNext = Math.floor(this.expToNext * this.expGrowthRate);

                // Curar um pouco ao subir de nível
                this.hp = Math.min(this.maxHp, this.hp + Math.floor(this.maxHp * 0.1));

                // Criar efeito visual de level up
                this.createLevelUpEffect();

                this.emit('levelUp', this.level);
            }
            
            createLevelUpEffect() {
                if (!this.levelUpParticles) {
                    this.levelUpParticles = [];
                }
                
                // Criar partículas douradas em círculo
                const particleCount = 20;
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i * Math.PI * 2) / particleCount;
                    const speed = 150 + Math.random() * 100;
                    const lifetime = 1500 + Math.random() * 500;
                    
                    const particle = {
                        x: this.x,
                        y: this.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 100, // Impulso para cima
                        size: 3 + Math.random() * 3,
                        color: `hsl(${45 + Math.random() * 30}, 90%, ${70 + Math.random() * 20}%)`,
                        alpha: 1.0,
                        lifetime: lifetime,
                        maxLifetime: lifetime,
                        createdAt: Date.now(),
                        type: 'levelUp'
                    };
                    
                    this.levelUpParticles.push(particle);
                }
                
                // Adicionar algumas estrelas especiais
                for (let i = 0; i < 5; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 20 + Math.random() * 30;
                    const particle = {
                        x: this.x + Math.cos(angle) * distance,
                        y: this.y + Math.sin(angle) * distance,
                        vx: 0,
                        vy: -50 - Math.random() * 50,
                        size: 4 + Math.random() * 4,
                        color: `hsl(${Math.random() * 60}, 100%, 85%)`,
                        alpha: 1.0,
                        lifetime: 2000,
                        maxLifetime: 2000,
                        createdAt: Date.now(),
                        type: 'star'
                    };
                    
                    this.levelUpParticles.push(particle);
                }
            }
            
            updateLevelUpParticles(deltaTime) {
                if (!this.levelUpParticles) return;
                
                const dt = deltaTime / 1000;
                const now = Date.now();
                
                this.levelUpParticles = this.levelUpParticles.filter(particle => {
                    // Atualizar posição
                    particle.x += particle.vx * dt;
                    particle.y += particle.vy * dt;
                    
                    // Aplicar gravidade leve
                    particle.vy += 50 * dt;
                    
                    // Aplicar fricção
                    particle.vx *= 0.98;
                    particle.vy *= 0.98;
                    
                    // Fade out baseado no tempo de vida
                    const age = now - particle.createdAt;
                    particle.alpha = Math.max(0, 1 - (age / particle.lifetime));
                    
                    // Remover se expirou
                    return age < particle.lifetime;
                });
            }
            
            renderLevelUpParticles(ctx) {
                if (!this.levelUpParticles) return;
                
                ctx.save();
                
                this.levelUpParticles.forEach(particle => {
                    ctx.globalAlpha = particle.alpha;
                    
                    if (particle.type === 'star') {
                        // Desenhar estrela
                        ctx.fillStyle = particle.color;
                        ctx.beginPath();
                        
                        const spikes = 5;
                        const outerRadius = particle.size;
                        const innerRadius = outerRadius * 0.4;
                        
                        for (let i = 0; i < spikes * 2; i++) {
                            const angle = (i * Math.PI) / spikes;
                            const radius = i % 2 === 0 ? outerRadius : innerRadius;
                            const x = particle.x + Math.cos(angle) * radius;
                            const y = particle.y + Math.sin(angle) * radius;
                            
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.closePath();
                        ctx.fill();
                        
                        // Brilho da estrela
                        const gradient = ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, outerRadius * 3
                        );
                        gradient.addColorStop(0, particle.color + '60');
                        gradient.addColorStop(1, particle.color + '00');
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, outerRadius * 3, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        // Partícula normal com brilho
                        const gradient = ctx.createRadialGradient(
                            particle.x, particle.y, 0,
                            particle.x, particle.y, particle.size * 3
                        );
                        gradient.addColorStop(0, particle.color);
                        gradient.addColorStop(0.5, particle.color + '80');
                        gradient.addColorStop(1, particle.color + '00');
                        
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size * 3, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Núcleo da partícula
                        ctx.fillStyle = particle.color;
                        ctx.beginPath();
                        ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                });
                
                ctx.restore();
            }

            // Calcular dano com chance de crítico
            calculateDamage() {
                let damage = this.damage;

                // Calcular crítico
                if (Math.random() < this.critChance) {
                    damage *= this.critMultiplier;
                    this.emit('critical');
                }

                return damage;
            }

            updateProjectiles(deltaTime, enemies, canvas) {
                const dt = deltaTime / 1000;
                const now = Date.now();

                this.projectiles = this.projectiles.filter(projectile => {
                    // Atualizar posição
                    projectile.x += projectile.vx * dt;
                    projectile.y += projectile.vy * dt;

                    // Verificar tempo de vida
                    if (now - projectile.createdAt > projectile.lifetime) {
                        return false;
                    }

                    // Verificar se saiu do canvas
                    if (projectile.x < 0 || projectile.x > canvas.width ||
                        projectile.y < 0 || projectile.y > canvas.height) {
                        return false;
                    }

                    // Verificar colisão com inimigos
                    for (let enemy of enemies) {
                        if (Collision.circleCircle(
                            projectile.x, projectile.y, projectile.size,
                            enemy.x, enemy.y, enemy.size
                        )) {
                            enemy.takeDamage(projectile.damage);

                            // Ganhar EXP por hit
                            if (enemy.hp <= 0) {
                                this.gainExp(enemy.expValue || 10);
                            }

                            this.emit('hit', enemy, projectile.damage);
                            return false; // Remove o projétil
                        }
                    }

                    return true;
                });
            }

            updateInvulnerability(deltaTime) {
                if (this.invulnerable) {
                    this.invulnerabilityTime += deltaTime;
                    if (this.invulnerabilityTime >= this.invulnerabilityDuration) {
                        this.invulnerable = false;
                        this.invulnerabilityTime = 0;
                    }
                }
            }

            takeDamage(amount) {
                if (this.invulnerable) return;

                // Aplicar defesa
                const damageReduction = this.defense / (this.defense + 100);
                const finalDamage = Math.max(1, Math.floor(amount * (1 - damageReduction)));

                this.hp = Math.max(0, this.hp - finalDamage);
                this.invulnerable = true;
                this.invulnerabilityTime = 0;

                this.emit('damaged', finalDamage, this.hp);
                this.playHitSound(); // Toca som de hit

                if (this.hp <= 0) {
                    this.emit('death');
                }
            }

            heal(amount) {
                this.hp = Math.min(this.maxHp, this.hp + amount);
                this.emit('healed', amount, this.hp);
            }

            constrainToCanvas(canvas) {
                // Apenas controlar horizontalmente, verticalmente é controlado pelas plataformas
                if (this.x - this.size < 0) {
                    this.x = this.size;
                }
                if (this.x + this.size > canvas.width) {
                    this.x = canvas.width - this.size;
                }
            }

            // Métodos de input para compatibilidade
            setInput(key, value) {
                if (this.input.hasOwnProperty(key)) {
                    this.input[key] = Boolean(value);
                }
            }

            // Mobile controls
            setMobileControls(controls) {
                // Limpar primeiro para evitar estados persistentes
                if (controls.hasOwnProperty('left') || controls.hasOwnProperty('right')) {
                    this.mobileControls.left = false;
                    this.mobileControls.right = false;
                }

                Object.assign(this.mobileControls, controls);
            }

            // Método para limpar completamente os controles
            clearAllInputs() {
                // Limpar inputs de teclado
                this.input = {
                    left: false,
                    right: false,
                    jump: false
                };

                // Limpar controles mobile
                this.resetMobileControls();

                // Limpar velocidade também para parar movimento imediatamente
                this.vx = 0;
            }

            // Método para desabilitar completamente controles mobile (usado em desktop)
            disableMobileControls() {
                this.mobileControls = {
                    left: false,
                    right: false,
                    jump: false,
                    shooting: false,
                    aimX: 0,
                    aimY: 0
                };
                console.log('Mobile controls permanently disabled (desktop mode)');
            }

            // Sistema de estatísticas e equipamentos
            updateStats() {
                // Recalcular estatísticas base do level
                this.recalculateBaseStats();

                // Aplicar efeitos dos equipamentos equipados
                if (this.equippedEquipment.hats) {
                    this.applyEquipmentEffects('hats', this.equippedEquipment.hats);
                }
                if (this.equippedEquipment.staffs) {
                    this.applyEquipmentEffects('staffs', this.equippedEquipment.staffs);
                }

                // Garantir que HP não exceda maxHp
                if (this.hp > this.maxHp) {
                    this.hp = this.maxHp;
                }

                console.log('Stats atualizadas:', {
                    level: this.level,
                    hp: this.hp,
                    maxHp: this.maxHp,
                    damage: this.damage,
                    defense: this.defense,
                    speed: this.speed,
                    equippedHat: this.equippedEquipment.hats,
                    equippedStaff: this.equippedEquipment.staffs
                });
            }

            recalculateBaseStats() {
                // Stats base por nível
                const baseStats = this.getBaseStats();

                this.maxHp = baseStats.maxHp;
                this.damage = baseStats.damage;
                this.defense = baseStats.defense;
                this.speed = baseStats.speed;
                this.attackSpeed = baseStats.attackSpeed;
                this.critChance = baseStats.critChance;
            }

            getBaseStats() {
                // Estatísticas base que crescem com o level
                return {
                    maxHp: 100 + (this.level - 1) * 20,
                    damage: 15 + (this.level - 1) * 3,
                    defense: (this.level - 1) * 2,
                    speed: 200 + (this.level - 1) * 5,
                    attackSpeed: 3.0 + (this.level - 1) * 0.1,
                    critChance: 0.05 + (this.level - 1) * 0.01
                };
            }

            applyEquipmentEffects(type, itemId) {
                // Esta função será chamada pelo equipmentManager
                // quando um equipamento for equipado
                console.log(`Aplicando efeitos do equipamento ${type}:${itemId}`);
            }

            render(ctx) {
                // Desenhar corpo do jogador
                this.renderBody(ctx);

                // Desenhar projéteis
                this.renderProjectiles(ctx);

                // Desenhar raios do Thunderbolt
                this.renderLightning(ctx);
                
                // Desenhar partículas mágicas
                this.renderCastingParticles(ctx);
                
                // Desenhar partículas de level up
                this.renderLevelUpParticles(ctx);
            }

            renderBody(ctx) {
                const alpha = this.invulnerable ? 0.5 : 1.0;
                ctx.globalAlpha = alpha;

                // Calcular posição e tamanho de renderização
                const renderSize = this.spriteSize;
                const renderX = this.x - renderSize / 2;
                const renderY = this.y - renderSize / 2;

                // Salvar contexto para flip horizontal
                ctx.save();

                // Aplicar flip horizontal se necessário
                if (!this.facingRight) {
                    ctx.scale(-1, 1);
                    ctx.translate(-this.x * 2, 0);
                }

                // Renderizar sprite base do mago
                if (false) { // Desabilitado temporariamente para mostrar sempre o desenho detalhado
                    ctx.drawImage(this.sprites.base, renderX, renderY, renderSize, renderSize);
                } else {
                    // Desenho detalhado do mago
                    this.drawDetailedWizard(ctx);
                }

                // Renderizar chapéu equipado (acima da cabeça)
                if (this.sprites.hat && this.sprites.hat.complete) {
                    // Posicionar chapéu no topo da cabeça com tamanho menor
                    const hatSize = renderSize * 0.6; // 60% do tamanho do personagem
                    const hatX = renderX + (renderSize - hatSize) / 2; // Centralizar
                    const hatY = renderY - hatSize * 0.3; // Posicionar acima da cabeça
                    ctx.drawImage(this.sprites.hat, hatX, hatY, hatSize, hatSize);
                }

                // Renderizar cajado equipado (ao lado do mago)
                if (this.sprites.staff && this.sprites.staff.complete) {
                    // Posicionar cajado ao lado do mago com tamanho menor
                    const staffSize = renderSize * 0.7; // 70% do tamanho do personagem
                    const staffX = renderX - staffSize * 0.4; // Ao lado esquerdo
                    const staffY = renderY + renderSize * 0.1; // Ligeiramente abaixo do centro
                    ctx.drawImage(this.sprites.staff, staffX, staffY, staffSize, staffSize);
                }

                // Restaurar contexto
                ctx.restore();

                // Reset alpha
                ctx.globalAlpha = 1.0;
            }

            renderProjectiles(ctx) {
                for (let projectile of this.projectiles) {
                    this.renderMagicalProjectile(ctx, projectile);
                }
            }
            
            // Método para renderizar projéteis mágicos com efeitos
            renderMagicalProjectile(ctx, projectile) {
                const time = Date.now() * 0.005;
                const age = Date.now() - projectile.createdAt;
                const lifePercent = age / projectile.lifetime;
                
                // Efeito de trilha/rastro
                const trailLength = 5;
                for (let i = 0; i < trailLength; i++) {
                    const trailPercent = i / trailLength;
                    const trailX = projectile.x - projectile.vx * trailPercent * 0.02;
                    const trailY = projectile.y - projectile.vy * trailPercent * 0.02;
                    const trailSize = projectile.size * (1 - trailPercent * 0.5);
                    const trailAlpha = (1 - trailPercent) * (1 - lifePercent * 0.5);
                    
                    ctx.globalAlpha = trailAlpha * 0.6;
                    ctx.fillStyle = projectile.color;
                    ctx.beginPath();
                    ctx.arc(trailX, trailY, trailSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Projétil principal
                ctx.globalAlpha = 1 - lifePercent * 0.3;
                
                // Core do projétil
                ctx.fillStyle = projectile.color;
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, projectile.size, 0, Math.PI * 2);
                ctx.fill();
                
                // Brilho interno
                ctx.fillStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, projectile.size * 0.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Aura externa pulsante
                const pulseSize = projectile.size * (1.5 + Math.sin(time * 3 + projectile.x * 0.01) * 0.3);
                const auraAlpha = (0.3 + Math.sin(time * 2) * 0.2) * (1 - lifePercent);
                
                ctx.globalAlpha = auraAlpha;
                ctx.fillStyle = projectile.color;
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, pulseSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Partículas orbitais
                for (let i = 0; i < 4; i++) {
                    const angle = time + i * Math.PI / 2 + projectile.x * 0.01;
                    const orbitRadius = projectile.size * 1.2;
                    const orbX = projectile.x + Math.cos(angle) * orbitRadius;
                    const orbY = projectile.y + Math.sin(angle) * orbitRadius;
                    
                    ctx.globalAlpha = 0.8 * (1 - lifePercent);
                    ctx.fillStyle = '#66ffff';
                    ctx.beginPath();
                    ctx.arc(orbX, orbY, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Reset alpha
                ctx.globalAlpha = 1.0;
            }

            renderLightning(ctx) {
                if (!this.lightningStrikes) return;

                const now = Date.now();

                for (let lightning of this.lightningStrikes) {
                    const age = now - lightning.createdAt;

                    // Renderizar apenas durante a duração visual
                    if (age > lightning.duration) continue;

                    const isWarningPhase = age < lightning.warningDuration;

                    if (isWarningPhase) {
                        // Fase de aviso - círculo piscante vermelho
                        const opacity = 0.3 + 0.3 * Math.sin(age * 0.02); // Piscando
                        ctx.globalAlpha = opacity;
                        ctx.fillStyle = '#ff4444';
                        ctx.beginPath();
                        ctx.arc(lightning.x, lightning.y, lightning.size, 0, Math.PI * 2);
                        ctx.fill();

                        // Borda de aviso
                        ctx.globalAlpha = 0.8;
                        ctx.strokeStyle = '#ff0000';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    } else {
                        // Fase do raio - efeito de raio brilhante
                        const strikeAge = age - lightning.warningDuration;
                        const strikeProgress = strikeAge / lightning.visualDuration;

                        if (strikeProgress <= 1) {
                            // Desenhar o raio principal
                            ctx.globalAlpha = 1 - strikeProgress;

                            // Raio principal (amarelo brilhante)
                            ctx.fillStyle = '#ffff00';
                            ctx.beginPath();
                            ctx.arc(lightning.x, lightning.y, lightning.size * (1 + strikeProgress * 0.5), 0, Math.PI * 2);
                            ctx.fill();

                            // Núcleo brilhante (branco)
                            ctx.fillStyle = '#ffffff';
                            ctx.beginPath();
                            ctx.arc(lightning.x, lightning.y, lightning.size * 0.5 * (1 - strikeProgress), 0, Math.PI * 2);
                            ctx.fill();

                            // Efeito de brilho externo
                            ctx.globalAlpha = (1 - strikeProgress) * 0.3;
                            ctx.fillStyle = '#ffff88';
                            ctx.beginPath();
                            ctx.arc(lightning.x, lightning.y, lightning.size * (2 + strikeProgress), 0, Math.PI * 2);
                            ctx.fill();

                            // Raios menores ao redor
                            ctx.globalAlpha = 1 - strikeProgress;
                            ctx.strokeStyle = '#ffff00';
                            ctx.lineWidth = 3;

                            for (let i = 0; i < 8; i++) {
                                const angle = (i / 8) * Math.PI * 2;
                                const length = lightning.size * (1.5 + Math.random() * 0.5);
                                const startX = lightning.x + Math.cos(angle) * lightning.size * 0.5;
                                const startY = lightning.y + Math.sin(angle) * lightning.size * 0.5;
                                const endX = lightning.x + Math.cos(angle) * length;
                                const endY = lightning.y + Math.sin(angle) * length;

                                ctx.beginPath();
                                ctx.moveTo(startX, startY);
                                ctx.lineTo(endX, endY);
                                ctx.stroke();
                            }
                        }
                    }
                }

                // Resetar alpha
                ctx.globalAlpha = 1.0;
            }

            // Coletar Soul Orb
            collectSoulOrb(value = 1) {
                this.soulOrbs += value;
                this.score += value * 5; // 5 pontos por soul orb
                this.emit('soulOrbCollected', this.soulOrbs);
                
                // Salvar imediatamente quando Soul Orbs são coletados
                if (window.game && window.game.saveGame) {
                    window.game.saveGame();
                }
            }

            // Métodos para atualizar estatísticas e pontuação
            addKill(enemy) {
                this.enemiesKilled++;
                this.score += enemy.points || 10;

                // Bônus por tipo de inimigo
                const typeBonus = {
                    'basic': 10,
                    'fast': 15,
                    'heavy': 25,
                    'sniper': 20
                };
                this.score += typeBonus[enemy.type] || 10;

                // Processar efeitos OnKill (como Fragmentation)
                this.processOnKillEffects(enemy);
            }

            addDamage(damage, isCritical = false) {
                this.totalDamageDealt += damage;
                this.score += Math.floor(damage / 10); // 1 ponto a cada 10 de dano

                if (isCritical) {
                    this.criticalHits++;
                    this.score += 25; // Bônus por crítico
                }
            }

            addShot(hit = false) {
                this.shotsFired++;
                if (hit) {
                    this.shotsHit++;
                    this.score += 2; // Pontos por acerto
                }
            }

            updateSurvivalTime(deltaTime) {
                this.survivalTime += deltaTime;
                // 1 ponto por segundo sobrevivido
                this.score += Math.floor(deltaTime / 1000);
            }

            // Obter estatísticas para o ranking
            getStats() {
                const accuracy = this.shotsFired > 0 ? (this.shotsHit / this.shotsFired) * 100 : 0;

                return {
                    playerName: this.playerName,
                    score: this.score,
                    level: this.level,
                    enemiesKilled: this.enemiesKilled,
                    survivalTime: this.survivalTime,
                    accuracy: Math.round(accuracy * 100) / 100,
                    criticalHits: this.criticalHits,
                    totalDamageDealt: this.totalDamageDealt,
                    soulOrbs: this.soulOrbs,
                    build: this.getBuild(), // Adicionar build ao placar
                    timestamp: Date.now()
                };
            }

            // Definir nome do jogador
            setPlayerName(name) {
                this.playerName = name || 'Player';
            }

            // Adicionar sons ao player para tiro e hit
            playShotSound() {
                // Verificar se há acesso ao audioSystem através do game
                if (window.game && window.game.audioSystem) {
                    window.game.audioSystem.playSound('shot');
                }
            }

            playHitSound() {
                if (window.game && window.game.audioSystem) {
                    window.game.audioSystem.playSound('hit');
                }
            }

            // Adicionar carta escolhida à build
            addSelectedCard(card) {
                if (!card) return;

                this.selectedCards.push({
                    id: card.id,
                    name: card.name,
                    rarity: card.rarity,
                    description: card.description,
                    selectedAt: Date.now()
                });

                console.log('Carta adicionada à build:', card.name, 'Total de cartas:', this.selectedCards.length);
            }

            // Obter build (cartas escolhidas)
            getBuild() {
                return [...this.selectedCards]; // Retorna cópia
            }

            // Métodos para atualizar cartas (ex: fragmentação)
            updateCards(deltaTime) {
                const now = Date.now();

                // Atualizar efeitos de cartas ativas
                for (let card of this.selectedCards) {
                    if (card.id === 'fragmentation' && card.active) {
                        // Exemplo: fragmentação causa dano ao longo do tempo
                        if (now - card.lastApplied >= 1000) {
                            this.applyFragmentationDamage();
                            card.lastApplied = now;
                        }
                    }
                }
            }

            applyFragmentationDamage() {
                const damage = 5 + Math.floor(this.level * 0.5);
                this.totalDamageDealt += damage;
                this.score += Math.floor(damage / 10);

                console.log('Dano de fragmentação aplicado:', damage);
            }

            // Método para resetar controles mobile
            resetMobileControls() {
                this.mobileControls = {
                    left: false,
                    right: false,
                    jump: false,
                    shooting: false,
                    aimX: 0,
                    aimY: 0
                };
            }

            // Método para forçar parada do movimento
            stopMovement() {
                console.log('Forcing movement stop...');
                this.vx = 0;
                this.input.left = false;
                this.input.right = false;
                this.mobileControls.left = false;
                this.mobileControls.right = false;
                console.log('Movement stopped');
            }

            // Método para encontrar o inimigo mais próximo (usado em mobile)
            findNearestEnemy(enemies) {
                if (!enemies || enemies.length === 0) return null;

                let nearestEnemy = null;
                let nearestDistance = Infinity;
                const maxTargetRange = 400; // Alcance máximo para mira automática

                for (let enemy of enemies) {
                    // Ignorar inimigos mortos ou em animação de morte
                    if (enemy.hp <= 0 || enemy.deathAnimation) continue;

                    const distance = Math.sqrt(
                        Math.pow(enemy.x - this.x, 2) +
                        Math.pow(enemy.y - this.y, 2)
                    );

                    // Só considerar inimigos dentro do alcance
                    if (distance < nearestDistance && distance <= maxTargetRange) {
                        nearestDistance = distance;
                        nearestEnemy = enemy;
                    }
                }

                return nearestEnemy;
            }

            // Método para processar efeitos das cartas
            updateCardEffects(deltaTime, enemies, canvas) {
                const now = Date.now();

                // Processar efeito de raio (Thunderbolt)
                if (this.lightningEffect && this.lightningEffect.enabled) {
                    if (now - this.lightningEffect.lastCast >= this.lightningEffect.interval) {
                        this.castLightning(enemies, canvas);
                        this.lightningEffect.lastCast = now;
                    }
                }

                // Aqui podem ser adicionados outros efeitos de cartas no futuro
                // como fragmentação, etc.
            }

            // Método para lançar raios do Thunderbolt
            castLightning(enemies, canvas) {
                if (!this.lightningEffect || !enemies || enemies.length === 0) return;

                const lightningStrikes = [];
                const strikeCount = this.lightningEffect.count || 2;
                const damage = this.lightningEffect.damage || (this.damage * 2);

                // Priorizar inimigos próximos ao jogador
                const sortedEnemies = enemies
                    .filter(enemy => enemy.hp > 0) // Apenas inimigos vivos
                    .sort((a, b) => {
                        const distA = Math.sqrt(Math.pow(a.x - this.x, 2) + Math.pow(a.y - this.y, 2));
                        const distB = Math.sqrt(Math.pow(b.x - this.x, 2) + Math.pow(b.y - this.y, 2));
                        return distA - distB;
                    });

                // Criar raios
                for (let i = 0; i < strikeCount; i++) {
                    let targetX, targetY;

                    if (sortedEnemies.length > 0 && i < sortedEnemies.length) {
                        // Mirar em inimigos próximos primeiro
                        const enemy = sortedEnemies[i];
                        targetX = enemy.x + (Math.random() - 0.5) * 40; // Pequena variação
                        targetY = enemy.y + (Math.random() - 0.5) * 40;
                    } else {
                        // Posições aleatórias se não há inimigos suficientes
                        targetX = Math.random() * canvas.width;
                        targetY = Math.random() * canvas.height;
                    }

                    const lightning = {
                        x: targetX,
                        y: targetY,
                        damage: damage,
                        size: 40, // Raio de dano
                        createdAt: Date.now(),
                        duration: 500, // 0.5 segundos
                        visualDuration: 200, // Efeito visual mais rápido
                        warningDuration: 300 // Tempo de aviso antes do dano
                    };

                    lightningStrikes.push(lightning);
                }

                // Armazenar raios para renderização e dano
                this.lightningStrikes = this.lightningStrikes || [];
                this.lightningStrikes.push(...lightningStrikes);

                // Processar dano após o tempo de aviso
                lightningStrikes.forEach(lightning => {
                    setTimeout(() => {
                        this.dealLightningDamage(lightning, enemies);
                    }, lightning.warningDuration);
                });

                // Limpar raios antigos
                this.cleanupOldLightning();
            }

            // Método para causar dano dos raios
            dealLightningDamage(lightning, enemies) {
                if (!enemies) return;

                enemies.forEach(enemy => {
                    if (enemy.hp <= 0) return; // Pular inimigos mortos

                    const distance = Math.sqrt(
                        Math.pow(enemy.x - lightning.x, 2) +
                        Math.pow(enemy.y - lightning.y, 2)
                    );

                    if (distance <= lightning.size) {
                        enemy.takeDamage(lightning.damage);

                        // Efeitos visuais no inimigo atingido
                        if (enemy.flashColor) {
                            enemy.flashColor = '#ffff00'; // Amarelo para raio
                            enemy.flashTime = 300;
                        }

                        // Estatísticas
                        this.addDamage(lightning.damage);
                        if (enemy.hp <= 0) {
                            this.addKill(enemy);
                        }
                    }
                });
            }

            // Método para limpar raios antigos
            cleanupOldLightning() {
                if (!this.lightningStrikes) return;

                const now = Date.now();
                this.lightningStrikes = this.lightningStrikes.filter(lightning => {
                    return (now - lightning.createdAt) < lightning.duration;
                });
            }

            // Processar efeitos que ativam quando um inimigo é morto
            processOnKillEffects(enemy) {
                if (!this.onKillEffects || this.onKillEffects.length === 0) return;

                for (let effect of this.onKillEffects) {
                    switch (effect.type) {
                        case 'fragmentation':
                            this.createFragmentationProjectiles(enemy, effect);
                            break;
                        // Outros efeitos OnKill podem ser adicionados aqui
                    }
                }
            }

            // Criar projéteis de fragmentação quando um inimigo morre
            createFragmentationProjectiles(enemy, effect) {
                const projectileCount = effect.projectiles || 2;
                const projectileDamage = effect.damage || (this.damage * 0.3);

                console.log(`Criando ${projectileCount} projéteis de fragmentação em`, enemy.x, enemy.y);
                console.log('Array de projéteis antes:', this.projectiles.length);

                for (let i = 0; i < projectileCount; i++) {
                    // Ângulo aleatório para cada projétil
                    const angle = (Math.PI * 2 * i / projectileCount) + (Math.random() - 0.5) * 0.5;

                    const projectile = {
                        x: enemy.x,
                        y: enemy.y,
                        vx: Math.cos(angle) * this.projectileSpeed * 0.8, // Velocidade um pouco menor
                        vy: Math.sin(angle) * this.projectileSpeed * 0.8,
                        size: this.projectileSize,
                        damage: projectileDamage,
                        lifetime: 2000, // 2 segundos
                        createdAt: Date.now(),
                        color: '#ff8800', // Cor laranja para distinguir
                        isFragmentation: true
                    };

                    this.projectiles.push(projectile);
                    console.log('Projétil de fragmentação adicionado:', projectile);
                }

                console.log('Array de projéteis depois:', this.projectiles.length);

                // Som de fragmentação (se disponível)
                if (window.game && window.game.audioSystem) {
                    window.game.audioSystem.playSound('fragmentation');
                }
            }

            // Sistema de Sprites e Renderização Visual
            loadSprites() {
                // Usar pré-carregador se disponível, senão carregar diretamente
                if (typeof imagePreloader !== 'undefined') {
                    this.sprites.base = CanvasUtils.getSvgImage('mago-sprite');
                    if (!this.sprites.base) {
                        // Fallback se não estiver pré-carregado
                        this.sprites.base = new Image();
                        this.sprites.base = CanvasUtils.getSvgImage('mago-sprite');
                    }
                } else {
                    this.sprites.base = new Image();
                    this.sprites.base = CanvasUtils.getSvgImage('mago-sprite');
                }

                console.log('Sprite base do mago configurado');
            }

            // Carregar sprite do chapéu equipado
            loadHatSprite() {
                if (!this.equippedEquipment.hats) {
                    this.sprites.hat = null;
                    console.log('Nenhum chapéu equipado');
                    return;
                }

                // Verificar se EQUIPMENT_DEFINITIONS está disponível
                if (typeof EQUIPMENT_DEFINITIONS === 'undefined') {
                    console.warn('EQUIPMENT_DEFINITIONS não está disponível. Tentando novamente em 1 segundo...');
                    setTimeout(() => this.loadHatSprite(), 1000);
                    return;
                }

                const hatData = EQUIPMENT_DEFINITIONS[this.equippedEquipment.hats];
                if (hatData && hatData.image) {
                    // Usar SVG em vez de imagem
                    this.sprites.hat = CanvasUtils.getSvgImage(hatData.image);
                    console.log('Sprite do chapéu configurado:', hatData.name, 'SVG ID:', hatData.image);
                } else {
                    console.error('Dados do chapéu não encontrados:', this.equippedEquipment.hats);
                }
            }

            // Carregar sprite do cajado equipado
            loadStaffSprite() {
                if (!this.equippedEquipment.staffs) {
                    this.sprites.staff = null;
                    console.log('Nenhum cajado equipado');
                    return;
                }

                // Verificar se EQUIPMENT_DEFINITIONS está disponível
                if (typeof EQUIPMENT_DEFINITIONS === 'undefined') {
                    console.warn('EQUIPMENT_DEFINITIONS não está disponível. Tentando novamente em 1 segundo...');
                    setTimeout(() => this.loadStaffSprite(), 1000);
                    return;
                }

                const staffData = EQUIPMENT_DEFINITIONS[this.equippedEquipment.staffs];
                if (staffData && staffData.image) {
                    // Usar SVG em vez de imagem
                    this.sprites.staff = CanvasUtils.getSvgImage(staffData.image);
                    console.log('Sprite do cajado configurado:', staffData.name, 'SVG ID:', staffData.image);
                } else {
                    console.error('Dados do cajado não encontrados:', this.equippedEquipment.staffs);
                }
            }

            // Atualizar sprites quando equipamentos mudarem
            updateEquipmentSprites() {
                this.loadHatSprite();
                this.loadStaffSprite();
            }

            // Desenhar mago detalhado proceduralmente
            drawDetailedWizard(ctx) {
                const time = Date.now() * 0.003;
                const renderSize = this.spriteSize;
                const centerX = this.x;
                const centerY = this.y;
                
                // Salvar contexto
                ctx.save();
                
                // Aplicar transparência se invulnerável
                if (this.invulnerable) {
                    ctx.globalAlpha = 0.5;
                }

                // Corpo principal (robes do mago)
                const bodyColor = '#4a4a8a'; // Azul escuro
                const robeGradient = ctx.createLinearGradient(
                    centerX - renderSize/3, centerY - renderSize/4,
                    centerX + renderSize/3, centerY + renderSize/2
                );
                robeGradient.addColorStop(0, '#6666aa');
                robeGradient.addColorStop(0.5, bodyColor);
                robeGradient.addColorStop(1, '#333366');
                
                ctx.fillStyle = robeGradient;
                ctx.beginPath();
                ctx.ellipse(centerX, centerY, renderSize/3, renderSize/2, 0, 0, Math.PI * 2);
                ctx.fill();

                // Detalhes da robe (bordas douradas)
                ctx.strokeStyle = '#ffd700';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Cabeça (tom de pele)
                const headRadius = renderSize * 0.15;
                ctx.fillStyle = '#ffdbac';
                ctx.beginPath();
                ctx.arc(centerX, centerY - renderSize * 0.3, headRadius, 0, Math.PI * 2);
                ctx.fill();

                // Contorno da cabeça
                ctx.strokeStyle = '#d4af8c';
                ctx.lineWidth = 1;
                ctx.stroke();

                // Barba (branca/grisalha)
                ctx.fillStyle = '#e6e6e6';
                ctx.beginPath();
                ctx.ellipse(centerX, centerY - renderSize * 0.2, headRadius * 0.8, headRadius * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Olhos
                const eyeY = centerY - renderSize * 0.35;
                const eyeSize = 2;
                ctx.fillStyle = '#000000';
                ctx.beginPath();
                ctx.arc(centerX - 4, eyeY, eyeSize, 0, Math.PI * 2);
                ctx.arc(centerX + 4, eyeY, eyeSize, 0, Math.PI * 2);
                ctx.fill();

                // Brilho nos olhos (efeito mágico)
                ctx.fillStyle = '#66ccff';
                ctx.beginPath();
                ctx.arc(centerX - 4, eyeY, 1, 0, Math.PI * 2);
                ctx.arc(centerX + 4, eyeY, 1, 0, Math.PI * 2);
                ctx.fill();

                // Braços
                const armLength = renderSize * 0.4;
                const armY = centerY - renderSize * 0.1;
                
                // Braço esquerdo
                ctx.strokeStyle = bodyColor;
                ctx.lineWidth = 6;
                ctx.beginPath();
                ctx.moveTo(centerX - renderSize/4, armY);
                ctx.lineTo(centerX - renderSize/2, armY + renderSize/6);
                ctx.stroke();

                // Braço direito (segurando cajado imaginário)
                ctx.beginPath();
                ctx.moveTo(centerX + renderSize/4, armY);
                ctx.lineTo(centerX + renderSize/2, armY - renderSize/8);
                ctx.stroke();

                // Mãos
                ctx.fillStyle = '#ffdbac';
                ctx.beginPath();
                ctx.arc(centerX - renderSize/2, armY + renderSize/6, 4, 0, Math.PI * 2);
                ctx.arc(centerX + renderSize/2, armY - renderSize/8, 4, 0, Math.PI * 2);
                ctx.fill();

                // Aura mágica ao redor do mago
                const auraRadius = renderSize * (0.8 + Math.sin(time * 2) * 0.2);
                const auraGradient = ctx.createRadialGradient(
                    centerX, centerY, renderSize/3,
                    centerX, centerY, auraRadius
                );
                auraGradient.addColorStop(0, 'rgba(102, 204, 255, 0)');
                auraGradient.addColorStop(0.7, 'rgba(102, 204, 255, 0.1)');
                auraGradient.addColorStop(1, 'rgba(102, 204, 255, 0.3)');
                
                ctx.fillStyle = auraGradient;
                ctx.beginPath();
                ctx.arc(centerX, centerY, auraRadius, 0, Math.PI * 2);
                ctx.fill();

                // Partículas mágicas flutuando
                for (let i = 0; i < 6; i++) {
                    const angle = time + i * Math.PI / 3;
                    const radius = renderSize * (0.6 + Math.sin(time * 1.5 + i) * 0.2);
                    const particleX = centerX + Math.cos(angle) * radius;
                    const particleY = centerY + Math.sin(angle) * radius * 0.5;
                    
                    const particleSize = 2 + Math.sin(time * 3 + i * 0.5) * 1;
                    
                    ctx.fillStyle = `hsl(${190 + Math.sin(time + i) * 30}, 80%, 70%)`;
                    ctx.globalAlpha = 0.6 + Math.sin(time * 2 + i) * 0.3;
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Estrelas mágicas pequenas
                ctx.globalAlpha = 0.8;
                for (let i = 0; i < 3; i++) {
                    const angle = time * 0.5 + i * Math.PI * 2 / 3;
                    const starRadius = renderSize * 0.9;
                    const starX = centerX + Math.cos(angle) * starRadius;
                    const starY = centerY + Math.sin(angle) * starRadius * 0.3;
                    
                    // Desenhar estrela de 5 pontas
                    this.drawStar(ctx, starX, starY, 3, '#ffff66');
                }

                // Restaurar contexto
                ctx.restore();
            }

            // Função auxiliar para desenhar estrela
            drawStar(ctx, x, y, size, color) {
                ctx.fillStyle = color;
                ctx.beginPath();
                
                for (let i = 0; i < 5; i++) {
                    const angle = (i * Math.PI * 2) / 5 - Math.PI / 2;
                    const outerRadius = size;
                    const innerRadius = size * 0.4;
                    
                    const outerX = x + Math.cos(angle) * outerRadius;
                    const outerY = y + Math.sin(angle) * outerRadius;
                    
                    if (i === 0) {
                        ctx.moveTo(outerX, outerY);
                    } else {
                        ctx.lineTo(outerX, outerY);
                    }
                    
                    const innerAngle = angle + Math.PI / 5;
                    const innerX = x + Math.cos(innerAngle) * innerRadius;
                    const innerY = y + Math.sin(innerAngle) * innerRadius;
                    ctx.lineTo(innerX, innerY);
                }
                
                ctx.closePath();
                ctx.fill();
            }
        }
    </script>
    <!-- Enemy Scripts -->
    <script>
        // enemies.js - Sistema de inimigos voadores

        class Enemy extends EventEmitter {
            constructor(x, y, type = 'basic') {
                super();

                this.x = x;
                this.y = y;
                this.vx = 0;
                this.vy = 0;
                this.type = type;

                // Estados de movimento específicos para sidescroller
                this.state = 'descending'; // descending, following, attacking
                this.targetHeight = 0; // 70% da altura da tela
                this.followDelay = 100; // delay suave para seguir o jogador

                // Configurações baseadas no tipo
                this.setupByType(type);

                // Estados
                this.hp = this.maxHp;
                this.lastAttackTime = 0;
                this.target = null;
                this.stateTime = 0;
                this.expValue = this.points; // EXP que dá quando morto

                // Projéteis do inimigo
                this.projectiles = [];

                // Visual
                this.animationTime = 0;
                this.deathAnimation = false;
                this.deathTime = 0;
            }

            setupByType(type) {
                const types = {
                    basic: {
                        maxHp: 25,
                        speed: 80,
                        damage: 10,
                        attackSpeed: 1.2,
                        size: 12,
                        color: '#ff6666',
                        points: 15,
                        projectileSpeed: 200,
                        attackRange: 300
                    },
                    fast: {
                        maxHp: 15,
                        speed: 120,
                        damage: 8,
                        attackSpeed: 1.8,
                        size: 10,
                        color: '#ffff66',
                        points: 20,
                        projectileSpeed: 250,
                        attackRange: 250
                    },
                    heavy: {
                        maxHp: 60,
                        speed: 50,
                        damage: 20,
                        attackSpeed: 0.8,
                        size: 18,
                        color: '#ff6600',
                        points: 35,
                        projectileSpeed: 150,
                        attackRange: 350
                    },
                    sniper: {
                        maxHp: 30,
                        speed: 60,
                        damage: 25,
                        attackSpeed: 0.6,
                        size: 14,
                        color: '#ff66ff',
                        points: 30,
                        projectileSpeed: 400,
                        attackRange: 400
                    }
                };

                const config = types[type] || types.basic;
                Object.assign(this, config);
            }

            update(deltaTime, player, canvas) {
                if (this.deathAnimation) {
                    this.updateDeathAnimation(deltaTime);
                    return;
                }

                this.target = player;
                this.targetHeight = canvas.height * 0.7; // 70% da altura

                this.updateMovement(deltaTime, canvas);
                this.updateCombat(deltaTime, canvas);
                this.updateProjectiles(deltaTime, canvas);
                this.animationTime += deltaTime;
                this.stateTime += deltaTime;
            }

            updateMovement(deltaTime, canvas) {
                const dt = deltaTime / 1000;

                if (this.state === 'descending') {
                    // Fase 1: Descer verticalmente até 70% da altura da tela
                    this.vy = this.speed * 0.8; // velocidade de descida
                    this.vx = 0; // sem movimento horizontal

                    // Verificar se atingiu 70% da altura
                    if (this.y >= this.targetHeight) {
                        this.state = 'following';
                        this.vy = 0;
                    }
                } else if (this.state === 'following') {
                    // Fase 2: Seguir o jogador mas manter uma distância mínima
                    if (!this.target) return;

                    const dx = this.target.x - this.x;
                    const dy = this.target.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // Distância mínima que o inimigo deve manter do player (aumentada)
                    const minDistance = 120; // pixels de distância mínima (dobrou de 60 para 120)
                    const maxDistance = 250; // distância máxima antes de se aproximar
                    const idealDistance = 180; // distância ideal para ficar orbitando

                    if (distance > 0) {
                        if (distance > maxDistance) {
                            // Muito longe - se aproximar
                            const followStrength = 0.6; // reduzido para movimento mais suave
                            const dirX = (dx / distance) * followStrength;
                            const dirY = (dy / distance) * followStrength;

                            const speedMultiplier = Math.min(1.5, distance / 150);
                            const moveSpeed = this.speed * speedMultiplier;

                            this.vx = dirX * moveSpeed;
                            this.vy = dirY * moveSpeed;
                        } else if (distance < minDistance) {
                            // Muito perto - se afastar mais agressivamente
                            const dirX = -(dx / distance) * 0.8; // direção oposta, mais forte
                            const dirY = -(dy / distance) * 0.8;

                            this.vx = dirX * this.speed * 1.2; // velocidade aumentada para se afastar
                            this.vy = dirY * this.speed * 1.2;
                        } else {
                            // Na distância ideal - movimento orbital/lateral mais pronunciado
                            const angle = Math.atan2(dy, dx);
                            const orbitalAngle = angle + Math.PI * 0.5; // perpendicular ao player

                            // Movimento orbital mais pronunciado
                            const orbitalSpeed = this.speed * 0.4;
                            this.vx = Math.cos(orbitalAngle + this.animationTime * 0.002) * orbitalSpeed;
                            this.vy = Math.sin(orbitalAngle + this.animationTime * 0.002) * orbitalSpeed * 0.3;

                            // Manter distância ideal
                            const distanceFromIdeal = distance - idealDistance;
                            if (Math.abs(distanceFromIdeal) > 20) {
                                const correctionStrength = 0.15;
                                const correctionDir = distanceFromIdeal > 0 ? -1 : 1;
                                this.vx += (dx / distance) * this.speed * correctionStrength * correctionDir;
                                this.vy += (dy / distance) * this.speed * correctionStrength * correctionDir;
                            }
                        }

                        // Adicionar pequena variação no movimento para parecer mais orgânico
                        if (this.animationTime % 3000 < 100) { // menos frequente
                            this.vx += (Math.random() - 0.5) * 40; // variação reduzida
                            this.vy += (Math.random() - 0.5) * 30;
                        }
                    }
                }

                // Aplicar velocidade
                this.x += this.vx * dt;
                this.y += this.vy * dt;

                // Manter dentro do canvas
                const margin = this.size;
                this.x = Math.max(margin, Math.min(canvas.width - margin, this.x));

                // Não permitir subir acima de 70% quando em following
                if (this.state === 'following') {
                    this.y = Math.max(this.targetHeight, this.y);
                }

                this.y = Math.max(margin, Math.min(canvas.height - margin, this.y));
            }

            updateCombat(deltaTime, canvas) {
                if (!this.target || this.state === 'descending') return;

                const distance = Math.sqrt((this.x - this.target.x) ** 2 + (this.y - this.target.y) ** 2);
                const now = Date.now();
                const attackInterval = 1000 / this.attackSpeed;

                // Só ataca quando está seguindo o jogador
                if (this.state === 'following' && now - this.lastAttackTime >= attackInterval) {
                    if (distance <= this.attackRange) {
                        this.shootAt(this.target);
                        this.lastAttackTime = now;
                    }
                }
            }

            updateProjectiles(deltaTime, canvas) {
                const dt = deltaTime / 1000;
                const now = Date.now();

                this.projectiles = this.projectiles.filter(projectile => {
                    // Atualizar posição
                    projectile.x += projectile.vx * dt;
                    projectile.y += projectile.vy * dt;

                    // Verificar tempo de vida
                    if (now - projectile.createdAt > projectile.lifetime) {
                        return false;
                    }

                    // Verificar se saiu do canvas
                    if (projectile.x < 0 || projectile.x > canvas.width ||
                        projectile.y < 0 || projectile.y > canvas.height) {
                        return false;
                    }

                    return true;
                });
            }

            shootAt(target) {
                const angle = Math.atan2(target.y - this.y, target.x - this.x);

                const projectile = {
                    x: this.x,
                    y: this.y,
                    vx: Math.cos(angle) * this.projectileSpeed,
                    vy: Math.sin(angle) * this.projectileSpeed,
                    damage: this.damage,
                    size: 5,
                    color: this.color,
                    lifetime: 4000,
                    createdAt: Date.now()
                };

                this.projectiles.push(projectile);
                this.emit('enemyShot', projectile);
            }

            takeDamage(damage) {
                this.hp -= damage;
                this.emit('damaged', damage);

                // Pequeno knockback para trás
                if (this.target) {
                    const angle = Math.atan2(this.y - this.target.y, this.x - this.target.x);
                    this.vx = Math.cos(angle) * 100;
                    this.vy = Math.sin(angle) * 100;
                }

                if (this.hp <= 0) {
                    this.die();
                }
            }

            die() {
                this.deathAnimation = true;
                this.deathTime = 0;

                // Tocar som de morte
                if (window.game && window.game.audioSystem) {
                    window.game.audioSystem.playSound('enemyDeath');
                }

                this.emit('death', this);
            }

            updateDeathAnimation(deltaTime) {
                this.deathTime += deltaTime;
                // Animação dura 500ms
                if (this.deathTime >= 500) {
                    this.emit('remove', this);
                }
            }

            render(ctx) {
                if (this.deathAnimation) {
                    this.renderDeathAnimation(ctx);
                    return;
                }

                // Desenhar corpo
                this.renderBody(ctx);

                // Desenhar projéteis
                this.renderProjectiles(ctx);

                // Desenhar HP bar se não estiver com HP cheio
                if (this.hp < this.maxHp) {
                    this.renderHealthBar(ctx);
                }
            }

            renderBody(ctx) {
                // Efeito de piscar quando com pouco HP
                const flashEffect = (Date.now() % 300) < 150;
                const lowHP = this.hp < this.maxHp * 0.3;
                const baseColor = flashEffect && lowHP ? '#ffffff' : this.color;
                
                // Desenhar inimigo baseado no tipo
                this.drawDetailedEnemy(ctx, baseColor);
            }
            
            // Método para desenhar inimigos detalhados baseado no tipo
            drawDetailedEnemy(ctx, baseColor) {
                const time = Date.now() * 0.005;
                const hover = Math.sin(time + this.x * 0.01) * 3; // Efeito de flutuação
                const pulse = (Math.sin(time * 2) + 1) * 0.5; // Pulsação
                
                const drawY = this.y + hover;
                
                switch (this.type) {
                    case 'basic':
                        this.drawBasicDemon(ctx, baseColor, drawY, pulse);
                        break;
                    case 'fast':
                        this.drawSpeedDemon(ctx, baseColor, drawY, pulse);
                        break;
                    case 'heavy':
                        this.drawHeavyDemon(ctx, baseColor, drawY, pulse);
                        break;
                    case 'sniper':
                        this.drawSniperDemon(ctx, baseColor, drawY, pulse);
                        break;
                    default:
                        this.drawBasicDemon(ctx, baseColor, drawY, pulse);
                }
            }
            
            // Demônio básico - corpo arredondado com chifres
            drawBasicDemon(ctx, baseColor, drawY, pulse) {
                // Corpo principal
                ctx.fillStyle = baseColor;
                ctx.beginPath();
                ctx.ellipse(this.x, drawY, this.size, this.size * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Sombra
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(this.x + this.size * 0.2, drawY + this.size * 0.2, this.size * 0.8, this.size * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Chifres
                ctx.fillStyle = '#8B0000';
                ctx.beginPath();
                ctx.moveTo(this.x - this.size * 0.4, drawY - this.size * 0.6);
                ctx.lineTo(this.x - this.size * 0.6, drawY - this.size * 1.2);
                ctx.lineTo(this.x - this.size * 0.2, drawY - this.size * 0.8);
                ctx.closePath();
                ctx.fill();
                
                ctx.beginPath();
                ctx.moveTo(this.x + this.size * 0.4, drawY - this.size * 0.6);
                ctx.lineTo(this.x + this.size * 0.6, drawY - this.size * 1.2);
                ctx.lineTo(this.x + this.size * 0.2, drawY - this.size * 0.8);
                ctx.closePath();
                ctx.fill();
                
                // Olhos vermelhos brilhantes
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(this.x - this.size * 0.3, drawY - this.size * 0.2, this.size * 0.15, 0, Math.PI * 2);
                ctx.arc(this.x + this.size * 0.3, drawY - this.size * 0.2, this.size * 0.15, 0, Math.PI * 2);
                ctx.fill();
                
                // Brilho dos olhos
                ctx.fillStyle = `rgba(255, 0, 0, ${pulse})`;
                ctx.beginPath();
                ctx.arc(this.x - this.size * 0.3, drawY - this.size * 0.2, this.size * 0.25, 0, Math.PI * 2);
                ctx.arc(this.x + this.size * 0.3, drawY - this.size * 0.2, this.size * 0.25, 0, Math.PI * 2);
                ctx.fill();
                
                // Asas pequenas
                ctx.fillStyle = 'rgba(139, 0, 0, 0.7)';
                ctx.beginPath();
                ctx.ellipse(this.x - this.size * 0.8, drawY, this.size * 0.4, this.size * 0.6, Math.PI / 6, 0, Math.PI * 2);
                ctx.ellipse(this.x + this.size * 0.8, drawY, this.size * 0.4, this.size * 0.6, -Math.PI / 6, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Demônio rápido - mais esguio com asas maiores
            drawSpeedDemon(ctx, baseColor, drawY, pulse) {
                // Corpo esguio
                ctx.fillStyle = baseColor;
                ctx.beginPath();
                ctx.ellipse(this.x, drawY, this.size * 0.8, this.size * 1.2, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Asas grandes e dinâmicas
                const wingFlap = Math.sin(Date.now() * 0.02) * 0.3;
                ctx.fillStyle = 'rgba(0, 139, 139, 0.8)';
                
                // Asa esquerda
                ctx.beginPath();
                ctx.ellipse(this.x - this.size * 1.2, drawY, this.size * 0.8, this.size * 1.5, wingFlap, 0, Math.PI * 2);
                ctx.fill();
                
                // Asa direita
                ctx.beginPath();
                ctx.ellipse(this.x + this.size * 1.2, drawY, this.size * 0.8, this.size * 1.5, -wingFlap, 0, Math.PI * 2);
                ctx.fill();
                
                // Detalhes das asas
                ctx.strokeStyle = '#008080';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x - this.size * 0.8, drawY);
                ctx.lineTo(this.x - this.size * 1.5, drawY - this.size * 0.5);
                ctx.moveTo(this.x + this.size * 0.8, drawY);
                ctx.lineTo(this.x + this.size * 1.5, drawY - this.size * 0.5);
                ctx.stroke();
                
                // Olhos azuis brilhantes
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(this.x - this.size * 0.2, drawY - this.size * 0.3, this.size * 0.1, 0, Math.PI * 2);
                ctx.arc(this.x + this.size * 0.2, drawY - this.size * 0.3, this.size * 0.1, 0, Math.PI * 2);
                ctx.fill();
                
                // Rastro de velocidade
                ctx.strokeStyle = `rgba(0, 255, 255, ${pulse * 0.5})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                for (let i = 1; i <= 3; i++) {
                    ctx.moveTo(this.x + this.size * i * 0.5, drawY);
                    ctx.lineTo(this.x + this.size * (i + 0.3) * 0.5, drawY);
                }
                ctx.stroke();
            }
            
            // Demônio pesado - maior e blindado
            drawHeavyDemon(ctx, baseColor, drawY, pulse) {
                // Corpo grande e robusto
                ctx.fillStyle = baseColor;
                ctx.beginPath();
                ctx.ellipse(this.x, drawY, this.size * 1.2, this.size * 1.0, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Armadura/placas
                ctx.fillStyle = '#4a4a4a';
                ctx.beginPath();
                ctx.rect(this.x - this.size * 0.8, drawY - this.size * 0.5, this.size * 1.6, this.size * 0.3);
                ctx.rect(this.x - this.size * 0.6, drawY - this.size * 0.1, this.size * 1.2, this.size * 0.3);
                ctx.fill();
                
                // Spikes na armadura
                ctx.fillStyle = '#696969';
                for (let i = -1; i <= 1; i++) {
                    ctx.beginPath();
                    ctx.moveTo(this.x + i * this.size * 0.4, drawY - this.size * 0.5);
                    ctx.lineTo(this.x + i * this.size * 0.4, drawY - this.size * 0.8);
                    ctx.lineTo(this.x + (i + 0.1) * this.size * 0.4, drawY - this.size * 0.6);
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Olhos pequenos e vermelhos
                ctx.fillStyle = '#ff4444';
                ctx.beginPath();
                ctx.arc(this.x - this.size * 0.3, drawY - this.size * 0.2, this.size * 0.08, 0, Math.PI * 2);
                ctx.arc(this.x + this.size * 0.3, drawY - this.size * 0.2, this.size * 0.08, 0, Math.PI * 2);
                ctx.fill();
                
                // Aura de defesa
                ctx.strokeStyle = `rgba(128, 128, 128, ${pulse * 0.3})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(this.x, drawY, this.size * 1.5, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Demônio atirador - com foco e mira
            drawSniperDemon(ctx, baseColor, drawY, pulse) {
                // Corpo angular
                ctx.fillStyle = baseColor;
                ctx.beginPath();
                ctx.moveTo(this.x, drawY - this.size);
                ctx.lineTo(this.x - this.size * 0.6, drawY + this.size * 0.5);
                ctx.lineTo(this.x + this.size * 0.6, drawY + this.size * 0.5);
                ctx.closePath();
                ctx.fill();
                
                // Terceiro olho (mira)
                ctx.fillStyle = '#ff8800';
                ctx.beginPath();
                ctx.arc(this.x, drawY - this.size * 0.5, this.size * 0.2, 0, Math.PI * 2);
                ctx.fill();
                
                // Crosshair no terceiro olho
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(this.x - this.size * 0.1, drawY - this.size * 0.5);
                ctx.lineTo(this.x + this.size * 0.1, drawY - this.size * 0.5);
                ctx.moveTo(this.x, drawY - this.size * 0.6);
                ctx.lineTo(this.x, drawY - this.size * 0.4);
                ctx.stroke();
                
                // Olhos laterais menores
                ctx.fillStyle = '#ffaa00';
                ctx.beginPath();
                ctx.arc(this.x - this.size * 0.4, drawY - this.size * 0.2, this.size * 0.1, 0, Math.PI * 2);
                ctx.arc(this.x + this.size * 0.4, drawY - this.size * 0.2, this.size * 0.1, 0, Math.PI * 2);
                ctx.fill();
                
                // Raio de mira
                if (this.target) {
                    ctx.strokeStyle = `rgba(255, 136, 0, ${pulse * 0.3})`;
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(this.x, drawY);
                    ctx.lineTo(this.target.x, this.target.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                // Tentáculos/apêndices de foco
                ctx.strokeStyle = baseColor;
                ctx.lineWidth = 4;
                ctx.beginPath();
                for (let i = 0; i < 4; i++) {
                    const angle = (i * Math.PI / 2) + Date.now() * 0.001;
                    const endX = this.x + Math.cos(angle) * this.size * 0.8;
                    const endY = drawY + Math.sin(angle) * this.size * 0.8;
                    ctx.moveTo(this.x, drawY);
                    ctx.lineTo(endX, endY);
                }
                ctx.stroke();
            }

            renderProjectiles(ctx) {
                for (let projectile of this.projectiles) {
                    CanvasUtils.drawMagicalProjectile(ctx, projectile.x, projectile.y, projectile.size, projectile.color, projectile.type || 'basic');
                }
            }

            renderHealthBar(ctx) {
                const barWidth = this.size * 2;
                const barHeight = 3;
                const barY = this.y - this.size - 8;

                // Background
                CanvasUtils.drawRect(ctx, this.x - barWidth / 2, barY, barWidth, barHeight, 'rgba(0, 0, 0, 0.5)');

                // HP fill
                const hpPercent = this.hp / this.maxHp;
                const fillWidth = barWidth * hpPercent;
                const color = hpPercent > 0.6 ? '#4CAF50' : hpPercent > 0.3 ? '#FF9800' : '#F44336';

                CanvasUtils.drawRect(ctx, this.x - barWidth / 2, barY, fillWidth, barHeight, color);
            }

            renderDeathAnimation(ctx) {
                const progress = this.deathTime / 500;
                const alpha = 1 - progress;
                const scale = 1 + progress * 2;

                ctx.save();
                ctx.globalAlpha = alpha;
                
                // Explosão principal
                const explosionGradient = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.size * scale * 3
                );
                explosionGradient.addColorStop(0, `rgba(255, 255, 255, ${alpha})`);
                explosionGradient.addColorStop(0.3, `rgba(255, 200, 100, ${alpha * 0.8})`);
                explosionGradient.addColorStop(0.6, `rgba(255, 100, 100, ${alpha * 0.6})`);
                explosionGradient.addColorStop(1, `rgba(255, 50, 50, 0)`);
                
                ctx.fillStyle = explosionGradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * scale * 3, 0, Math.PI * 2);
                ctx.fill();
                
                // Fragmentos voadores
                const fragmentCount = 12;
                for (let i = 0; i < fragmentCount; i++) {
                    const angle = (i * Math.PI * 2) / fragmentCount;
                    const distance = this.size * progress * 3;
                    const fragX = this.x + Math.cos(angle) * distance;
                    const fragY = this.y + Math.sin(angle) * distance;
                    const fragSize = this.size * 0.3 * (1 - progress);
                    
                    // Gradiente para cada fragmento
                    const fragGradient = ctx.createRadialGradient(
                        fragX, fragY, 0,
                        fragX, fragY, fragSize * 2
                    );
                    fragGradient.addColorStop(0, this.color);
                    fragGradient.addColorStop(1, this.color + '00');
                    
                    ctx.fillStyle = fragGradient;
                    ctx.beginPath();
                    ctx.arc(fragX, fragY, fragSize, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Faíscas brilhantes
                const sparkCount = 20;
                for (let i = 0; i < sparkCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = this.size * progress * (2 + Math.random() * 2);
                    const sparkX = this.x + Math.cos(angle) * distance;
                    const sparkY = this.y + Math.sin(angle) * distance;
                    const sparkSize = (1 - progress) * (1 + Math.random() * 2);
                    
                    ctx.fillStyle = `rgba(255, 255, 200, ${alpha * (0.5 + Math.random() * 0.5)})`;
                    ctx.beginPath();
                    ctx.arc(sparkX, sparkY, sparkSize, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Trilha da faísca
                    if (progress > 0.3) {
                        ctx.strokeStyle = `rgba(255, 200, 100, ${alpha * 0.3})`;
                        ctx.lineWidth = sparkSize * 0.5;
                        ctx.beginPath();
                        ctx.moveTo(this.x, this.y);
                        ctx.lineTo(sparkX, sparkY);
                        ctx.stroke();
                    }
                }
                
                // Núcleo residual
                if (progress < 0.7) {
                    ctx.fillStyle = this.color;
                    ctx.globalAlpha = alpha * 1.5;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * (1 - progress * 0.5), 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        // Sistema de spawn contínuo de inimigos
        class EnemySpawner extends EventEmitter {
            constructor() {
                super();

                this.enemies = [];
                this.enemyProjectiles = [];

                // Sistema de spawn contínuo
                this.spawnRate = 2000; // 2 segundos entre spawns inicialmente
                this.lastSpawnTime = 0;
                this.maxEnemies = 8; // máximo de inimigos na tela

                // Progressão de dificuldade
                this.gameStartTime = Date.now();
                this.difficultyMultiplier = 1.0;
                this.difficultyIncreaseInterval = 30000; // aumenta a cada 30 segundos

                // Sistema de ondas (compatibilidade com game.js)
                this.currentWave = 1;
                this.enemiesKilled = 0; // Total de inimigos mortos

                // Estatísticas
                this.totalEnemiesSpawned = 0;
                this.totalEnemiesKilled = 0;
            }

            update(deltaTime, player, canvas) {
                this.updateDifficulty();
                this.updateSpawning(canvas);
                this.updateEnemies(deltaTime, player, canvas);
                this.updateEnemyProjectiles(deltaTime, player, canvas);
            }

            updateDifficulty() {
                const timeElapsed = Date.now() - this.gameStartTime;
                const difficultyLevel = Math.floor(timeElapsed / this.difficultyIncreaseInterval);

                // Atualizar onda atual baseado no tempo
                const newWave = Math.max(1, difficultyLevel + 1);
                if (newWave > this.currentWave) {
                    this.currentWave = newWave;
                    this.emit('waveChanged', this.currentWave);
                }

                // Aumentar dificuldade gradualmente
                this.difficultyMultiplier = 1.0 + (difficultyLevel * 0.2);

                // Reduzir tempo entre spawns
                this.spawnRate = Math.max(800, 2000 - (difficultyLevel * 150));

                // Aumentar máximo de inimigos
                this.maxEnemies = Math.min(15, 8 + difficultyLevel);
            }

            updateSpawning(canvas) {
                const now = Date.now();

                // Spawn contínuo se não atingiu o máximo
                if (now - this.lastSpawnTime >= this.spawnRate &&
                    this.enemies.length < this.maxEnemies) {

                    this.spawnEnemy(canvas);
                    this.lastSpawnTime = now;
                }
            }

            spawnEnemy(canvas) {
                // Spawnar sempre no topo da tela (conforme descrição)
                const x = Math.random() * (canvas.width - 100) + 50;
                const y = -30; // acima da tela

                // Determinar tipo de inimigo baseado na dificuldade
                const enemyType = this.determineEnemyType();
                const enemy = new Enemy(x, y, enemyType);

                // Aplicar escalas de dificuldade
                enemy.maxHp = Math.floor(enemy.maxHp * this.difficultyMultiplier);
                enemy.hp = enemy.maxHp;
                enemy.damage = Math.floor(enemy.damage * this.difficultyMultiplier);
                enemy.speed = Math.floor(enemy.speed * (1 + (this.difficultyMultiplier - 1) * 0.5));
                enemy.expValue = Math.floor(enemy.expValue * this.difficultyMultiplier);

                // Event listeners
                enemy.on('death', () => {
                    this.removeEnemy(enemy, true); // wasKilled = true
                    this.emit('enemyKilled', enemy);
                });

                enemy.on('enemyShot', (projectile) => {
                    this.enemyProjectiles.push(projectile);
                });

                enemy.on('remove', (enemyToRemove) => {
                    this.removeEnemy(enemyToRemove);
                });

                this.enemies.push(enemy);
                this.totalEnemiesSpawned++;
                this.emit('enemySpawned', enemy);
            }

            determineEnemyType() {
                const difficultyLevel = Math.floor((Date.now() - this.gameStartTime) / this.difficultyIncreaseInterval);
                const random = Math.random();

                // Tipos básicos inicialmente, mais variedade com dificuldade
                if (difficultyLevel === 0) {
                    return 'basic';
                } else if (difficultyLevel === 1) {
                    return random < 0.7 ? 'basic' : 'fast';
                } else if (difficultyLevel === 2) {
                    if (random < 0.5) return 'basic';
                    else if (random < 0.8) return 'fast';
                    else return 'heavy';
                } else {
                    // Dificuldade alta - todos os tipos
                    if (random < 0.3) return 'basic';
                    else if (random < 0.5) return 'fast';
                    else if (random < 0.7) return 'heavy';
                    else return 'sniper';
                }
            }

            updateEnemies(deltaTime, player, canvas) {
                this.enemies = this.enemies.filter(enemy => {
                    enemy.update(deltaTime, player, canvas);

                    // Verificar colisão com jogador (apenas quando muito próximo e player não está invulnerável)
                    if (!player.invulnerable) {
                        const distance = Math.sqrt((enemy.x - player.x) ** 2 + (enemy.y - player.y) ** 2);
                        const collisionDistance = enemy.size + player.size - 5;

                        if (distance < collisionDistance) {
                            player.takeDamage(enemy.damage);
                            enemy.takeDamage(enemy.maxHp * 0.5); // Dano no inimigo também
                        }
                    }

                    return enemy.hp > 0 || (enemy.deathAnimation && enemy.deathTime < 500);
                });
            }

            updateEnemyProjectiles(deltaTime, player, canvas) {
                const dt = deltaTime / 1000;
                const now = Date.now();

                this.enemyProjectiles = this.enemyProjectiles.filter(projectile => {
                    // Atualizar posição
                    projectile.x += projectile.vx * dt;
                    projectile.y += projectile.vy * dt;

                    // Verificar tempo de vida
                    if (now - projectile.createdAt > projectile.lifetime) {
                        return false;
                    }

                    // Verificar se saiu do canvas
                    if (projectile.x < 0 || projectile.x > canvas.width ||
                        projectile.y < 0 || projectile.y > canvas.height) {
                        return false;
                    }

                    // Verificar colisão com jogador (apenas se não está invulnerável)
                    if (!player.invulnerable && Collision.circleCircle(
                        projectile.x, projectile.y, projectile.size,
                        player.x, player.y, player.size
                    )) {
                        player.takeDamage(projectile.damage);
                        return false;
                    }

                    return true;
                });
            }

            removeEnemy(enemy, wasKilled = false) {
                const index = this.enemies.indexOf(enemy);
                if (index > -1) {
                    this.enemies.splice(index, 1);

                    // Contabilizar se foi morto pelo jogador
                    if (wasKilled) {
                        this.enemiesKilled++;
                        this.totalEnemiesKilled++;
                    }
                }
            }

            render(ctx) {
                // Renderizar inimigos
                for (let enemy of this.enemies) {
                    enemy.render(ctx);
                }

                // Renderizar projéteis inimigos com efeitos mágicos
                for (let projectile of this.enemyProjectiles) {
                    CanvasUtils.drawMagicalProjectile(ctx, projectile.x, projectile.y, projectile.size, projectile.color, 'basic');
                }
            }

            getEnemies() {
                return this.enemies;
            }

            getEnemyProjectiles() {
                return this.enemyProjectiles;
            }

            getStats() {
                return {
                    totalSpawned: this.totalEnemiesSpawned,
                    totalKilled: this.totalEnemiesKilled,
                    currentEnemies: this.enemies.length,
                    difficultyMultiplier: this.difficultyMultiplier,
                    spawnRate: this.spawnRate
                };
            }
        }

    </script>
    <!-- Card Scripts -->
    <script>
        // types-card.js - Sistema completo de cartas com imagens e habilidades
        // Integra o sistema de equipamentos (chapéus e cajados) com cartas de upgrade

        // Enum para raridades das cartas
        const CardRarity = {
            COMMON: 'common',
            UNCOMMON: 'uncommon',
            EPIC: 'epic',
            ASCENSION: 'ascension'
        };

        // Enum para efeitos especiais
        const CardEffectType = {
            INSTANT: 'instant',        // Efeito imediato (ex: cura)
            PASSIVE: 'passive',        // Efeito passivo permanente
            ON_HIT: 'onHit',          // Efeito quando acerta inimigo
            ON_KILL: 'onKill',        // Efeito quando mata inimigo
            ON_DAMAGE: 'onDamage',    // Efeito quando toma dano
            TIMED: 'timed'            // Efeito com tempo/intervalo
        };

        // Definições completas das cartas com imagens e efeitos
        const CARD_DEFINITIONS = {
            // ===== CARTAS COMUNS (70% chance) =====
            catalyst: {
                id: 'catalyst',
                name: 'Catalyst',
                description: 'Dano de Projétil +2',
                image: 'catalyst-icon',
                rarity: CardRarity.COMMON,
                stackable: true,
                maxStacks: 20,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    damage: 2
                },
                apply: (player, stacks = 1) => {
                    player.damage += 2 * stacks;
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.catalyst = (player.cardStacks.catalyst || 0) + stacks;
                }
            },

            eyesight: {
                id: 'eyesight',
                name: 'Eyesight',
                description: 'Chance crítica +5%',
                image: 'eyesight-icon',
                rarity: CardRarity.COMMON,
                stackable: true,
                maxStacks: 15,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    critChance: 0.05
                },
                apply: (player, stacks = 1) => {
                    player.critChance = (player.critChance || 0) + 0.05 * stacks;
                    player.critChance = Math.min(player.critChance, 0.95); // Cap em 95%
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.eyesight = (player.cardStacks.eyesight || 0) + stacks;
                }
            },

            growth: {
                id: 'growth',
                name: 'Growth',
                description: 'HP máximo +10',
                image: 'growth-icon',
                rarity: CardRarity.COMMON,
                stackable: true,
                maxStacks: 30,
                effectType: CardEffectType.INSTANT,
                effects: {
                    maxHp: 10
                },
                apply: (player, stacks = 1) => {
                    const hpIncrease = 10 * stacks;
                    player.maxHp += hpIncrease;
                    player.hp += hpIncrease; // Também cura ao pegar
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.growth = (player.cardStacks.growth || 0) + stacks;
                }
            },

            impulse: {
                id: 'impulse',
                name: 'Impulse',
                description: 'Altura do Salto +30%',
                image: 'impulse-icon',
                rarity: CardRarity.COMMON,
                stackable: true,
                maxStacks: 10,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    jumpSpeedMultiplier: 0.3
                },
                apply: (player, stacks = 1) => {
                    player.jumpSpeed = (player.jumpSpeed || player.baseJumpSpeed) * (1 + 0.3 * stacks);
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.impulse = (player.cardStacks.impulse || 0) + stacks;
                }
            },

            renew: {
                id: 'renew',
                name: 'Renew',
                description: 'Cura completa instantânea',
                image: 'renew-icon',
                rarity: CardRarity.COMMON,
                stackable: false,
                effectType: CardEffectType.INSTANT,
                effects: {
                    instantHeal: true
                },
                apply: (player) => {
                    player.hp = player.maxHp;
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.renew = (player.cardStacks.renew || 0) + 1;
                }
            },

            resist: {
                id: 'resist',
                name: 'Resist',
                description: 'Redução de dano +4%',
                image: 'resist-icon',
                rarity: CardRarity.COMMON,
                stackable: true,
                maxStacks: 20,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    defense: 4
                },
                apply: (player, stacks = 1) => {
                    player.defense = (player.defense || 0) + 4 * stacks;
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.resist = (player.cardStacks.resist || 0) + stacks;
                }
            },

            resonance: {
                id: 'resonance',
                name: 'Resonance',
                description: 'Velocidade de Ataque +12%',
                image: 'resonance-icon',
                rarity: CardRarity.COMMON,
                stackable: true,
                maxStacks: 15,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    attackSpeedMultiplier: 0.12
                },
                apply: (player, stacks = 1) => {
                    player.attackSpeed = (player.attackSpeed || player.baseAttackSpeed) * (1 + 0.12 * stacks);
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.resonance = (player.cardStacks.resonance || 0) + stacks;
                }
            },

            souls: {
                id: 'souls',
                name: 'Souls',
                description: '+1% chance de drop de Soul Orb',
                image: 'souls-icon',
                rarity: CardRarity.COMMON,
                stackable: true,
                maxStacks: 50,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    soulOrbChance: 0.01
                },
                apply: (player, stacks = 1) => {
                    player.soulOrbChance = (player.soulOrbChance || 0.05) + 0.01 * stacks;
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.souls = (player.cardStacks.souls || 0) + stacks;
                }
            },

            stability: {
                id: 'stability',
                name: 'Stability',
                description: 'Projéteis atravessam +1 inimigo antes de sumir',
                image: 'stability-icon',
                rarity: CardRarity.COMMON,
                stackable: true,
                maxStacks: 10,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    piercing: 1
                },
                apply: (player, stacks = 1) => {
                    player.projectilePiercing = (player.projectilePiercing || 0) + 1 * stacks;
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.stability = (player.cardStacks.stability || 0) + stacks;
                }
            },

            swift: {
                id: 'swift',
                name: 'Swift',
                description: 'Velocidade de Movimento +20%',
                image: 'swift-icon',
                rarity: CardRarity.COMMON,
                stackable: true,
                maxStacks: 10,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    speedMultiplier: 0.2
                },
                apply: (player, stacks = 1) => {
                    player.speed = (player.speed || player.baseSpeed) * (1 + 0.2 * stacks);
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.swift = (player.cardStacks.swift || 0) + stacks;
                }
            },

            // ===== CARTAS INCOMUNS (25% chance) =====
            charge: {
                id: 'charge',
                name: 'Charge',
                description: 'Tamanho do Projétil +20%',
                image: 'charge-icon',
                rarity: CardRarity.UNCOMMON,
                stackable: true,
                maxStacks: 10,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    projectileSize: 0.2
                },
                apply: (player, stacks = 1) => {
                    player.projectileSize = (player.projectileSize || 1) * (1 + 0.2 * stacks);
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.charge = (player.cardStacks.charge || 0) + stacks;
                }
            },

            clock: {
                id: 'clock',
                name: 'Clock',
                description: '+10% duração de invulnerabilidade pós-dano',
                image: 'clock-icon',
                rarity: CardRarity.UNCOMMON,
                stackable: true,
                maxStacks: 15,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    invulnerabilityDuration: 0.1
                },
                apply: (player, stacks = 1) => {
                    player.invulnerabilityDuration = (player.invulnerabilityDuration || 0.5) * (1 + 0.1 * stacks);
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.clock = (player.cardStacks.clock || 0) + stacks;
                }
            },

            fragmentation: {
                id: 'fragmentation',
                name: 'Fragmentation',
                description: 'Inimigos mortos liberam 2 projéteis fracos aleatórios',
                image: 'fragmentation-icon',
                rarity: CardRarity.UNCOMMON,
                stackable: true,
                maxStacks: 10,
                effectType: CardEffectType.ON_KILL,
                effects: {
                    fragmentationProjectiles: 2
                },
                apply: (player, stacks = 1) => {
                    player.onKillEffects = player.onKillEffects || [];
                    player.onKillEffects.push({
                        type: 'fragmentation',
                        projectiles: 2 * stacks,
                        damage: player.damage * 0.3
                    });
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.fragmentation = (player.cardStacks.fragmentation || 0) + stacks;
                }
            },

            friction: {
                id: 'friction',
                name: 'Friction',
                description: 'A cada metro corrido, dispara 1 projétil explosivo para cima',
                image: 'friction-icon',
                rarity: CardRarity.UNCOMMON,
                stackable: true,
                maxStacks: 5,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    frictionProjectiles: 1
                },
                apply: (player, stacks = 1) => {
                    player.frictionEffect = {
                        enabled: true,
                        projectilesPerMeter: 1 * stacks,
                        damage: player.damage * 0.8
                    };
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.friction = (player.cardStacks.friction || 0) + stacks;
                }
            },

            growthPlus: {
                id: 'growthPlus',
                name: 'Growth+',
                description: 'HP máximo +20',
                image: 'growth-plus-icon',
                rarity: CardRarity.UNCOMMON,
                stackable: true,
                maxStacks: 20,
                effectType: CardEffectType.INSTANT,
                effects: {
                    maxHp: 20
                },
                apply: (player, stacks = 1) => {
                    const hpIncrease = 20 * stacks;
                    player.maxHp += hpIncrease;
                    player.hp += hpIncrease;
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.growthPlus = (player.cardStacks.growthPlus || 0) + stacks;
                }
            },

            leech: {
                id: 'leech',
                name: 'Leech',
                description: '3% de lifesteal em todo dano causado',
                image: 'leech-icon',
                rarity: CardRarity.UNCOMMON,
                stackable: true,
                maxStacks: 15,
                effectType: CardEffectType.ON_HIT,
                effects: {
                    lifesteal: 0.03
                },
                apply: (player, stacks = 1) => {
                    player.lifesteal = (player.lifesteal || 0) + 0.03 * stacks;
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.leech = (player.cardStacks.leech || 0) + stacks;
                }
            },

            luck: {
                id: 'luck',
                name: 'Luck',
                description: 'Aumenta chance de cartas Incomuns+',
                image: 'luck-icon',
                rarity: CardRarity.UNCOMMON,
                stackable: true,
                maxStacks: 10,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    rarityBonus: 0.05
                },
                apply: (player, stacks = 1) => {
                    player.rarityBonus = (player.rarityBonus || 0) + 0.05 * stacks;
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.luck = (player.cardStacks.luck || 0) + stacks;
                }
            },

            orb: {
                id: 'orb',
                name: 'Orb',
                description: '5% chance de inimigos droparem orbe de cura pequena',
                image: 'orb-icon',
                rarity: CardRarity.UNCOMMON,
                stackable: true,
                maxStacks: 10,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    healOrbChance: 0.05
                },
                apply: (player, stacks = 1) => {
                    player.healOrbChance = (player.healOrbChance || 0) + 0.05 * stacks;
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.orb = (player.cardStacks.orb || 0) + stacks;
                }
            },

            precision: {
                id: 'precision',
                name: 'Precision',
                description: 'Dano crítico causa +50% dano extra',
                image: 'precision-icon',
                rarity: CardRarity.UNCOMMON,
                stackable: true,
                maxStacks: 5,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    critMultiplier: 0.5
                },
                apply: (player, stacks = 1) => {
                    player.critMultiplier = (player.critMultiplier || 1.5) + 0.5 * stacks;
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.precision = (player.cardStacks.precision || 0) + stacks;
                }
            },

            regrowth: {
                id: 'regrowth',
                name: 'Regrowth',
                description: 'Regenera HP baseado no número de inimigos vivos nearby',
                image: 'regrowth-icon',
                rarity: CardRarity.UNCOMMON,
                stackable: true,
                maxStacks: 10,
                effectType: CardEffectType.TIMED,
                effects: {
                    regeneration: 0.5
                },
                apply: (player, stacks = 1) => {
                    player.regenerationRate = (player.regenerationRate || 0) + 0.5 * stacks;
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.regrowth = (player.cardStacks.regrowth || 0) + stacks;
                }
            },

            resonancePlus: {
                id: 'resonancePlus',
                name: 'Resonance+',
                description: 'Velocidade de Ataque +24%',
                image: 'resonance-plus-icon',
                rarity: CardRarity.UNCOMMON,
                stackable: true,
                maxStacks: 10,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    attackSpeedMultiplier: 0.24
                },
                apply: (player, stacks = 1) => {
                    player.attackSpeed = (player.attackSpeed || player.baseAttackSpeed) * (1 + 0.24 * stacks);
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.resonancePlus = (player.cardStacks.resonancePlus || 0) + stacks;
                }
            },

            shrink: {
                id: 'shrink',
                name: 'Shrink',
                description: 'Reduz hitbox do jogador em 10%',
                image: 'shrink-icon',
                rarity: CardRarity.UNCOMMON,
                stackable: true,
                maxStacks: 5,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    hitboxReduction: 0.1
                },
                apply: (player, stacks = 1) => {
                    player.hitboxScale = (player.hitboxScale || 1) * (1 - 0.1 * stacks);
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.shrink = (player.cardStacks.shrink || 0) + stacks;
                }
            },

            swiftPlus: {
                id: 'swiftPlus',
                name: 'Swift+',
                description: 'Velocidade de Movimento +40%',
                image: 'swift-plus-icon',
                rarity: CardRarity.UNCOMMON,
                stackable: true,
                maxStacks: 8,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    speedMultiplier: 0.4
                },
                apply: (player, stacks = 1) => {
                    player.speed = (player.speed || player.baseSpeed) * (1 + 0.4 * stacks);
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.swiftPlus = (player.cardStacks.swiftPlus || 0) + stacks;
                }
            },

            thunderbolt: {
                id: 'thunderbolt',
                name: 'Thunderbolt',
                description: 'A cada 3s, invoca 2 raios em posições aleatórias',
                image: 'thunderbolt-icon',
                rarity: CardRarity.UNCOMMON,
                stackable: true,
                maxStacks: 10,
                effectType: CardEffectType.TIMED,
                effects: {
                    lightningInterval: 3000,
                    lightningCount: 2
                },
                apply: (player, stacks = 1) => {
                    player.lightningEffect = {
                        enabled: true,
                        interval: 3000,
                        count: 2 * stacks,
                        damage: player.damage * 2,
                        lastCast: 0
                    };
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.thunderbolt = (player.cardStacks.thunderbolt || 0) + stacks;
                }
            },

            // ===== CARTAS ÉPICAS (4.5% chance) =====
            appraisal: {
                id: 'appraisal',
                name: 'Appraisal',
                description: '+1 opção em todas as seleções de carta futuras',
                image: 'appraisal-icon',
                rarity: CardRarity.EPIC,
                stackable: true,
                maxStacks: 5,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    extraCardOptions: 1
                },
                apply: (player, stacks = 1) => {
                    player.extraCardOptions = (player.extraCardOptions || 0) + 1 * stacks;
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.appraisal = (player.cardStacks.appraisal || 0) + stacks;
                }
            },

            barrier: {
                id: 'barrier',
                name: 'Barrier',
                description: 'Gera escudo que absorve 1 hit a cada 5s',
                image: 'barrier-icon',
                rarity: CardRarity.EPIC,
                stackable: true,
                maxStacks: 5,
                effectType: CardEffectType.TIMED,
                effects: {
                    shieldInterval: 5000,
                    shieldStrength: 1
                },
                apply: (player, stacks = 1) => {
                    player.barrierEffect = {
                        enabled: true,
                        interval: 5000,
                        strength: 1 * stacks,
                        currentShield: 0,
                        lastGenerated: 0
                    };
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.barrier = (player.cardStacks.barrier || 0) + stacks;
                }
            },

            cold: {
                id: 'cold',
                name: 'Cold',
                description: 'Inimigos ficam -1% velocidade por hit recebido (max -80%)',
                image: 'cold-icon',
                rarity: CardRarity.EPIC,
                stackable: true,
                maxStacks: 10,
                effectType: CardEffectType.ON_HIT,
                effects: {
                    slowEffect: 0.01,
                    maxSlow: 0.8
                },
                apply: (player, stacks = 1) => {
                    player.onHitEffects = player.onHitEffects || [];
                    player.onHitEffects.push({
                        type: 'slow',
                        slowAmount: 0.01 * stacks,
                        maxSlow: 0.8
                    });
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.cold = (player.cardStacks.cold || 0) + stacks;
                }
            },

            focus: {
                id: 'focus',
                name: 'Focus',
                description: '+2% velocidade de ataque por segundo parado (reset por onda)',
                image: 'focus-icon',
                rarity: CardRarity.EPIC,
                stackable: true,
                maxStacks: 10,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    focusBonus: 0.02
                },
                apply: (player, stacks = 1) => {
                    player.focusEffect = {
                        enabled: true,
                        bonusPerSecond: 0.02 * stacks,
                        currentBonus: 0,
                        stationaryTime: 0
                    };
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.focus = (player.cardStacks.focus || 0) + stacks;
                }
            },

            immortal: {
                id: 'immortal',
                name: 'Immortal',
                description: '+1 Vida extra (mata todos inimigos ao reviver) [carta única]',
                image: 'immortal-icon',
                rarity: CardRarity.EPIC,
                stackable: false,
                unique: true,
                effectType: CardEffectType.ON_DAMAGE,
                effects: {
                    extraLife: 1
                },
                apply: (player) => {
                    player.extraLives = (player.extraLives || 0) + 1;
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.immortal = 1;
                }
            },

            overheat: {
                id: 'overheat',
                name: 'Overheat',
                description: 'Corpo causa 40 de dano de contato por segundo',
                image: 'overheat-icon',
                rarity: CardRarity.EPIC,
                stackable: true,
                maxStacks: 5,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    contactDamage: 40
                },
                apply: (player, stacks = 1) => {
                    player.contactDamage = (player.contactDamage || 0) + 40 * stacks;
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.overheat = (player.cardStacks.overheat || 0) + stacks;
                }
            },

            tome: {
                id: 'tome',
                name: 'Tome',
                description: 'Cartas Comuns futuras são 35% mais eficazes',
                image: 'tome-icon',
                rarity: CardRarity.EPIC,
                stackable: true,
                maxStacks: 5,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    commonCardBonus: 0.35
                },
                apply: (player, stacks = 1) => {
                    player.commonCardBonus = (player.commonCardBonus || 1) * (1 + 0.35 * stacks);
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.tome = (player.cardStacks.tome || 0) + stacks;
                }
            },

            willOWisp: {
                id: 'willOWisp',
                name: 'Will-O-Wisp',
                description: 'Spawn wisp que orbita e ataca (50% do seu dano e velocidade)',
                image: 'will-o-wisp-icon',
                rarity: CardRarity.EPIC,
                stackable: true,
                maxStacks: 4,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    wisp: true
                },
                apply: (player, stacks = 1) => {
                    player.wisps = (player.wisps || 0) + 1 * stacks;
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.willOWisp = (player.cardStacks.willOWisp || 0) + stacks;
                }
            },

            wound: {
                id: 'wound',
                name: 'Wound',
                description: 'Todo dano aplica sangramento (DPS overtime)',
                image: 'wound-icon',
                rarity: CardRarity.EPIC,
                stackable: true,
                maxStacks: 10,
                effectType: CardEffectType.ON_HIT,
                effects: {
                    bleeding: true
                },
                apply: (player, stacks = 1) => {
                    player.onHitEffects = player.onHitEffects || [];
                    player.onHitEffects.push({
                        type: 'bleeding',
                        dps: player.damage * 0.2 * stacks,
                        duration: 5000
                    });
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.wound = (player.cardStacks.wound || 0) + stacks;
                }
            },

            // Novas cartas Incomuns adicionadas
            gush: {
                id: 'gush',
                name: 'Gush',
                description: '+1 Salto adicional (multi-jump)',
                image: 'gush-icon',
                rarity: CardRarity.UNCOMMON,
                stackable: true,
                maxStacks: 5,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    extraJumps: 1
                },
                apply: (player, stacks = 1) => {
                    player.maxJumps = (player.maxJumps || 1) + 1 * stacks;
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.gush = (player.cardStacks.gush || 0) + stacks;
                }
            },

            rage: {
                id: 'rage',
                name: 'Rage',
                description: '<50% HP: +1% dano para cada 1% de HP perdido (max 50%)',
                image: 'rage-icon',
                rarity: CardRarity.UNCOMMON,
                stackable: true,
                maxStacks: 5,
                effectType: CardEffectType.PASSIVE,
                effects: {
                    rageDamageBonus: 0.01
                },
                apply: (player, stacks = 1) => {
                    player.rageEffect = {
                        enabled: true,
                        damagePerHpLost: 0.01 * stacks,
                        maxBonus: 0.5
                    };
                    player.cardStacks = player.cardStacks || {};
                    player.cardStacks.rage = (player.cardStacks.rage || 0) + stacks;
                }
            },
        };

        // Função para construir pools de cartas por raridade
        function buildCardPools() {
            const pools = {
                [CardRarity.COMMON]: [],
                [CardRarity.UNCOMMON]: [],
                [CardRarity.EPIC]: [],
                [CardRarity.ASCENSION]: []
            };

            Object.values(CARD_DEFINITIONS).forEach(card => {
                pools[card.rarity].push(card);
            });

            return pools;
        }

        // Função para obter cartas aleatórias baseado nas probabilidades
        function getRandomCards(count = 3, extraOptions = 0) {
            const totalOptions = count + extraOptions;
            const cards = [];

            for (let i = 0; i < totalOptions; i++) {
                const rand = Math.random();
                let rarity;

                if (rand < 0.70) {
                    rarity = CardRarity.COMMON;
                } else if (rand < 0.95) {
                    rarity = CardRarity.UNCOMMON;
                } else {
                    rarity = CardRarity.EPIC;
                }

                const pool = buildCardPools()[rarity];
                const randomCard = pool[Math.floor(Math.random() * pool.length)];

                // Evitar cartas duplicadas na mesma seleção
                if (!cards.find(c => c.id === randomCard.id)) {
                    cards.push(randomCard);
                } else {
                    i--; // Tentar novamente
                }
            }

            return cards;
        }

        // Função para aplicar efeito de uma carta ao jogador
        function applyCard(player, cardId, stacks = 1) {
            const card = CARD_DEFINITIONS[cardId];
            if (!card) {
                console.warn(`Card ${cardId} not found`);
                return false;
            }

            // Verificar se é única e já foi aplicada
            if (card.unique && player.appliedCards && player.appliedCards.includes(cardId)) {
                return false;
            }

            // Verificar stacks máximos
            if (card.stackable && card.maxStacks) {
                const currentStacks = (player.cardStacks && player.cardStacks[cardId]) || 0;
                if (currentStacks >= card.maxStacks) {
                    return false;
                }
                stacks = Math.min(stacks, card.maxStacks - currentStacks);
            }

            // Aplicar efeito
            card.apply(player, stacks);

            // Registrar aplicação
            if (!player.appliedCards) player.appliedCards = [];
            if (!player.cardStacks) player.cardStacks = {};

            if (!player.appliedCards.includes(cardId)) {
                player.appliedCards.push(cardId);
            }

            if (card.stackable) {
                player.cardStacks[cardId] = (player.cardStacks[cardId] || 0) + stacks;
            }

            return true;
        }

        // Função para obter informações de uma carta
        function getCardInfo(cardId) {
            return CARD_DEFINITIONS[cardId] || null;
        }

        // Export das funcionalidades principais
        if (typeof module !== 'undefined' && module.exports) {
            module.exports = {
                CARD_DEFINITIONS,
                CardRarity,
                buildCardPools,
                getRandomCards,
                applyCard,
                getCardInfo
            };
        }

    </script>
    <!-- Upgrade Scripts -->
    <script>
        // upgrades.js - Sistema de upgrades por nível integrado com cartas

        class UpgradeSystem extends EventEmitter {
            constructor() {
                super();

                this.currentUpgradeOptions = [];
                this.isUpgradeMenuOpen = false;
                this.selectedUpgrade = null;

                // Carregar sistema de cartas
                this.loadCardSystem();
            }

            loadCardSystem() {
                // Certificar que o sistema de cartas está disponível
                if (typeof getRandomCards === 'undefined') {
                    console.error('Card system not loaded! Make sure types-card.js is included.');
                    return;
                }
            }

            // Gerar opções de upgrade quando jogador sobe de nível
            generateUpgradeOptions(player) {
                const baseOptions = 3;
                const extraOptions = (player.abilities && player.abilities.extraCardOptions) || 0;
                const totalOptions = baseOptions + extraOptions;

                // Se o chapéu força cartas incomuns+
                let cards;
                if (player.abilities && player.abilities.onlyUncommonCards) {
                    cards = this.getFilteredCards(totalOptions, ['uncommon', 'epic']);
                } else {
                    cards = getRandomCards(totalOptions, 0);
                }

                this.currentUpgradeOptions = cards;
                this.isUpgradeMenuOpen = true;

                this.emit('upgradeMenuOpened', cards);

                return cards;
            }

            // Obter cartas filtradas por raridade
            getFilteredCards(count, allowedRarities) {
                const cards = [];
                const pools = buildCardPools();

                for (let i = 0; i < count; i++) {
                    let attempts = 0;
                    let card = null;

                    while (!card && attempts < 50) {
                        const rarity = allowedRarities[Math.floor(Math.random() * allowedRarities.length)];
                        const pool = pools[rarity];

                        if (pool && pool.length > 0) {
                            const randomCard = pool[Math.floor(Math.random() * pool.length)];

                            // Evitar duplicatas
                            if (!cards.find(c => c.id === randomCard.id)) {
                                card = randomCard;
                            }
                        }
                        attempts++;
                    }

                    if (card) {
                        cards.push(card);
                    }
                }

                return cards;
            }

            // Aplicar upgrade selecionado
            selectUpgrade(cardId, player) {
                if (!this.isUpgradeMenuOpen) return false;

                const selectedCard = this.currentUpgradeOptions.find(card => card.id === cardId);
                if (!selectedCard) return false;

                // Aplicar efeito da carta
                const success = applyCard(player, cardId, 1);

                if (success) {
                    this.selectedUpgrade = selectedCard;

                    // Adicionar carta à build do player
                    if (player.addSelectedCard) {
                        player.addSelectedCard(selectedCard);
                    }

                    this.closeUpgradeMenu();
                    this.emit('upgradeSelected', selectedCard, player);

                    // Efeito visual/sonoro
                    this.showUpgradeEffect(selectedCard);

                    return true;
                }

                return false;
            }

            // Reroll das opções (se permitido)
            rerollOptions(player) {
                // Verificar se tem rerolls infinitos (Fedora)
                if (player.abilities && player.abilities.infiniteRerolls) {
                    this.generateUpgradeOptions(player);
                    return true;
                }

                // Sistema básico de reroll (pode ser expandido)
                if (player.rerolls && player.rerolls > 0) {
                    player.rerolls--;
                    this.generateUpgradeOptions(player);
                    this.emit('rerollUsed', player.rerolls);
                    return true;
                }

                return false;
            }

            // Fechar menu de upgrade
            closeUpgradeMenu() {
                this.isUpgradeMenuOpen = false;
                this.currentUpgradeOptions = [];
                this.selectedUpgrade = null;

                this.emit('upgradeMenuClosed');
            }

            // Mostrar efeito visual do upgrade
            showUpgradeEffect(card) {
                // Criar elemento visual
                const effect = document.createElement('div');
                effect.className = `upgrade-effect upgrade-${card.rarity}`;
                effect.innerHTML = `
            <div class="upgrade-card upgrade-${card.rarity}">
                <div class="upgrade-card-glow"></div>
                <div class="upgrade-card-content">
                    <div class="upgrade-icon-container">
                        <svg width="64" height="64" viewBox="0 0 64 64">
                            <use href="#${card.image}"/>
                        </svg>
                        <div class="upgrade-icon-glow"></div>
                    </div>
                    <h3>${card.name}</h3>
                    <div class="upgrade-rarity-badge">${card.rarity.toUpperCase()}</div>
                    <p>${card.description}</p>
                    <div class="upgrade-particles"></div>
                </div>
            </div>
        `;

                // Estilos
                Object.assign(effect.style, {
                    position: 'fixed',
                    top: '50%',
                    left: '50%',
                    transform: 'translate(-50%, -50%) scale(0)',
                    zIndex: '2000',
                    background: this.getRarityColor(card.rarity),
                    padding: '20px',
                    borderRadius: '15px',
                    border: '3px solid #fff',
                    boxShadow: '0 0 30px rgba(255, 255, 255, 0.5)',
                    color: '#fff',
                    textAlign: 'center',
                    maxWidth: '300px',
                    animation: 'upgradeShow 2s ease-out forwards'
                });

                document.body.appendChild(effect);

                // Remover após animação
                setTimeout(() => {
                    if (effect.parentNode) {
                        effect.parentNode.removeChild(effect);
                    }
                }, 2000);
            }

            // Obter cor baseada na raridade
            getRarityColor(rarity) {
                const colors = {
                    common: 'linear-gradient(135deg, #9E9E9E, #BDBDBD)',
                    uncommon: 'linear-gradient(135deg, #2196F3, #64B5F6)',
                    epic: 'linear-gradient(135deg, #9C27B0, #BA68C8)',
                    ascension: 'linear-gradient(135deg, #FF9800, #FFB74D)'
                };
                return colors[rarity] || colors.common;
            }

            // Renderizar menu de upgrade
            renderUpgradeMenu(ctx, canvas) {
                if (!this.isUpgradeMenuOpen || this.currentUpgradeOptions.length === 0) {
                    return;
                }

                // Overlay escuro
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Título
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 32px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('LEVEL UP!', canvas.width / 2, 80);

                ctx.font = '18px Arial';
                ctx.fillText('Choose an upgrade:', canvas.width / 2, 110);

                // Cartas
                const cardWidth = 200;
                const cardHeight = 280;
                const spacing = 20;
                const startX = (canvas.width - (this.currentUpgradeOptions.length * cardWidth + (this.currentUpgradeOptions.length - 1) * spacing)) / 2;
                const startY = 150;

                this.currentUpgradeOptions.forEach((card, index) => {
                    const x = startX + index * (cardWidth + spacing);
                    const y = startY;

                    this.renderUpgradeCard(ctx, card, x, y, cardWidth, cardHeight, index);
                });

                // Instruções
                ctx.fillStyle = '#cccccc';
                ctx.font = '16px Arial';
                ctx.fillText('Click on a card to select it', canvas.width / 2, canvas.height - 40);
            }

            // Renderizar carta individual com visual aprimorado
            renderUpgradeCard(ctx, card, x, y, width, height, index) {
                const time = Date.now() * 0.002;
                const hoverOffset = Math.sin(time + index * 0.5) * 2;
                const glowIntensity = (Math.sin(time * 2 + index) + 1) * 0.5;
                
                // Sombra da carta
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
                ctx.shadowBlur = 15;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3 + hoverOffset;
                
                // Background principal da carta com cantos arredondados
                const radius = 12;
                this.drawRoundedRect(ctx, x, y + hoverOffset, width, height, radius);
                
                // Gradientes baseados na raridade
                const gradient = ctx.createLinearGradient(x, y, x + width, y + height);
                const rarityColors = this.getRarityGradient(card.rarity);
                
                gradient.addColorStop(0, rarityColors.start);
                gradient.addColorStop(0.3, rarityColors.mid);
                gradient.addColorStop(1, rarityColors.end);
                
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Borda ornamental com brilho
                ctx.restore();
                const borderGradient = ctx.createLinearGradient(x, y, x + width, y + height);
                const borderColors = this.getRarityBorderColors(card.rarity);
                
                borderGradient.addColorStop(0, borderColors.light);
                borderGradient.addColorStop(0.5, borderColors.bright);
                borderGradient.addColorStop(1, borderColors.dark);
                
                ctx.strokeStyle = borderGradient;
                ctx.lineWidth = 4;
                ctx.shadowColor = borderColors.glow;
                ctx.shadowBlur = 8 + glowIntensity * 5;
                this.drawRoundedRect(ctx, x, y + hoverOffset, width, height, radius);
                ctx.stroke();
                
                // Padrão decorativo de fundo
                ctx.save();
                ctx.globalAlpha = 0.1;
                this.drawCardPattern(ctx, x, y + hoverOffset, width, height, card.rarity);
                ctx.restore();
                
                // Área do ícone - círculo ornamental
                const iconSize = 48;
                const iconY = y + hoverOffset + 35;
                const iconCenterX = x + width / 2;
                
                // Círculo de fundo do ícone
                const iconGradient = ctx.createRadialGradient(iconCenterX, iconY, 0, iconCenterX, iconY, iconSize);
                iconGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                iconGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.6)');
                iconGradient.addColorStop(1, 'rgba(255, 255, 255, 0.2)');
                
                ctx.fillStyle = iconGradient;
                ctx.beginPath();
                ctx.arc(iconCenterX, iconY, iconSize / 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Borda do círculo do ícone
                ctx.strokeStyle = borderColors.bright;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Ícone da carta (simulado com forma geométrica)
                this.drawCardIcon(ctx, iconCenterX, iconY, iconSize * 0.6, card);
                
                // Nome da carta com sombra
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                ctx.shadowBlur = 3;
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;
                
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 20px "Arial", sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(card.name, x + width / 2, y + hoverOffset + 110);
                ctx.restore();
                
                // Linha decorativa
                const lineY = y + hoverOffset + 125;
                ctx.strokeStyle = borderColors.bright;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x + 20, lineY);
                ctx.lineTo(x + width - 20, lineY);
                ctx.stroke();
                
                // Descrição com fundo semi-transparente
                ctx.save();
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.drawRoundedRect(ctx, x + 10, y + hoverOffset + 135, width - 20, 80, 8);
                ctx.fill();
                
                ctx.fillStyle = '#ffffff';
                ctx.font = '14px "Arial", sans-serif';
                ctx.textAlign = 'center';
                const lines = this.wrapText(ctx, card.description, width - 30);
                lines.forEach((line, lineIndex) => {
                    ctx.fillText(line, x + width / 2, y + hoverOffset + 155 + lineIndex * 18);
                });
                ctx.restore();
                
                // Badge de raridade
                this.drawRarityBadge(ctx, x + width - 15, y + hoverOffset + 15, card.rarity);
                
                // Efeitos especiais baseados na raridade
                this.drawRarityEffects(ctx, x, y + hoverOffset, width, height, card.rarity, time + index);
                
                // Gemas decorativas nos cantos
                this.drawCornerGems(ctx, x, y + hoverOffset, width, height, card.rarity);
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;

                // Número da opção
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px Arial';
                ctx.fillText((index + 1).toString(), x + 15, y + 20);
    
                // Guardar área clicável
                card._clickArea = { x, y, width, height };
            }
    
            // Métodos auxiliares para renderização das cartas
            
            // Desenhar retângulo com cantos arredondados
            drawRoundedRect(ctx, x, y, width, height, radius) {
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
            }
            
            // Obter gradientes de cor baseados na raridade
            getRarityGradient(rarity) {
                const gradients = {
                    common: {
                        start: '#E0E0E0',
                        mid: '#BDBDBD', 
                        end: '#9E9E9E'
                    },
                    uncommon: {
                        start: '#64B5F6',
                        mid: '#2196F3',
                        end: '#1976D2'
                    },
                    epic: {
                        start: '#CE93D8',
                        mid: '#AB47BC',
                        end: '#8E24AA'
                    },
                    ascension: {
                        start: '#FFD54F',
                        mid: '#FFC107',
                        end: '#FF8F00'
                    }
                };
                return gradients[rarity] || gradients.common;
            }
            
            // Obter cores da borda baseadas na raridade
            getRarityBorderColors(rarity) {
                const borderColors = {
                    common: {
                        light: '#FFFFFF',
                        bright: '#E0E0E0',
                        dark: '#757575',
                        glow: '#FFFFFF'
                    },
                    uncommon: {
                        light: '#E3F2FD',
                        bright: '#2196F3',
                        dark: '#0D47A1',
                        glow: '#2196F3'
                    },
                    epic: {
                        light: '#F3E5F5',
                        bright: '#AB47BC',
                        dark: '#4A148C',
                        glow: '#AB47BC'
                    },
                    ascension: {
                        light: '#FFF8E1',
                        bright: '#FFC107',
                        dark: '#E65100',
                        glow: '#FFC107'
                    }
                };
                return borderColors[rarity] || borderColors.common;
            }
            
            // Desenhar padrão decorativo de fundo
            drawCardPattern(ctx, x, y, width, height, rarity) {
                ctx.save();
                
                // Padrões diferentes por raridade
                switch (rarity) {
                    case 'common':
                        // Linhas simples
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 1;
                        for (let i = 0; i < width; i += 20) {
                            ctx.beginPath();
                            ctx.moveTo(x + i, y);
                            ctx.lineTo(x + i, y + height);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'uncommon':
                        // Padrão de diamantes
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 1;
                        for (let i = 0; i < width; i += 30) {
                            for (let j = 0; j < height; j += 30) {
                                ctx.beginPath();
                                ctx.moveTo(x + i + 15, y + j);
                                ctx.lineTo(x + i + 30, y + j + 15);
                                ctx.lineTo(x + i + 15, y + j + 30);
                                ctx.lineTo(x + i, y + j + 15);
                                ctx.closePath();
                                ctx.stroke();
                            }
                        }
                        break;
                        
                    case 'epic':
                        // Círculos concêntricos
                        ctx.strokeStyle = '#FFFFFF';
                        ctx.lineWidth = 1;
                        for (let radius = 10; radius < Math.max(width, height); radius += 25) {
                            ctx.beginPath();
                            ctx.arc(x + width/2, y + height/2, radius, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                        break;
                        
                    case 'ascension':
                        // Estrelas
                        ctx.fillStyle = '#FFFFFF';
                        for (let i = 0; i < width; i += 40) {
                            for (let j = 0; j < height; j += 40) {
                                this.drawStar(ctx, x + i + 20, y + j + 20, 8, '#FFFFFF');
                            }
                        }
                        break;
                }
                
                ctx.restore();
            }
            
            // Desenhar ícone da carta baseado no tipo
            drawCardIcon(ctx, centerX, centerY, size, card) {
                ctx.save();
                
                // Ícones simulados baseados no nome da carta
                const iconColor = '#2C3E50';
                ctx.fillStyle = iconColor;
                
                // Formas básicas baseadas no nome/tipo da carta
                switch (card.id) {
                    case 'catalyst':
                        // Símbolo de mais
                        ctx.fillRect(centerX - size/2, centerY - size/8, size, size/4);
                        ctx.fillRect(centerX - size/8, centerY - size/2, size/4, size);
                        break;
                        
                    case 'eyesight':
                        // Olho
                        ctx.beginPath();
                        ctx.ellipse(centerX, centerY, size/2, size/3, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = '#FFFFFF';
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, size/4, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                        
                    case 'growth':
                        // Coração
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY + size/4);
                        ctx.bezierCurveTo(centerX - size/2, centerY - size/4, centerX - size/4, centerY - size/2, centerX, centerY);
                        ctx.bezierCurveTo(centerX + size/4, centerY - size/2, centerX + size/2, centerY - size/4, centerX, centerY + size/4);
                        ctx.fill();
                        break;
                        
                    case 'swift':
                        // Seta
                        ctx.beginPath();
                        ctx.moveTo(centerX - size/2, centerY);
                        ctx.lineTo(centerX + size/4, centerY - size/4);
                        ctx.lineTo(centerX + size/4, centerY - size/8);
                        ctx.lineTo(centerX + size/2, centerY - size/8);
                        ctx.lineTo(centerX + size/2, centerY + size/8);
                        ctx.lineTo(centerX + size/4, centerY + size/8);
                        ctx.lineTo(centerX + size/4, centerY + size/4);
                        ctx.closePath();
                        ctx.fill();
                        break;
                        
                    case 'thunderbolt':
                        // Raio
                        ctx.beginPath();
                        ctx.moveTo(centerX - size/4, centerY - size/2);
                        ctx.lineTo(centerX + size/8, centerY - size/2);
                        ctx.lineTo(centerX - size/8, centerY);
                        ctx.lineTo(centerX + size/4, centerY);
                        ctx.lineTo(centerX, centerY + size/2);
                        ctx.lineTo(centerX - size/8, centerY + size/8);
                        ctx.lineTo(centerX + size/8, centerY + size/8);
                        ctx.closePath();
                        ctx.fill();
                        break;
                        
                    default:
                        // Ícone genérico - losango
                        ctx.beginPath();
                        ctx.moveTo(centerX, centerY - size/2);
                        ctx.lineTo(centerX + size/3, centerY);
                        ctx.lineTo(centerX, centerY + size/2);
                        ctx.lineTo(centerX - size/3, centerY);
                        ctx.closePath();
                        ctx.fill();
                        break;
                }
                
                ctx.restore();
            }
            
            // Desenhar badge de raridade
            drawRarityBadge(ctx, x, y, rarity) {
                const badgeSize = 24;
                const colors = {
                    common: '#9E9E9E',
                    uncommon: '#2196F3',
                    epic: '#9C27B0',
                    ascension: '#FF9800'
                };
                
                ctx.save();
                
                // Círculo de fundo
                ctx.fillStyle = colors[rarity] || colors.common;
                ctx.beginPath();
                ctx.arc(x, y, badgeSize/2, 0, Math.PI * 2);
                ctx.fill();
                
                // Borda
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Letra da raridade
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 12px Arial';
                ctx.textAlign = 'center';
                const letter = rarity.charAt(0).toUpperCase();
                ctx.fillText(letter, x, y + 4);
                
                ctx.restore();
            }
            
            // Desenhar efeitos especiais baseados na raridade
            drawRarityEffects(ctx, x, y, width, height, rarity, time) {
                ctx.save();
                
                switch (rarity) {
                    case 'epic':
                        // Partículas flutuantes
                        ctx.fillStyle = 'rgba(171, 71, 188, 0.6)';
                        for (let i = 0; i < 8; i++) {
                            const particleX = x + (width * 0.2) + (i * width * 0.1) + Math.sin(time + i) * 10;
                            const particleY = y + (height * 0.3) + Math.cos(time + i * 0.7) * height * 0.4;
                            ctx.beginPath();
                            ctx.arc(particleX, particleY, 2, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        break;
                        
                    case 'ascension':
                        // Aura dourada pulsante
                        const alpha = (Math.sin(time * 2) + 1) * 0.2;
                        ctx.globalAlpha = alpha;
                        ctx.strokeStyle = '#FFD700';
                        ctx.lineWidth = 3;
                        ctx.shadowColor = '#FFD700';
                        ctx.shadowBlur = 15;
                        this.drawRoundedRect(ctx, x - 5, y - 5, width + 10, height + 10, 15);
                        ctx.stroke();
                        break;
                }
                
                ctx.restore();
            }
            
            // Desenhar gemas decorativas nos cantos
            drawCornerGems(ctx, x, y, width, height, rarity) {
                const gemSize = 6;
                const colors = this.getRarityBorderColors(rarity);
                
                ctx.save();
                ctx.fillStyle = colors.bright;
                
                // Gema superior esquerda
                ctx.beginPath();
                ctx.moveTo(x + 10, y + 5);
                ctx.lineTo(x + 10 + gemSize, y + 5);
                ctx.lineTo(x + 10 + gemSize/2, y + 5 + gemSize);
                ctx.closePath();
                ctx.fill();
                
                // Gema superior direita
                ctx.beginPath();
                ctx.moveTo(x + width - 10 - gemSize, y + 5);
                ctx.lineTo(x + width - 10, y + 5);
                ctx.lineTo(x + width - 10 - gemSize/2, y + 5 + gemSize);
                ctx.closePath();
                ctx.fill();
                
                // Gema inferior esquerda
                ctx.beginPath();
                ctx.moveTo(x + 10 + gemSize/2, y + height - 5 - gemSize);
                ctx.lineTo(x + 10, y + height - 5);
                ctx.lineTo(x + 10 + gemSize, y + height - 5);
                ctx.closePath();
                ctx.fill();
                
                // Gema inferior direita
                ctx.beginPath();
                ctx.moveTo(x + width - 10 - gemSize/2, y + height - 5 - gemSize);
                ctx.lineTo(x + width - 10 - gemSize, y + height - 5);
                ctx.lineTo(x + width - 10, y + height - 5);
                ctx.closePath();
                ctx.fill();
                
                ctx.restore();
            }
            
            // Desenhar estrela (reutilizando do Player)
            drawStar(ctx, x, y, size, color) {
                ctx.save();
                ctx.fillStyle = color;
                ctx.beginPath();
                
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 4 * Math.PI) / 5;
                    const starX = x + Math.cos(angle) * size;
                    const starY = y + Math.sin(angle) * size;
                    
                    if (i === 0) {
                        ctx.moveTo(starX, starY);
                    } else {
                        ctx.lineTo(starX, starY);
                    }
                }
                
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            // Quebrar texto em linhas
            wrapText(ctx, text, maxWidth) {
                const words = text.split(' ');
                const lines = [];
                let currentLine = words[0];

                for (let i = 1; i < words.length; i++) {
                    const word = words[i];
                    const width = ctx.measureText(currentLine + ' ' + word).width;
                    if (width < maxWidth) {
                        currentLine += ' ' + word;
                    } else {
                        lines.push(currentLine);
                        currentLine = word;
                    }
                }
                lines.push(currentLine);

                return lines;
            }

            // Cor do texto baseada na raridade
            getRarityTextColor(rarity) {
                const colors = {
                    common: '#666666',
                    uncommon: '#1976d2',
                    epic: '#7b1fa2',
                    ascension: '#f57c00'
                };
                return colors[rarity] || colors.common;
            }

            // Mostrar menu de upgrade
            showUpgradeMenu(player) {
                if (this.isUpgradeMenuOpen) {
                    return; // Já está aberto
                }

                // Gerar opções de upgrade
                this.generateUpgradeOptions(player);

                return this.currentUpgradeOptions;
            }

            // Esconder menu de upgrade
            hideUpgradeMenu() {
                this.closeUpgradeMenu();
            }

            // Detectar clique nas cartas
            handleClick(x, y) {
                if (!this.isUpgradeMenuOpen) return null;

                for (let card of this.currentUpgradeOptions) {
                    if (card._clickArea) {
                        const area = card._clickArea;
                        if (x >= area.x && x <= area.x + area.width &&
                            y >= area.y && y <= area.y + area.height) {
                            return card.id;
                        }
                    }
                }

                return null;
            }
        }

        // Adicionar estilos CSS para as animações
        const upgradeStyles = document.createElement('style');
        upgradeStyles.textContent = `
    @keyframes upgradeShow {
        0% {
            transform: translate(-50%, -50%) scale(0) rotate(-180deg);
            opacity: 0;
        }
        50% {
            transform: translate(-50%, -50%) scale(1.2) rotate(0deg);
            opacity: 1;
        }
        100% {
            transform: translate(-50%, -50%) scale(1) rotate(0deg);
            opacity: 1;
        }
    }
    
    .upgrade-card {
        text-align: center;
        background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
        border: 2px solid rgba(255,255,255,0.3);
        border-radius: 15px;
        padding: 20px;
        backdrop-filter: blur(10px);
        box-shadow: 
            0 8px 32px rgba(0,0,0,0.3),
            inset 0 1px 0 rgba(255,255,255,0.2);
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
    }
    
    .upgrade-card:hover {
        transform: translateY(-5px) scale(1.02);
        box-shadow: 
            0 12px 40px rgba(0,0,0,0.4),
            inset 0 1px 0 rgba(255,255,255,0.3);
        border-color: rgba(255,255,255,0.5);
    }
    
    .upgrade-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
        transition: left 0.5s;
    }
    
    .upgrade-card:hover::before {
        left: 100%;
    }
    
    .upgrade-card svg {
        width: 64px;
        height: 64px;
        margin-bottom: 15px;
        border-radius: 50%;
        background: radial-gradient(circle, rgba(255,255,255,0.8), rgba(255,255,255,0.3));
        padding: 8px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        transition: transform 0.3s ease;
    }
    
    .upgrade-card:hover svg {
        transform: rotateY(360deg) scale(1.1);
    }
    
    .upgrade-card h3 {
        margin: 15px 0 8px 0;
        font-size: 1.3em;
        font-weight: bold;
        text-shadow: 
            0 1px 2px rgba(0,0,0,0.8),
            0 0 20px rgba(255,255,255,0.3);
        background: linear-gradient(45deg, #ffffff, #f0f0f0);
        -webkit-background-clip: text;
        background-clip: text;
        -webkit-text-fill-color: transparent;
    }
    
    .upgrade-card p {
        margin: 0;
        font-size: 0.95em;
        opacity: 0.9;
        text-shadow: 0 1px 2px rgba(0,0,0,0.8);
        line-height: 1.4;
        background: rgba(0,0,0,0.2);
        padding: 10px;
        border-radius: 8px;
        border: 1px solid rgba(255,255,255,0.1);
    }
    
    /* Efeitos especiais para raridades */
    .upgrade-common {
        border-color: rgba(158, 158, 158, 0.5);
        box-shadow: 0 0 20px rgba(158, 158, 158, 0.3);
    }
    
    .upgrade-uncommon {
        border-color: rgba(33, 150, 243, 0.6);
        box-shadow: 0 0 25px rgba(33, 150, 243, 0.4);
    }
    
    .upgrade-epic {
        border-color: rgba(156, 39, 176, 0.7);
        box-shadow: 0 0 30px rgba(156, 39, 176, 0.5);
        animation: epicGlow 2s ease-in-out infinite alternate;
    }
    
    .upgrade-ascension {
        border-color: rgba(255, 152, 0, 0.8);
        box-shadow: 0 0 35px rgba(255, 152, 0, 0.6);
        animation: ascensionGlow 1.5s ease-in-out infinite alternate;
    }
    
    /* Efeitos especiais para o popup de upgrade */
    .upgrade-effect {
        animation: upgradePopup 3s ease-out forwards !important;
    }
    
    .upgrade-card-glow {
        position: absolute;
        top: -10px;
        left: -10px;
        right: -10px;
        bottom: -10px;
        background: inherit;
        border-radius: 20px;
        filter: blur(15px);
        opacity: 0.6;
        z-index: -1;
    }
    
    .upgrade-card-content {
        position: relative;
        z-index: 1;
    }
    
    .upgrade-icon-container {
        position: relative;
        display: inline-block;
        margin-bottom: 15px;
    }
    
    .upgrade-icon-glow {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 80px;
        height: 80px;
        background: radial-gradient(circle, rgba(255,255,255,0.4), transparent);
        border-radius: 50%;
        animation: iconPulse 2s ease-in-out infinite;
    }
    
    .upgrade-rarity-badge {
        display: inline-block;
        padding: 4px 12px;
        background: rgba(0,0,0,0.7);
        border-radius: 15px;
        font-size: 0.8em;
        font-weight: bold;
        margin: 8px 0;
        border: 1px solid rgba(255,255,255,0.3);
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    
    .upgrade-particles {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        overflow: hidden;
    }
    
    .upgrade-particles::before,
    .upgrade-particles::after {
        content: '';
        position: absolute;
        width: 4px;
        height: 4px;
        background: rgba(255,255,255,0.8);
        border-radius: 50%;
        animation: particleFloat 3s linear infinite;
    }
    
    .upgrade-particles::before {
        left: 20%;
        animation-delay: 0.5s;
    }
    
    .upgrade-particles::after {
        left: 80%;
        animation-delay: 1.5s;
    }
    
    @keyframes upgradePopup {
        0% {
            transform: translate(-50%, -50%) scale(0) rotate(180deg);
            opacity: 0;
        }
        20% {
            transform: translate(-50%, -50%) scale(1.2) rotate(10deg);
            opacity: 1;
        }
        40% {
            transform: translate(-50%, -50%) scale(0.9) rotate(-5deg);
        }
        60% {
            transform: translate(-50%, -50%) scale(1.05) rotate(2deg);
        }
        80% {
            transform: translate(-50%, -50%) scale(1) rotate(0deg);
        }
        100% {
            transform: translate(-50%, -50%) scale(0.8) rotate(0deg);
            opacity: 0;
        }
    }
    
    @keyframes iconPulse {
        0%, 100% { opacity: 0.3; transform: translate(-50%, -50%) scale(1); }
        50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.2); }
    }
    
    @keyframes particleFloat {
        0% {
            transform: translateY(100px);
            opacity: 0;
        }
        10% {
            opacity: 1;
        }
        90% {
            opacity: 1;
        }
        100% {
            transform: translateY(-100px);
            opacity: 0;
        }
    }
    
    @keyframes epicGlow {
        from { box-shadow: 0 0 30px rgba(156, 39, 176, 0.5); }
        to { box-shadow: 0 0 40px rgba(156, 39, 176, 0.8); }
    }
    
    @keyframes ascensionGlow {
        from { box-shadow: 0 0 35px rgba(255, 152, 0, 0.6); }
        to { box-shadow: 0 0 50px rgba(255, 152, 0, 0.9); }
    }
`;

        document.head.appendChild(upgradeStyles);

    </script>
    <!-- cards -->
    <script>
        // cards.js - Sistema de cartas placeholder (para implementação futura)

        class Card {
            constructor(name, rarity, description, effect) {
                this.name = name;
                this.rarity = rarity; // 'common', 'uncommon', 'epic', 'ascension'
                this.description = description;
                this.effect = effect;
                this.stacks = 1;
                this.maxStacks = this.getMaxStacks();
            }

            getMaxStacks() {
                // Diferentes cartas têm diferentes limites de stack
                const stackLimits = {
                    'Catalisador': 20,
                    'Visão': 10,
                    'Crescimento': 15,
                    'Impulso': 8,
                    'Resistência': 20,
                    'Ressonância': 10,
                    'Veloz': 10
                };

                return stackLimits[this.name] || 5;
            }

            apply(player) {
                // Aplicar efeito da carta ao jogador
                if (typeof this.effect === 'function') {
                    this.effect(player, this.stacks);
                }
            }

            addStack() {
                if (this.stacks < this.maxStacks) {
                    this.stacks++;
                    return true;
                }
                return false;
            }

            getColor() {
                const colors = {
                    common: '#ffffff',
                    uncommon: '#4da6ff',
                    epic: '#9d4edd',
                    ascension: '#ffd700'
                };
                return colors[this.rarity] || colors.common;
            }

            getDisplayName() {
                return this.stacks > 1 ? `${this.name} (${this.stacks})` : this.name;
            }
        }

        class CardSystem extends EventEmitter {
            constructor() {
                super();

                this.cardDatabase = this.initializeCardDatabase();
                this.playerCards = [];
                this.cardChoices = [];
                this.isChoosingCard = false;
            }

            initializeCardDatabase() {
                return {
                    // Cartas Comuns
                    common: [
                        new Card('Catalisador', 'common', 'Dano de Projétil +2', (player, stacks) => {
                            player.damage += 2 * stacks;
                        }),
                        new Card('Visão', 'common', 'Chance crítica +5%', (player, stacks) => {
                            player.critChance += 0.05 * stacks;
                        }),
                        new Card('Crescimento', 'common', 'HP máximo +10', (player, stacks) => {
                            const oldMax = player.maxHp;
                            player.maxHp += 10 * stacks;
                            player.hp += player.maxHp - oldMax; // Heal por HP aumentado
                        }),
                        new Card('Impulso', 'common', 'Altura do Salto +30%', (player, stacks) => {
                            player.jumpHeight += player.jumpHeight * 0.3 * stacks;
                        }),
                        new Card('Renovar', 'common', 'Cura completa instantânea', (player, stacks) => {
                            player.heal(player.maxHp);
                        }),
                        new Card('Resistência', 'common', 'Redução de dano +4%', (player, stacks) => {
                            player.defense += 4 * stacks;
                        }),
                        new Card('Ressonância', 'common', 'Velocidade de Ataque +12%', (player, stacks) => {
                            player.attackSpeed += player.attackSpeed * 0.12 * stacks;
                        }),
                        new Card('Veloz', 'common', 'Velocidade de Movimento +20%', (player, stacks) => {
                            player.speed += player.speed * 0.2 * stacks;
                        })
                    ],

                    // Cartas Incomuns (placeholder)
                    uncommon: [
                        new Card('Catalisador+', 'uncommon', 'Dano de Projétil +4', (player, stacks) => {
                            player.damage += 4 * stacks;
                        }),
                        new Card('Carga', 'uncommon', 'Tamanho do Projétil +20%', (player, stacks) => {
                            player.projectileSize += player.projectileSize * 0.2 * stacks;
                        }),
                        new Card('Sanguessuga', 'uncommon', '3% de lifesteal em todo dano', (player, stacks) => {
                            // TODO: Implementar lifesteal
                        })
                    ],

                    // Cartas Épicas (placeholder)
                    epic: [
                        new Card('Imortal', 'epic', '+1 Vida extra (mata todos inimigos ao reviver)', (player, stacks) => {
                            // TODO: Implementar sistema de revive
                        })
                    ],

                    // Cartas de Ascensão (placeholder)
                    ascension: []
                };
            }

            // Oferecer escolha de cartas (placeholder)
            offerCardChoice(rarityWeights = { common: 0.7, uncommon: 0.25, epic: 0.045, ascension: 0.005 }) {
                if (this.isChoosingCard) return;

                this.isChoosingCard = true;
                this.cardChoices = this.generateCardChoices(3, rarityWeights);

                this.emit('cardChoiceOffered', this.cardChoices);
            }

            generateCardChoices(count, weights) {
                const choices = [];

                for (let i = 0; i < count; i++) {
                    const rarity = this.selectRarity(weights);
                    const availableCards = this.cardDatabase[rarity];

                    if (availableCards.length > 0) {
                        const randomCard = availableCards[Math.floor(Math.random() * availableCards.length)];
                        choices.push(this.cloneCard(randomCard));
                    }
                }

                return choices;
            }

            selectRarity(weights) {
                const rand = Math.random();
                let accumulated = 0;

                for (const [rarity, weight] of Object.entries(weights)) {
                    accumulated += weight;
                    if (rand <= accumulated) {
                        return rarity;
                    }
                }

                return 'common'; // fallback
            }

            cloneCard(card) {
                return new Card(card.name, card.rarity, card.description, card.effect);
            }

            chooseCard(cardIndex, player) {
                if (!this.isChoosingCard || cardIndex >= this.cardChoices.length) return false;

                const chosenCard = this.cardChoices[cardIndex];
                this.addCardToPlayer(chosenCard, player);

                this.isChoosingCard = false;
                this.cardChoices = [];

                this.emit('cardChosen', chosenCard);
                return true;
            }

            addCardToPlayer(card, player) {
                // Verificar se jogador já tem a carta
                const existingCard = this.playerCards.find(c => c.name === card.name);

                if (existingCard) {
                    // Adicionar stack se possível
                    if (existingCard.addStack()) {
                        this.emit('cardStacked', existingCard);
                    }
                } else {
                    // Adicionar nova carta
                    this.playerCards.push(card);
                    this.emit('cardAdded', card);
                }

                // Aplicar efeito da carta
                card.apply(player);
            }

            getPlayerCards() {
                return this.playerCards;
            }

            hasCard(cardName) {
                return this.playerCards.some(card => card.name === cardName);
            }

            getCardStacks(cardName) {
                const card = this.playerCards.find(c => c.name === cardName);
                return card ? card.stacks : 0;
            }

            // Sistema de Ascensão (verificar requisitos)
            checkAscensionRequirements() {
                const ascensionCards = [];

                // Verificar cada carta de ascensão
                const requirements = {
                    'Absorvente': { 'Manto': 4 },
                    'Antiaéreo': { 'Atrito': 10 },
                    'Vingador': { 'Fúria': 5 },
                    'Abençoado': { 'Sorte': 5 },
                    'Mago Sangrento': { 'Ferimento': 3 }
                    // ... mais requisitos
                };

                for (const [ascensionName, reqs] of Object.entries(requirements)) {
                    let canUnlock = true;

                    for (const [reqCard, reqStacks] of Object.entries(reqs)) {
                        if (this.getCardStacks(reqCard) < reqStacks) {
                            canUnlock = false;
                            break;
                        }
                    }

                    if (canUnlock && !this.hasCard(ascensionName)) {
                        ascensionCards.push(ascensionName);
                    }
                }

                return ascensionCards;
            }

            // Renderizar UI de cartas (placeholder)
            renderCardChoice(ctx, canvas) {
                if (!this.isChoosingCard) return;

                // Overlay escuro
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Título
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Escolha uma Carta', canvas.width / 2, 100);

                // Renderizar cartas
                const cardWidth = 150;
                const cardHeight = 200;
                const spacing = 20;
                const startX = (canvas.width - (cardWidth * this.cardChoices.length + spacing * (this.cardChoices.length - 1))) / 2;

                this.cardChoices.forEach((card, index) => {
                    const x = startX + index * (cardWidth + spacing);
                    const y = canvas.height / 2 - cardHeight / 2;

                    this.renderCard(ctx, card, x, y, cardWidth, cardHeight, index);
                });

                // Instruções
                ctx.fillStyle = '#aaaaaa';
                ctx.font = '16px Arial';
                ctx.fillText('Clique na carta desejada ou use as teclas 1, 2, 3', canvas.width / 2, canvas.height - 50);
            }

            renderCard(ctx, card, x, y, width, height, index) {
                // Background da carta
                ctx.fillStyle = '#2a2a3a';
                ctx.fillRect(x, y, width, height);

                // Borda baseada na raridade
                ctx.strokeStyle = card.getColor();
                ctx.lineWidth = 3;
                ctx.strokeRect(x, y, width, height);

                // Nome da carta
                ctx.fillStyle = card.getColor();
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(card.getDisplayName(), x + width / 2, y + 30);

                // Descrição (quebrar texto)
                ctx.fillStyle = '#ffffff';
                ctx.font = '12px Arial';
                this.wrapText(ctx, card.description, x + 10, y + 60, width - 20, 16);

                // Número da tecla
                ctx.fillStyle = '#ffff00';
                ctx.font = 'bold 16px Arial';
                ctx.fillText((index + 1).toString(), x + 20, y + 20);

                // Indicador de hover/click
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.strokeRect(x - 2, y - 2, width + 4, height + 4);
            }

            wrapText(ctx, text, x, y, maxWidth, lineHeight) {
                const words = text.split(' ');
                let line = '';
                let currentY = y;

                for (let n = 0; n < words.length; n++) {
                    const testLine = line + words[n] + ' ';
                    const metrics = ctx.measureText(testLine);
                    const testWidth = metrics.width;

                    if (testWidth > maxWidth && n > 0) {
                        ctx.fillText(line, x, currentY);
                        line = words[n] + ' ';
                        currentY += lineHeight;
                    } else {
                        line = testLine;
                    }
                }
                ctx.fillText(line, x, currentY);
            }

            // Handle input para escolha de carta
            handleCardChoiceInput(key) {
                if (!this.isChoosingCard) return false;

                const keyNum = parseInt(key);
                if (keyNum >= 1 && keyNum <= this.cardChoices.length) {
                    return keyNum - 1; // Retorna índice da carta
                }

                return -1;
            }

            // Cancelar escolha de carta
            cancelCardChoice() {
                this.isChoosingCard = false;
                this.cardChoices = [];
            }

            // Reset para novo jogo
            reset() {
                this.playerCards = [];
                this.cardChoices = [];
                this.isChoosingCard = false;
            }
        }

    </script>
    <!-- UI -->
    <script>
        // ui.js - Sistema de interface do usuário

        class UI extends EventEmitter {
            constructor() {
                super();

                // Verificar se os elementos básicos existem
                const requiredElements = {
                    gameHUD: 'gameHUD',
                    hpText: 'hpText',
                    waveText: 'waveText',
                    timerText: 'timerText',
                    soulOrbsText: 'soulOrbsText'
                };

                this.elements = {};

                // Verificar elementos um por um
                Object.entries(requiredElements).forEach(([key, id]) => {
                    const element = document.getElementById(id);
                    this.elements[key] = element;
                    if (!element) {
                        console.warn(`UI element not found: ${id}`);
                    }
                });

                // Elementos opcionais
                this.elements.hpFill = document.getElementById('hpFill');
                this.elements.mainMenu = document.getElementById('mainMenu');
                this.elements.pauseMenu = document.getElementById('pauseMenu');
                this.elements.mobileControls = document.getElementById('mobileControls');
                this.elements.joystick = document.getElementById('movementJoystick');
                this.elements.joystickKnob = document.getElementById('joystickKnob');

                try {
                    this.setupMobileControls();
                    this.setupAnimations();
                } catch (error) {
                    console.error('Error setting up UI:', error);
                }
            }

            setupMobileControls() {
                try {
                    if (!DeviceUtils.hasTouch()) return;

                    // Joystick virtual
                    this.setupVirtualJoystick();

                    // Botões de ação
                    this.setupActionButtons();
                } catch (error) {
                    console.error('Error setting up mobile controls:', error);
                }
            }

            setupVirtualJoystick() {
                const joystick = this.elements.joystick;
                const knob = this.elements.joystickKnob;

                // Verificar se os elementos existem antes de prosseguir
                if (!joystick || !knob) {
                    console.log('Joystick elements not found - skipping setup');
                    return;
                }

                // APENAS ativar o joystick em dispositivos móveis
                if (!DeviceUtils.isMobile()) {
                    console.log('Desktop detected - disabling virtual joystick');
                    joystick.style.display = 'none';
                    return; // Sair completamente se não for mobile
                }

                let isDragging = false;
                let joystickRect;
                let centerX, centerY;
                const maxDistance = 50; // Raio máximo do joystick

                const updateJoystickRect = () => {
                    try {
                        if (joystick && joystick.getBoundingClientRect) {
                            joystickRect = joystick.getBoundingClientRect();
                            centerX = joystickRect.width / 2;
                            centerY = joystickRect.height / 2;
                        } else {
                            // Valores padrão se não conseguir obter o rect
                            joystickRect = { left: 0, top: 0, width: 100, height: 100 };
                            centerX = 50;
                            centerY = 50;
                        }
                    } catch (error) {
                        console.warn('Error getting joystick rect:', error);
                        // Valores padrão em caso de erro
                        joystickRect = { left: 0, top: 0, width: 100, height: 100 };
                        centerX = 50;
                        centerY = 50;
                    }
                };

                const handleStart = (e) => {
                    e.preventDefault();
                    isDragging = true;
                    updateJoystickRect();
                    joystick.style.opacity = '1';
                    console.log('Joystick drag started (mobile only)');
                };

                const handleMove = (e) => {
                    if (!isDragging) return;
                    e.preventDefault();

                    // Obter posição do toque relativa ao joystick
                    const touch = e.touches ? e.touches[0] : e;
                    const rect = joystickRect;
                    const x = touch.clientX - rect.left - centerX;
                    const y = touch.clientY - rect.top - centerY;

                    // Calcular distância do centro
                    const distance = Math.sqrt(x * x + y * y);

                    // Limitar à área do joystick
                    let finalX = x;
                    let finalY = y;

                    if (distance > maxDistance) {
                        finalX = (x / distance) * maxDistance;
                        finalY = (y / distance) * maxDistance;
                    }

                    // Atualizar posição do knob
                    knob.style.transform = `translate(${finalX}px, ${finalY}px)`;

                    // Normalizar valores para -1 a 1
                    const normalizedX = finalX / maxDistance;
                    const normalizedY = finalY / maxDistance;

                    console.log('Joystick move (mobile):', { normalizedX, normalizedY });

                    // Emitir evento APENAS se for dispositivo móvel
                    this.emit('joystickMove', normalizedX, normalizedY);
                };

                const handleEnd = (e) => {
                    if (!isDragging) return;
                    e.preventDefault();

                    isDragging = false;

                    // Resetar posição do knob
                    knob.style.transform = 'translate(0px, 0px)';
                    joystick.style.opacity = '0.7';

                    console.log('Joystick drag ended (mobile only)');

                    // Emitir evento de parada APENAS se for dispositivo móvel
                    this.emit('joystickStop');
                };

                // Event listeners APENAS para touch (não mouse)
                joystick.addEventListener('touchstart', handleStart, { passive: false });
                joystick.addEventListener('touchmove', handleMove, { passive: false });
                joystick.addEventListener('touchend', handleEnd, { passive: false });
                joystick.addEventListener('touchcancel', handleEnd, { passive: false });

                // REMOVER completamente os event listeners de mouse
                // joystick.addEventListener('mousedown', handleStart);
                // document.addEventListener('mousemove', handleMove);
                // document.addEventListener('mouseup', handleEnd);

                // Inicializar
                updateJoystickRect();
                window.addEventListener('resize', updateJoystickRect);
            }

            setupActionButtons() {
                try {
                    const shootBtn = document.getElementById('shootBtn');
                    const jumpBtn = document.getElementById('jumpBtn');
                    const pauseBtn = document.getElementById('pauseBtn');

                    // Botão de tiro
                    if (shootBtn) {
                        const handleShootPress = (e) => {
                            console.log('Shoot button pressed');
                            e.preventDefault();
                            e.stopPropagation();
                            this.emit('mobileShootStart');
                            shootBtn.style.transform = 'scale(0.9)';
                            shootBtn.style.background = 'linear-gradient(135deg, #ff4444 0%, #ff6666 100%)';
                            shootBtn.style.boxShadow = '0 0 20px rgba(255, 68, 68, 0.6)';
                        };

                        const handleShootRelease = (e) => {
                            console.log('Shoot button released');
                            e.preventDefault();
                            e.stopPropagation();
                            this.emit('mobileShootStop');
                            shootBtn.style.transform = 'scale(1)';
                            shootBtn.style.background = '';
                            shootBtn.style.boxShadow = '';
                        };

                        shootBtn.addEventListener('touchstart', handleShootPress, { passive: false });
                        shootBtn.addEventListener('touchend', handleShootRelease, { passive: false });
                        shootBtn.addEventListener('touchcancel', handleShootRelease, { passive: false });
                        shootBtn.addEventListener('mousedown', handleShootPress);
                        shootBtn.addEventListener('mouseup', handleShootRelease);
                        shootBtn.addEventListener('mouseleave', handleShootRelease);
                    }

                    // Botão de pulo
                    if (jumpBtn) {
                        const handleJumpPress = (e) => {
                            console.log('Jump button pressed');
                            e.preventDefault();
                            e.stopPropagation();
                            this.emit('mobileJump');
                            jumpBtn.style.transform = 'scale(0.9)';
                            jumpBtn.style.background = 'linear-gradient(135deg, #66ff66 0%, #88ff88 100%)';
                            jumpBtn.style.boxShadow = '0 0 20px rgba(102, 255, 102, 0.6)';
                        };

                        const handleJumpRelease = (e) => {
                            console.log('Jump button released');
                            e.preventDefault();
                            e.stopPropagation();
                            jumpBtn.style.transform = 'scale(1)';
                            jumpBtn.style.background = '';
                            jumpBtn.style.boxShadow = '';
                        };

                        jumpBtn.addEventListener('touchstart', handleJumpPress, { passive: false });
                        jumpBtn.addEventListener('touchend', handleJumpRelease, { passive: false });
                        jumpBtn.addEventListener('touchcancel', handleJumpRelease, { passive: false });
                        jumpBtn.addEventListener('mousedown', handleJumpPress);
                        jumpBtn.addEventListener('mouseup', handleJumpRelease);
                        jumpBtn.addEventListener('mouseleave', handleJumpRelease);
                    }

                    // Botão de pausa
                    if (pauseBtn) {
                        pauseBtn.addEventListener('click', () => {
                            this.emit('pausePress');
                        });
                    }
                } catch (error) {
                    console.error('Error setting up action buttons:', error);
                }
            }

            setupAnimations() {
                // Animações suaves para mudanças de HP
                this.lastHpPercentage = 100;

                // Animação de pulso para soul orbs
                this.setupSoulOrbPulse();

                // Animação de shake para dano
                this.setupDamageShake();
            }

            setupSoulOrbPulse() {
                const soulOrbsElement = this.elements.soulOrbsText;
                let lastCount = 0;

                this.on('soulOrbCollected', (count) => {
                    if (count > lastCount && soulOrbsElement && soulOrbsElement.style) {
                        // Animação de pulso
                        soulOrbsElement.style.transform = 'scale(1.2)';
                        soulOrbsElement.style.color = '#66ffff';

                        setTimeout(() => {
                            if (soulOrbsElement && soulOrbsElement.style) {
                                soulOrbsElement.style.transform = 'scale(1)';
                                soulOrbsElement.style.color = '';
                            }
                        }, 200);
                    }
                    lastCount = count;
                });
            }

            setupDamageShake() {
                const hudElement = this.elements.gameHUD;

                this.on('playerDamaged', () => {
                    // Shake effect - verificar se elemento existe
                    if (hudElement && hudElement.style) {
                        hudElement.style.animation = 'shake 0.5s ease-in-out';

                        setTimeout(() => {
                            if (hudElement && hudElement.style) {
                                hudElement.style.animation = '';
                            }
                        }, 500);
                    }
                });
            }

            updateHP(hp, maxHp) {
                const percentage = (hp / maxHp) * 100;
                const hpFill = this.elements.hpFill;
                const hpText = this.elements.hpText;

                // Verificar se elementos existem antes de usar
                if (hpFill && hpFill.style) {
                    // Animação suave da barra de HP
                    hpFill.style.transition = 'width 0.3s ease';
                    hpFill.style.width = percentage + '%';

                    // Cores baseadas na porcentagem
                    if (percentage > 60) {
                        hpFill.style.background = 'linear-gradient(90deg, #4CAF50 0%, #66BB6A 50%, #4CAF50 100%)';
                    } else if (percentage > 30) {
                        hpFill.style.background = 'linear-gradient(90deg, #FF9800 0%, #FFB74D 50%, #FF9800 100%)';
                    } else {
                        hpFill.style.background = 'linear-gradient(90deg, #F44336 0%, #EF5350 50%, #F44336 100%)';

                        // Piscar quando HP baixo
                        if (percentage < 20) {
                            hpFill.style.animation = 'pulse 1s infinite';
                        } else {
                            hpFill.style.animation = '';
                        }
                    }
                }

                // Atualizar texto
                if (hpText) {
                    hpText.textContent = `${Math.ceil(hp)}/${maxHp}`;
                }

                // Trigger shake se HP diminuiu significativamente
                if (percentage < this.lastHpPercentage - 10) {
                    this.emit('playerDamaged');
                }

                this.lastHpPercentage = percentage;
            }

            updateWave(wave) {
                const waveText = this.elements.waveText;
                if (waveText) {
                    waveText.textContent = `Onda: ${wave}`;

                    // Animação ao trocar de onda
                    waveText.style.transform = 'scale(1.3)';
                    waveText.style.color = '#66ffff';

                    setTimeout(() => {
                        if (waveText && waveText.style) {
                            waveText.style.transform = 'scale(1)';
                            waveText.style.color = '';
                        }
                    }, 1000);
                }
            }

            updateTimer(gameTime) {
                const timerText = this.elements.timerText;
                if (timerText && typeof TimeUtils !== 'undefined' && TimeUtils.formatTime) {
                    timerText.textContent = TimeUtils.formatTime(gameTime);
                } else if (timerText) {
                    // Fallback se TimeUtils não estiver disponível
                    const minutes = Math.floor(gameTime / 60000);
                    const seconds = Math.floor((gameTime % 60000) / 1000);
                    timerText.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }
            }

            updateSoulOrbs(count) {
                const soulOrbsText = this.elements.soulOrbsText;
                if (soulOrbsText) {
                    const oldCount = parseInt(soulOrbsText.textContent.replace('Orbes: ', '')) || 0;

                    soulOrbsText.textContent = `Orbes: ${count}`;

                    if (count > oldCount) {
                        this.emit('soulOrbCollected', count);
                    }
                }
            }

            showNotification(message, type = 'info', duration = 3000) {
                // Criar elemento de notificação
                const notification = document.createElement('div');
                notification.className = `notification notification-${type}`;
                notification.textContent = message;

                // Estilos
                Object.assign(notification.style, {
                    position: 'fixed',
                    top: '20px',
                    right: '20px',
                    padding: '15px 20px',
                    borderRadius: '5px',
                    color: 'white',
                    fontWeight: 'bold',
                    zIndex: '1000',
                    opacity: '0',
                    transform: 'translateX(100%)',
                    transition: 'all 0.3s ease'
                });

                // Cores baseadas no tipo
                const colors = {
                    info: '#2196F3',
                    success: '#4CAF50',
                    warning: '#FF9800',
                    error: '#F44336'
                };

                notification.style.backgroundColor = colors[type] || colors.info;

                // Adicionar ao DOM
                document.body.appendChild(notification);

                // Animação de entrada
                setTimeout(() => {
                    notification.style.opacity = '1';
                    notification.style.transform = 'translateX(0)';
                }, 10);

                // Remover após duração
                setTimeout(() => {
                    notification.style.opacity = '0';
                    notification.style.transform = 'translateX(100%)';

                    setTimeout(() => {
                        if (notification.parentNode) {
                            notification.parentNode.removeChild(notification);
                        }
                    }, 300);
                }, duration);
            }

            showWaveStartNotification(wave) {
                this.showNotification(`Onda ${wave} iniciada!`, 'info', 2000);
            }

            showWaveCompleteNotification(wave) {
                this.showNotification(`Onda ${wave} completa!`, 'success', 2000);
            }

            showCriticalHitNotification() {
                // Criar efeito visual de crítico
                const criticalEffect = document.createElement('div');
                criticalEffect.textContent = 'CRÍTICO!';
                criticalEffect.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2em;
            font-weight: bold;
            color: #ffff00;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
            pointer-events: none;
            z-index: 1000;
            animation: criticalHit 1s ease-out forwards;
        `;

                document.body.appendChild(criticalEffect);

                setTimeout(() => {
                    if (criticalEffect.parentNode) {
                        criticalEffect.parentNode.removeChild(criticalEffect);
                    }
                }, 1000);
            }

            // Utility methods para show/hide elementos
            show(elementId) {
                const element = document.getElementById(elementId) || this.elements[elementId];
                if (element) {
                    element.classList.remove('hidden');
                    element.style.display = '';
                }
            }

            hide(elementId) {
                const element = document.getElementById(elementId) || this.elements[elementId];
                if (element) {
                    element.classList.add('hidden');
                    element.style.display = 'none';
                }
            }

            toggle(elementId) {
                const element = document.getElementById(elementId) || this.elements[elementId];
                if (element) {
                    element.classList.toggle('hidden');
                }
            }

            // Responsividade
            updateForMobile() {
                try {
                    if (DeviceUtils && DeviceUtils.isMobile && DeviceUtils.isMobile()) {
                        this.show('mobileControls');

                        // Ajustar tamanhos para mobile
                        const hud = this.elements.gameHUD;
                        if (hud && hud.style) {
                            hud.style.fontSize = '0.9em';
                        }

                        // Reorganizar elementos para landscape/portrait
                        this.adjustForOrientation();
                    } else {
                        this.hide('mobileControls');
                    }
                } catch (error) {
                    console.warn('Error in updateForMobile:', error);
                }
            }

            adjustForOrientation() {
                try {
                    const isLandscape = window.innerWidth > window.innerHeight;
                    const mobileControls = this.elements.mobileControls;

                    if (mobileControls) {
                        if (isLandscape) {
                            mobileControls.classList.add('landscape');
                        } else {
                            mobileControls.classList.remove('landscape');
                        }
                    }
                } catch (error) {
                    console.warn('Error in adjustForOrientation:', error);
                }
            }

            // Renderizar HUD diretamente no canvas com visual aprimorado
            renderHUD(ctx, player, gameInstance = null) {
                if (!player) return;

                const time = Date.now() * 0.001;
                const margin = 25;
                const barWidth = 250;
                const barHeight = 30;
                const spacing = 15;
                const cornerRadius = 15;

                // Configurar sombra para todo o HUD
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                // ====== BARRA DE HP ======
                const hpX = margin;
                const hpY = margin;
                const hpPercent = player.hp / player.maxHp;
                const hpFillWidth = barWidth * hpPercent;

                // Container principal da barra de HP
                this.drawRoundedRect(ctx, hpX - 3, hpY - 3, barWidth + 6, barHeight + 6, cornerRadius + 3);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fill();

                // Fundo da barra com gradiente
                this.drawRoundedRect(ctx, hpX, hpY, barWidth, barHeight, cornerRadius);
                const bgGradient = ctx.createLinearGradient(hpX, hpY, hpX, hpY + barHeight);
                bgGradient.addColorStop(0, 'rgba(40, 40, 40, 0.9)');
                bgGradient.addColorStop(0.5, 'rgba(60, 60, 60, 0.9)');
                bgGradient.addColorStop(1, 'rgba(30, 30, 30, 0.9)');
                ctx.fillStyle = bgGradient;
                ctx.fill();

                // Preenchimento da barra de HP com gradiente animado
                if (hpFillWidth > 0) {
                    this.drawRoundedRect(ctx, hpX, hpY, hpFillWidth, barHeight, cornerRadius);
                    
                    const hpGradient = ctx.createLinearGradient(hpX, hpY, hpX, hpY + barHeight);
                    if (hpPercent > 0.6) {
                        // Verde saudável
                        hpGradient.addColorStop(0, '#66ff66');
                        hpGradient.addColorStop(0.5, '#44cc44');
                        hpGradient.addColorStop(1, '#22aa22');
                    } else if (hpPercent > 0.3) {
                        // Amarelo/laranja de alerta
                        hpGradient.addColorStop(0, '#ffcc33');
                        hpGradient.addColorStop(0.5, '#ff9900');
                        hpGradient.addColorStop(1, '#cc6600');
                    } else {
                        // Vermelho crítico
                        hpGradient.addColorStop(0, '#ff6666');
                        hpGradient.addColorStop(0.5, '#ff3333');
                        hpGradient.addColorStop(1, '#cc0000');
                    }
                    ctx.fillStyle = hpGradient;
                    ctx.fill();

                    // Efeito de brilho pulsante se HP baixo
                    if (hpPercent <= 0.3) {
                        const pulse = Math.sin(time * 8) * 0.5 + 0.5;
                        ctx.globalAlpha = 0.3 + pulse * 0.4;
                        ctx.fillStyle = '#ff0000';
                        ctx.fill();
                        ctx.globalAlpha = 1;
                    }

                    // Efeito de luz no topo da barra
                    const lightGradient = ctx.createLinearGradient(hpX, hpY, hpX, hpY + barHeight * 0.3);
                    lightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.6)');
                    lightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = lightGradient;
                    ctx.fill();
                }

                // Borda da barra de HP
                this.drawRoundedRect(ctx, hpX, hpY, barWidth, barHeight, cornerRadius);
                ctx.strokeStyle = 'rgba(200, 200, 200, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Ícone de coração para HP
                this.drawHeartIcon(ctx, hpX - 25, hpY + barHeight / 2 - 8, 16);

                // Texto da HP com sombra
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 3;
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${player.hp} / ${player.maxHp}`, hpX + barWidth / 2, hpY + barHeight / 2 + 6);

                // ====== BARRA DE EXP ======
                const expX = margin;
                const expY = hpY + barHeight + spacing;
                const expPercent = player.exp / player.expToNext;
                const expFillWidth = barWidth * expPercent;

                // Container principal da barra de EXP
                this.drawRoundedRect(ctx, expX - 3, expY - 3, barWidth + 6, barHeight + 6, cornerRadius + 3);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fill();

                // Fundo da barra com gradiente
                this.drawRoundedRect(ctx, expX, expY, barWidth, barHeight, cornerRadius);
                const expBgGradient = ctx.createLinearGradient(expX, expY, expX, expY + barHeight);
                expBgGradient.addColorStop(0, 'rgba(20, 20, 60, 0.9)');
                expBgGradient.addColorStop(0.5, 'rgba(30, 30, 80, 0.9)');
                expBgGradient.addColorStop(1, 'rgba(15, 15, 50, 0.9)');
                ctx.fillStyle = expBgGradient;
                ctx.fill();

                // Preenchimento da barra de EXP com gradiente animado
                if (expFillWidth > 0) {
                    this.drawRoundedRect(ctx, expX, expY, expFillWidth, barHeight, cornerRadius);
                    
                    const expGradient = ctx.createLinearGradient(expX, expY, expX, expY + barHeight);
                    expGradient.addColorStop(0, '#66ddff');
                    expGradient.addColorStop(0.5, '#3399cc');
                    expGradient.addColorStop(1, '#006699');
                    ctx.fillStyle = expGradient;
                    ctx.fill();

                    // Efeito de animação na barra de EXP
                    const shimmer = Math.sin(time * 3) * 0.3 + 0.7;
                    ctx.globalAlpha = shimmer;
                    const shimmerGradient = ctx.createLinearGradient(expX, expY, expX + expFillWidth, expY);
                    shimmerGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                    shimmerGradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
                    shimmerGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = shimmerGradient;
                    ctx.fill();
                    ctx.globalAlpha = 1;

                    // Efeito de luz no topo da barra
                    const expLightGradient = ctx.createLinearGradient(expX, expY, expX, expY + barHeight * 0.3);
                    expLightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.5)');
                    expLightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = expLightGradient;
                    ctx.fill();
                }

                // Borda da barra de EXP
                this.drawRoundedRect(ctx, expX, expY, barWidth, barHeight, cornerRadius);
                ctx.strokeStyle = 'rgba(100, 180, 255, 0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Ícone de estrela para EXP
                this.drawStarIcon(ctx, expX - 25, expY + barHeight / 2 - 8, 16);

                // Texto do level em destaque
                ctx.fillStyle = '#ffdd44';
                ctx.font = 'bold 18px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`LVL ${player.level}`, expX + 10, expY + barHeight / 2 + 6);

                // Texto da EXP
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'right';
                ctx.fillText(`${player.exp} / ${player.expToNext}`, expX + barWidth - 10, expY + barHeight / 2 + 5);

                // ====== INFORMAÇÕES ADICIONAIS (Direita) ======
                const infoX = ctx.canvas.width - 280;
                const infoY = margin;
                const infoSpacing = 35;
                const infoBoxWidth = 250;
                const infoBoxHeight = 25;

                // Soul Orbs
                const soulOrbY = infoY;
                this.drawInfoBox(ctx, infoX, soulOrbY, infoBoxWidth, infoBoxHeight, '#663399', '#9966cc');
                this.drawSoulOrbIcon(ctx, infoX + 10, soulOrbY + infoBoxHeight / 2 - 8, 16);
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'left';
                ctx.fillText(`Soul Orbs: ${player.soulOrbs || 0}`, infoX + 35, soulOrbY + infoBoxHeight / 2 + 6);

                // Tempo de Jogo
                const timeY = soulOrbY + infoSpacing;
                const gameTime = gameInstance ? gameInstance.gameTime : 0;
                const minutes = Math.floor(gameTime / 60000);
                const seconds = Math.floor((gameTime % 60000) / 1000);
                const timeText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                this.drawInfoBox(ctx, infoX, timeY, infoBoxWidth, infoBoxHeight, '#336633', '#66cc66');
                this.drawClockIcon(ctx, infoX + 10, timeY + infoBoxHeight / 2 - 8, 16);
                ctx.fillStyle = '#ffffff';
                ctx.fillText(`Time: ${timeText}`, infoX + 35, timeY + infoBoxHeight / 2 + 6);

                // Onda Atual
                const waveY = timeY + infoSpacing;
                const currentWave = (gameInstance && gameInstance.enemySpawner) ? gameInstance.enemySpawner.currentWave : 1;
                
                this.drawInfoBox(ctx, infoX, waveY, infoBoxWidth, infoBoxHeight, '#cc3333', '#ff6666');
                this.drawWaveIcon(ctx, infoX + 10, waveY + infoBoxHeight / 2 - 8, 16);
                ctx.fillStyle = '#ffffff';
                ctx.fillText(`Wave: ${currentWave}`, infoX + 35, waveY + infoBoxHeight / 2 + 6);

                // Resetar configurações
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                ctx.textAlign = 'left';
                ctx.globalAlpha = 1;
            }

            // Método auxiliar para desenhar caixas de informação
            drawInfoBox(ctx, x, y, width, height, darkColor, lightColor) {
                const cornerRadius = 12;
                
                // Container com sombra
                this.drawRoundedRect(ctx, x - 2, y - 2, width + 4, height + 4, cornerRadius + 2);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fill();
                
                // Fundo com gradiente
                this.drawRoundedRect(ctx, x, y, width, height, cornerRadius);
                const gradient = ctx.createLinearGradient(x, y, x, y + height);
                gradient.addColorStop(0, lightColor);
                gradient.addColorStop(0.5, darkColor);
                gradient.addColorStop(1, darkColor);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Borda
                this.drawRoundedRect(ctx, x, y, width, height, cornerRadius);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Efeito de luz no topo
                const lightGradient = ctx.createLinearGradient(x, y, x, y + height * 0.3);
                lightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.4)');
                lightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                ctx.fillStyle = lightGradient;
                ctx.fill();
            }

            // Método auxiliar para desenhar retângulos com bordas arredondadas
            drawRoundedRect(ctx, x, y, width, height, radius) {
                ctx.beginPath();
                ctx.moveTo(x + radius, y);
                ctx.lineTo(x + width - radius, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                ctx.lineTo(x + width, y + height - radius);
                ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                ctx.lineTo(x + radius, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                ctx.lineTo(x, y + radius);
                ctx.quadraticCurveTo(x, y, x + radius, y);
                ctx.closePath();
            }

            // Ícone de coração para HP
            drawHeartIcon(ctx, x, y, size) {
                ctx.save();
                ctx.fillStyle = '#ff4444';
                
                const scale = size / 16;
                ctx.translate(x, y);
                ctx.scale(scale, scale);
                
                ctx.beginPath();
                ctx.moveTo(8, 16);
                ctx.bezierCurveTo(8, 16, 0, 8, 0, 4);
                ctx.bezierCurveTo(0, 0, 4, 0, 8, 4);
                ctx.bezierCurveTo(12, 0, 16, 0, 16, 4);
                ctx.bezierCurveTo(16, 8, 8, 16, 8, 16);
                ctx.fill();
                
                // Brilho no coração
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.beginPath();
                ctx.moveTo(6, 6);
                ctx.bezierCurveTo(4, 4, 2, 4, 2, 6);
                ctx.bezierCurveTo(2, 8, 6, 12, 6, 12);
                ctx.fill();
                
                ctx.restore();
            }

            // Ícone de estrela para EXP
            drawStarIcon(ctx, x, y, size) {
                ctx.save();
                ctx.fillStyle = '#ffdd44';
                
                const scale = size / 16;
                ctx.translate(x + size/2, y + size/2);
                ctx.scale(scale, scale);
                
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    const angle = (i * 144 - 90) * Math.PI / 180;
                    const outerRadius = 8;
                    const innerRadius = 3;
                    
                    const outerX = Math.cos(angle) * outerRadius;
                    const outerY = Math.sin(angle) * outerRadius;
                    
                    const innerAngle = angle + (72 * Math.PI / 180);
                    const innerX = Math.cos(innerAngle) * innerRadius;
                    const innerY = Math.sin(innerAngle) * innerRadius;
                    
                    if (i === 0) {
                        ctx.moveTo(outerX, outerY);
                    } else {
                        ctx.lineTo(outerX, outerY);
                    }
                    ctx.lineTo(innerX, innerY);
                }
                ctx.closePath();
                ctx.fill();
                
                // Brilho na estrela
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.moveTo(0, -6);
                ctx.lineTo(-2, -2);
                ctx.lineTo(-6, -2);
                ctx.lineTo(-3, 1);
                ctx.lineTo(-4, 5);
                ctx.lineTo(0, 3);
                ctx.fill();
                
                ctx.restore();
            }

            // Ícone de Soul Orb
            drawSoulOrbIcon(ctx, x, y, size) {
                ctx.save();
                const scale = size / 16;
                ctx.translate(x + size/2, y + size/2);
                ctx.scale(scale, scale);
                
                // Orbe principal
                const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 8);
                gradient.addColorStop(0, '#bb88ff');
                gradient.addColorStop(0.7, '#7755cc');
                gradient.addColorStop(1, '#443388');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Brilho
                ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.beginPath();
                ctx.arc(-3, -3, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }

            // Ícone de relógio
            drawClockIcon(ctx, x, y, size) {
                ctx.save();
                const scale = size / 16;
                ctx.translate(x + size/2, y + size/2);
                ctx.scale(scale, scale);
                
                // Corpo do relógio
                ctx.fillStyle = '#666666';
                ctx.beginPath();
                ctx.arc(0, 0, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Borda
                ctx.strokeStyle = '#cccccc';
                ctx.lineWidth = 1;
                ctx.stroke();
                
                // Ponteiros
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -5); // Ponteiro das horas
                ctx.moveTo(0, 0);
                ctx.lineTo(3, -3); // Ponteiro dos minutos
                ctx.stroke();
                
                ctx.restore();
            }

            // Ícone de onda
            drawWaveIcon(ctx, x, y, size) {
                ctx.save();
                const scale = size / 16;
                ctx.translate(x + size/2, y + size/2);
                ctx.scale(scale, scale);
                
                // Ondas
                ctx.strokeStyle = '#ff6666';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                // Primeira onda
                ctx.moveTo(-8, 0);
                ctx.quadraticCurveTo(-4, -4, 0, 0);
                ctx.quadraticCurveTo(4, 4, 8, 0);
                
                // Segunda onda
                ctx.moveTo(-8, 3);
                ctx.quadraticCurveTo(-4, -1, 0, 3);
                ctx.quadraticCurveTo(4, 7, 8, 3);
                
                ctx.stroke();
                
                ctx.restore();
            }

            // Criar modal base
            createModal(id, title) {
                // Remover modal existente se houver
                const existingModal = document.getElementById(id);
                if (existingModal) {
                    existingModal.remove();
                }

                const modal = document.createElement('div');
                modal.id = id;
                modal.className = 'modal-overlay';

                // Garantir que seja visível com estilos inline
                modal.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 1;
            visibility: visible;
        `;

                modal.innerHTML = `
            <div class="modal-content" style="
                background: #1a1a1a;
                border: 2px solid #333;
                border-radius: 10px;
                max-width: 90vw;
                max-height: 90vh;
                overflow-y: auto;
                color: white;
                position: relative;
                z-index: 10001;
            ">
                <div class="modal-header" style="
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    padding: 20px;
                    border-bottom: 1px solid #333;
                ">
                    <h2 style="margin: 0; color: white;">${title}</h2>
                    <button class="modal-close" style="
                        background: none;
                        border: none;
                        color: white;
                        font-size: 24px;
                        cursor: pointer;
                        padding: 5px;
                        line-height: 1;
                    ">&times;</button>
                </div>
                <div class="modal-body"></div>
            </div>
        `;

                // Adicionar modal ao DOM
                document.body.appendChild(modal);

                // Fechar modal
                modal.querySelector('.modal-close').addEventListener('click', () => {
                    this.closeModal(id);
                });

                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        this.closeModal(id);
                    }
                });

                console.log('Modal criado e adicionado ao DOM:', id); // Debug

                return modal.querySelector('.modal-body');
            }

            // Fechar modal
            closeModal(id) {
                const modal = document.getElementById(id);
                if (modal) {
                    modal.remove();
                }
            }

            // Fechar todos os modais
            closeAllModals() {
                // Lista de todos os modais possíveis
                const modals = ['ranking-modal', 'settings-modal', 'shop-modal'];
                modals.forEach(modalId => {
                    this.closeModal(modalId);
                });

                // Também remover qualquer modal genérico que possa existir
                const allModals = document.querySelectorAll('.modal-overlay');
                allModals.forEach(modal => {
                    if (modal && modal.parentNode) {
                        modal.parentNode.removeChild(modal);
                    }
                });

                // Fechar quaisquer overlays ou elementos flutuantes
                const overlays = document.querySelectorAll('[class*="overlay"]');
                overlays.forEach(overlay => {
                    if (overlay && overlay.parentNode && overlay.id !== 'gameCanvas') {
                        overlay.style.display = 'none';
                    }
                });
            }

            // Sistema de Ranking
            showRankingModal(rankings) {
                console.log('showRankingModal chamado com:', rankings); // Debug

                // CSS para o ranking PRIMEIRO
                this.addRankingStyles();

                const modalBody = this.createModal('ranking-modal', 'Ranking - Top 10');

                const content = document.createElement('div');
                content.className = 'ranking-content';
                content.style.cssText = `
            padding: 20px;
            color: white;
            min-height: 200px;
        `;

                if (rankings.length === 0) {
                    content.innerHTML = `
                <div class="no-rankings">
                    <p>Nenhuma pontuação registrada ainda.</p>
                    <p>Jogue para aparecer no ranking!</p>
                </div>
            `;
                } else {
                    const rankingList = document.createElement('div');
                    rankingList.className = 'ranking-list';

                    rankings.forEach((entry, index) => {
                        const rankItem = document.createElement('div');
                        rankItem.className = `rank-item ${index < 3 ? 'top-three' : ''}`;

                        // Gerar HTML das cartas da build
                        let buildHtml = '';
                        if (entry.build && entry.build.length > 0) {
                            buildHtml = `
                        <div class="rank-build">
                            <span class="build-label">Build:</span>
                            <div class="build-cards">
                                ${entry.build.map(card => `
                                    <span class="build-card ${card.rarity}" title="${card.description}">
                                        ${card.name}
                                    </span>
                                `).join('')}
                            </div>
                        </div>
                    `;
                        } else {
                            buildHtml = `
                        <div class="rank-build">
                            <span class="build-label">Build:</span>
                            <span class="no-build">Nenhuma carta escolhida</span>
                        </div>
                    `;
                        }

                        rankItem.innerHTML = `
                    <div class="rank-position">#${index + 1}</div>
                    <div class="rank-info">
                        <div class="rank-name">${entry.playerName}</div>
                        <div class="rank-stats">
                            <span class="score">${RankingSystem.formatScore(entry.score)} pts</span>
                            <span class="level">Nível ${entry.level}</span>
                            <span class="kills">${entry.enemiesKilled} mortes</span>
                            <span class="time">${RankingSystem.formatSurvivalTime(entry.survivalTime)}</span>
                        </div>
                        ${buildHtml}
                        <div class="rank-date">${entry.date}</div>
                    </div>
                `;
                        rankingList.appendChild(rankItem);
                    });

                    content.appendChild(rankingList);
                }

                // Botões
                const buttons = document.createElement('div');
                buttons.className = 'modal-buttons';
                buttons.style.cssText = `
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
            padding: 20px;
        `;
                buttons.innerHTML = `
            <button id="clearRankingBtn" class="btn-secondary" style="
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 16px;
                background: #757575;
                color: white;
            ">Limpar Ranking</button>
            <button id="closeRankingBtn" class="btn-primary" style="
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 16px;
                background: #4CAF50;
                color: white;
            ">Fechar</button>
        `;

                content.appendChild(buttons);
                modalBody.appendChild(content);

                // Event listeners
                document.getElementById('clearRankingBtn').addEventListener('click', () => {
                    if (confirm('Tem certeza que deseja limpar o ranking? Esta ação não pode ser desfeita.')) {
                        this.emit('clearRanking');
                        this.closeModal('ranking-modal');
                    }
                });

                document.getElementById('closeRankingBtn').addEventListener('click', () => {
                    this.closeModal('ranking-modal');
                });
            }

            // Sistema de Configurações
            showSettingsModal(settings) {
                console.log('showSettingsModal chamado com:', settings); // Debug

                // Validar e garantir valores padrão
                const validSettings = {
                    playerName: settings.playerName || 'Player',
                    audioEnabled: settings.audioEnabled !== false,
                    masterVolume: isNaN(settings.masterVolume) ? 0.7 : Math.max(0, Math.min(1, settings.masterVolume)),
                    sfxVolume: isNaN(settings.sfxVolume) ? 0.8 : Math.max(0, Math.min(1, settings.sfxVolume)),
                    xpMultiplier: isNaN(settings.xpMultiplier) ? 1.0 : Math.max(0.5, Math.min(5.0, settings.xpMultiplier))
                };

                console.log('Settings validados:', validSettings); // Debug

                // CSS para as configurações PRIMEIRO
                this.addSettingsStyles();

                const modalBody = this.createModal('settings-modal', 'Configurações');

                const content = document.createElement('div');
                content.className = 'settings-content';
                content.style.cssText = `
            padding: 20px;
            min-width: 400px;
            color: white;
        `;
                content.innerHTML = `
            <div class="setting-group">
                <label for="playerNameInput">Nome do Jogador:</label>
                <input type="text" id="playerNameInput" value="${validSettings.playerName}" maxlength="20" />
            </div>
            
            <div class="setting-group">
                <label for="audioToggle">Áudio:</label>
                <button id="audioToggle" class="toggle-btn ${validSettings.audioEnabled ? 'enabled' : 'disabled'}">
                    ${validSettings.audioEnabled ? 'ATIVADO' : 'DESATIVADO'}
                </button>
            </div>
            
            <div class="setting-group">
                <label for="masterVolumeSlider">Volume Geral:</label>
                <div class="slider-container">
                    <input type="range" id="masterVolumeSlider" min="0" max="1" step="0.1" value="${validSettings.masterVolume}" />
                    <span id="masterVolumeValue">${Math.round(validSettings.masterVolume * 100)}%</span>
                </div>
            </div>
            
            <div class="setting-group">
                <label for="sfxVolumeSlider">Volume dos Efeitos:</label>
                <div class="slider-container">
                    <input type="range" id="sfxVolumeSlider" min="0" max="1" step="0.1" value="${validSettings.sfxVolume}" />
                    <span id="sfxVolumeValue">${Math.round(validSettings.sfxVolume * 100)}%</span>
                </div>
            </div>
            
            <div class="setting-group">
                <label for="xpMultiplierSlider">Multiplicador de XP:</label>
                <div class="slider-container">
                    <input type="range" id="xpMultiplierSlider" min="0.5" max="5.0" step="0.5" value="${validSettings.xpMultiplier}" />
                    <span id="xpMultiplierValue">${validSettings.xpMultiplier}x</span>
                </div>
                <small class="setting-help">Aumenta a velocidade de ganho de experiência</small>
            </div>
            
            <div class="setting-group">
                <label>Soul Orbs (Debug):</label>
                <div class="soul-orbs-controls">
                    <input type="number" id="soulOrbsInput" min="0" max="99999" step="1" value="100" 
                           placeholder="Quantidade" style="width: 100px; margin-right: 10px;" />
                    <button id="addSoulOrbsBtn" class="btn-primary" style="
                        padding: 8px 16px;
                        border: none;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 14px;
                        background: #2196F3;
                        color: white;
                    ">Adicionar</button>
                    <button id="removeSoulOrbsBtn" class="btn-secondary" style="
                        padding: 8px 16px;
                        border: none;
                        border-radius: 5px;
                        cursor: pointer;
                        font-size: 14px;
                        background: #f44336;
                        color: white;
                        margin-left: 5px;
                    ">Remover</button>
                </div>
                <small class="setting-help">Para testes e desenvolvimento</small>
            </div>
        `;

                // Botões
                const buttons = document.createElement('div');
                buttons.className = 'modal-buttons';
                buttons.style.cssText = `
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
            padding: 20px;
        `;
                buttons.innerHTML = `
            <button id="resetSettingsBtn" class="btn-secondary" style="
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 16px;
                background: #757575;
                color: white;
            ">Restaurar Padrão</button>
            <button id="saveSettingsBtn" class="btn-primary" style="
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 16px;
                background: #4CAF50;
                color: white;
            ">Salvar</button>
            <button id="cancelSettingsBtn" class="btn-secondary" style="
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 16px;
                background: #757575;
                color: white;
            ">Cancelar</button>
        `;

                content.appendChild(buttons);
                modalBody.appendChild(content);

                // Event listeners para controles
                this.setupSettingsControls(validSettings);
            }
            setupSettingsControls(originalSettings) {
                const currentSettings = { ...originalSettings };

                console.log('setupSettingsControls chamado com:', currentSettings); // Debug

                // Toggle de áudio
                const audioToggle = document.getElementById('audioToggle');
                audioToggle.addEventListener('click', () => {
                    currentSettings.audioEnabled = !currentSettings.audioEnabled;
                    audioToggle.textContent = currentSettings.audioEnabled ? 'ATIVADO' : 'DESATIVADO';
                    audioToggle.className = `toggle-btn ${currentSettings.audioEnabled ? 'enabled' : 'disabled'}`;

                    // Aplicar mudança imediatamente
                    this.emit('audioToggled', currentSettings.audioEnabled);
                });

                // Sliders de volume
                const masterSlider = document.getElementById('masterVolumeSlider');
                const masterValue = document.getElementById('masterVolumeValue');
                masterSlider.addEventListener('input', () => {
                    const value = parseFloat(masterSlider.value);
                    if (!isNaN(value)) {
                        currentSettings.masterVolume = value;
                        masterValue.textContent = Math.round(value * 100) + '%';
                        this.emit('masterVolumeChanged', value);
                        this.emit('saveSettings'); // Salvar imediatamente
                    }
                });

                const sfxSlider = document.getElementById('sfxVolumeSlider');
                const sfxValue = document.getElementById('sfxVolumeValue');
                sfxSlider.addEventListener('input', () => {
                    const value = parseFloat(sfxSlider.value);
                    if (!isNaN(value)) {
                        currentSettings.sfxVolume = value;
                        sfxValue.textContent = Math.round(value * 100) + '%';
                        this.emit('sfxVolumeChanged', value);
                        this.emit('saveSettings'); // Salvar imediatamente
                    }
                });

                // Slider de multiplicador XP
                const xpSlider = document.getElementById('xpMultiplierSlider');
                const xpValue = document.getElementById('xpMultiplierValue');
                xpSlider.addEventListener('input', () => {
                    const value = parseFloat(xpSlider.value);
                    if (!isNaN(value)) {
                        currentSettings.xpMultiplier = value;
                        xpValue.textContent = value + 'x';
                        this.emit('xpMultiplierChanged', value);
                        this.emit('saveSettings'); // Salvar imediatamente
                    }
                });

                // Botões
                document.getElementById('resetSettingsBtn').addEventListener('click', () => {
                    if (confirm('Restaurar todas as configurações para o padrão?')) {
                        // Valores padrão
                        const defaultSettings = {
                            playerName: 'Player',
                            audioEnabled: true,
                            masterVolume: 0.7,
                            sfxVolume: 0.8,
                            xpMultiplier: 1.0
                        };

                        // Atualizar currentSettings
                        Object.assign(currentSettings, defaultSettings);

                        // Aplicar imediatamente
                        this.emit('audioToggled', defaultSettings.audioEnabled);
                        this.emit('masterVolumeChanged', defaultSettings.masterVolume);
                        this.emit('sfxVolumeChanged', defaultSettings.sfxVolume);

                        // Atualizar interface
                        document.getElementById('playerNameInput').value = defaultSettings.playerName;
                        document.getElementById('masterVolumeSlider').value = defaultSettings.masterVolume;
                        document.getElementById('masterVolumeValue').textContent = Math.round(defaultSettings.masterVolume * 100) + '%';
                        document.getElementById('sfxVolumeSlider').value = defaultSettings.sfxVolume;
                        document.getElementById('sfxVolumeValue').textContent = Math.round(defaultSettings.sfxVolume * 100) + '%';
                        document.getElementById('xpMultiplierSlider').value = defaultSettings.xpMultiplier;
                        document.getElementById('xpMultiplierValue').textContent = defaultSettings.xpMultiplier + 'x';

                        audioToggle.textContent = 'ATIVADO';
                        audioToggle.className = 'toggle-btn enabled';

                        this.emit('resetSettings');
                        this.closeModal('settings-modal');
                    }
                });

                // Botões de Soul Orbs
                document.getElementById('addSoulOrbsBtn').addEventListener('click', () => {
                    const amount = parseInt(document.getElementById('soulOrbsInput').value) || 100;
                    this.emit('addSoulOrbs', amount);
                });

                document.getElementById('removeSoulOrbsBtn').addEventListener('click', () => {
                    const amount = parseInt(document.getElementById('soulOrbsInput').value) || 100;
                    this.emit('removeSoulOrbs', amount);
                });

                document.getElementById('saveSettingsBtn').addEventListener('click', () => {
                    // Atualizar nome do jogador
                    const newName = document.getElementById('playerNameInput').value.trim() || 'Player';
                    currentSettings.playerName = newName;

                    console.log('Salvando configurações:', currentSettings); // Debug

                    this.emit('settingsSaved', currentSettings);
                    this.closeModal('settings-modal');
                });

                document.getElementById('cancelSettingsBtn').addEventListener('click', () => {
                    this.closeModal('settings-modal');
                });
            }

            // Adicionar estilos do ranking
            addRankingStyles() {
                if (document.getElementById('ranking-styles')) return;

                const style = document.createElement('style');
                style.id = 'ranking-styles';
                style.textContent = `
            .modal-overlay {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 1000;
            }
            
            .modal-content {
                background: #1a1a1a;
                border: 2px solid #333;
                border-radius: 10px;
                max-width: 600px;
                max-height: 80vh;
                overflow-y: auto;
                color: white;
            }
            
            .modal-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 20px;
                border-bottom: 1px solid #333;
            }
            
            .modal-close {
                background: none;
                border: none;
                color: white;
                font-size: 24px;
                cursor: pointer;
            }
            
            .ranking-content {
                padding: 20px;
            }
            
            .ranking-list {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }
            
            .rank-item {
                display: flex;
                align-items: center;
                padding: 15px;
                background: #222;
                border-radius: 8px;
                gap: 15px;
            }
            
            .rank-item.top-three {
                background: linear-gradient(135deg, #333, #444);
                border: 1px solid #555;
            }
            
            .rank-position {
                font-size: 24px;
                font-weight: bold;
                min-width: 40px;
                text-align: center;
            }
            
            .rank-item:nth-child(1) .rank-position { color: #ffd700; }
            .rank-item:nth-child(2) .rank-position { color: #c0c0c0; }
            .rank-item:nth-child(3) .rank-position { color: #cd7f32; }
            
            .rank-info {
                flex: 1;
            }
            
            .rank-name {
                font-size: 18px;
                font-weight: bold;
                margin-bottom: 5px;
            }
            
            .rank-stats {
                display: flex;
                gap: 15px;
                font-size: 14px;
                color: #ccc;
            }
            
            .rank-date {
                font-size: 12px;
                color: #888;
                margin-top: 5px;
            }
            
            .score { color: #4CAF50; }
            .level { color: #2196F3; }
            .kills { color: #FF5722; }
            .time { color: #FF9800; }
            
            .no-rankings {
                text-align: center;
                padding: 40px;
                color: #888;
            }
            
            .modal-buttons {
                display: flex;
                gap: 10px;
                justify-content: center;
                margin-top: 20px;
            }
            
            .btn-primary, .btn-secondary {
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 16px;
            }
            
            .btn-primary {
                background: #4CAF50;
                color: white;
            }
            
            .btn-secondary {
                background: #757575;
                color: white;
            }
            
            .new-record-popup {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
                border: 3px solid #ffd700;
                border-radius: 15px;
                padding: 30px;
                text-align: center;
                color: white;
                z-index: 1001;
                box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
                animation: recordPopup 0.5s ease-out;
            }
            
            @keyframes recordPopup {
                from {
                    opacity: 0;
                    transform: translate(-50%, -50%) scale(0.8);
                }
                to {
                    opacity: 1;
                    transform: translate(-50%, -50%) scale(1);
                }
            }
            
            .record-content h2 {
                color: #ffd700;
                margin-bottom: 20px;
                font-size: 32px;
            }
            
            .record-position {
                font-size: 24px;
                font-weight: bold;
                margin-bottom: 20px;
                color: #4CAF50;
            }
            
            .record-stats {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 15px;
                margin-bottom: 30px;
            }
            
            .stat {
                display: flex;
                flex-direction: column;
                align-items: center;
            }
            
            .stat-label {
                font-size: 14px;
                color: #ccc;
                margin-bottom: 5px;
            }
            
            .stat-value {
                font-size: 20px;
                font-weight: bold;
                color: white;
            }
            
            /* Estilos para Build/Cartas */
            .rank-build {
                margin-top: 8px;
                margin-bottom: 5px;
            }
            
            .build-label {
                font-size: 12px;
                color: #aaa;
                margin-right: 8px;
            }
            
            .build-cards {
                display: flex;
                flex-wrap: wrap;
                gap: 4px;
                margin-top: 4px;
            }
            
            .build-card {
                display: inline-block;
                padding: 2px 6px;
                border-radius: 4px;
                font-size: 11px;
                font-weight: bold;
                color: white;
                border: 1px solid transparent;
                cursor: help;
            }
            
            /* Cores por raridade das cartas */
            .build-card.common {
                background: #666;
                border-color: #888;
            }
            
            .build-card.uncommon {
                background: #2a7d32;
                border-color: #4caf50;
            }
            
            .build-card.epic {
                background: #7b1fa2;
                border-color: #9c27b0;
            }
            
            .build-card.legendary {
                background: #e65100;
                border-color: #ff9800;
            }
            
            .no-build {
                font-size: 11px;
                color: #666;
                font-style: italic;
            }
        `;

                document.head.appendChild(style);
            }

            // Adicionar estilos das configurações
            addSettingsStyles() {
                if (document.getElementById('settings-styles')) return;

                const style = document.createElement('style');
                style.id = 'settings-styles';
                style.textContent = `
            .settings-content {
                padding: 20px;
                min-width: 400px;
            }
            
            .setting-group {
                margin-bottom: 20px;
                display: flex;
                flex-direction: column;
                gap: 8px;
            }
            
            .setting-group label {
                font-weight: bold;
                color: #fff;
                font-size: 14px;
            }
            
            .setting-group input[type="text"] {
                padding: 8px 12px;
                border: 2px solid #333;
                border-radius: 5px;
                background: #222;
                color: white;
                font-size: 16px;
            }
            
            .setting-group input[type="text"]:focus {
                outline: none;
                border-color: #4CAF50;
            }
            
            .toggle-btn {
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.3s ease;
                font-size: 14px;
            }
            
            .toggle-btn.enabled {
                background: #4CAF50;
                color: white;
            }
            
            .toggle-btn.disabled {
                background: #757575;
                color: white;
            }
            
            .slider-container {
                display: flex;
                align-items: center;
                gap: 15px;
            }
            
            .slider-container input[type="range"] {
                flex: 1;
                height: 6px;
                border-radius: 3px;
                background: #333;
                outline: none;
                -webkit-appearance: none;
            }
            
            .slider-container input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 20px;
                height: 20px;
                border-radius: 50%;
                background: #4CAF50;
                cursor: pointer;
            }
            
            .slider-container input[type="range"]::-moz-range-thumb {
                width: 20px;
                height: 20px;
                border-radius: 50%;
                background: #4CAF50;
                cursor: pointer;
                border: none;
            }
            
            .slider-container span {
                min-width: 50px;
                text-align: right;
                color: #4CAF50;
                font-weight: bold;
            }
            
            .setting-help {
                color: #888;
                font-size: 12px;
                margin-top: 4px;
            }
            
            .soul-orbs-controls {
                display: flex;
                align-items: center;
                gap: 10px;
                flex-wrap: wrap;
            }
            
            .soul-orbs-controls input[type="number"] {
                padding: 8px 12px;
                border: 2px solid #333;
                border-radius: 5px;
                background: #222;
                color: white;
                font-size: 14px;
                min-width: 100px;
            }
            
            .soul-orbs-controls input[type="number"]:focus {
                outline: none;
                border-color: #2196F3;
            }
            
            .soul-orbs-controls button {
                transition: all 0.3s ease;
            }
            
            .soul-orbs-controls button:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            }
            
            @media (max-width: 600px) {
                .settings-content {
                    min-width: 300px;
                    padding: 15px;
                }
                
                .slider-container {
                    flex-direction: column;
                    align-items: stretch;
                    gap: 8px;
                }
                
                .slider-container span {
                    text-align: center;
                }
            }
        `;

                document.head.appendChild(style);
            }

            // Sistema de Loja de Equipamentos
            showShopModal(playerData, equipmentData) {
                console.log('showShopModal chamado com:', { playerData, equipmentData }); // Debug
                console.log('Equipamentos de cajados:', equipmentData ? equipmentData.staffs : 'equipmentData é null'); // Debug específico

                // Verificar se os dados necessários existem
                if (!equipmentData || !equipmentData.hats || !equipmentData.staffs) {
                    console.error('Dados de equipamentos inválidos:', equipmentData);
                    alert('Erro: Dados da loja não disponíveis. Tente novamente.');
                    return;
                }

                // Garantir que equipamentos padrão apareçam como equipados
                if (!playerData.equippedEquipment.hats) {
                    playerData.equippedEquipment.hats = 'wizardHat';
                }
                if (!playerData.equippedEquipment.staffs) {
                    playerData.equippedEquipment.staffs = 'wizardStaff';
                }

                // Garantir que equipamentos padrão apareçam como possuídos
                if (!playerData.ownedEquipment.hats.includes('wizardHat')) {
                    playerData.ownedEquipment.hats.push('wizardHat');
                }
                if (!playerData.ownedEquipment.staffs.includes('wizardStaff')) {
                    playerData.ownedEquipment.staffs.push('wizardStaff');
                }

                // CSS para a loja PRIMEIRO
                this.addShopStyles();

                const modalBody = this.createModal('shop-modal', 'Loja de Equipamentos');

                const content = document.createElement('div');
                content.className = 'shop-content';
                content.style.cssText = `
            padding: 20px;
            min-width: 600px;
            max-width: 1000px;
            color: white;
        `;

                // Header com Soul Orbs
                const shopHeader = document.createElement('div');
                shopHeader.className = 'shop-header';
                shopHeader.innerHTML = `
            <div class="soul-orbs-display">
                <span class="soul-orbs-icon">💎</span>
                <span class="soul-orbs-count">${playerData.soulOrbs || 0}</span>
                <span class="soul-orbs-label">Soul Orbs</span>
            </div>
        `;
                content.appendChild(shopHeader);

                // Abas da loja
                const shopTabs = document.createElement('div');
                shopTabs.className = 'shop-tabs';
                shopTabs.innerHTML = `
            <button class="shop-tab active" data-tab="hats">🎩 Chapéus</button>
            <button class="shop-tab" data-tab="staffs">🔮 Cajados</button>
        `;
                content.appendChild(shopTabs);

                // Conteúdo das abas
                const shopTabsContent = document.createElement('div');
                shopTabsContent.className = 'shop-tabs-content';

                // Aba de Chapéus
                const hatsTab = document.createElement('div');
                hatsTab.className = 'shop-tab-content active';
                hatsTab.id = 'hats-tab';
                hatsTab.appendChild(this.createEquipmentGrid('hats', equipmentData.hats, playerData));

                // Aba de Cajados
                const staffsTab = document.createElement('div');
                staffsTab.className = 'shop-tab-content';
                staffsTab.id = 'staffs-tab';
                staffsTab.appendChild(this.createEquipmentGrid('staffs', equipmentData.staffs, playerData));

                shopTabsContent.appendChild(hatsTab);
                shopTabsContent.appendChild(staffsTab);
                content.appendChild(shopTabsContent);

                // Botões
                const buttons = document.createElement('div');
                buttons.className = 'modal-buttons';
                buttons.style.cssText = `
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
            padding: 20px;
        `;
                buttons.innerHTML = `
            <button id="closeShopBtn" class="btn-primary" style="
                padding: 10px 20px;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-size: 16px;
                background: #4CAF50;
                color: white;
            ">Fechar Loja</button>
        `;
                content.appendChild(buttons);

                modalBody.appendChild(content);

                // Event listeners
                this.setupShopControls(playerData, equipmentData);
            }

            // Helper function to convert SVG ID to data URL for shop display
            svgIdToDataUrl(svgId) {
                if (!svgId) return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIGZpbGw9IiNjY2MiLz48L3N2Zz4='; // Default placeholder
                
                const svgElement = document.getElementById(svgId);
                if (!svgElement) {
                    console.warn('SVG element not found:', svgId);
                    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIGZpbGw9IiNjY2MiLz48L3N2Zz4=';
                }
                
                try {
                    // Clone the SVG element to avoid modifying the original
                    const clonedSvg = svgElement.cloneNode(true);
                    
                    // Create a temporary SVG container
                    const tempSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                    tempSvg.setAttribute('width', '64');
                    tempSvg.setAttribute('height', '64');
                    tempSvg.setAttribute('viewBox', '0 0 64 64');
                    tempSvg.appendChild(clonedSvg);
                    
                    // Convert to string and encode
                    const svgString = new XMLSerializer().serializeToString(tempSvg);
                    const encodedSvg = btoa(unescape(encodeURIComponent(svgString)));
                    return `data:image/svg+xml;base64,${encodedSvg}`;
                } catch (error) {
                    console.warn('Error converting SVG to data URL:', error);
                    return 'data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIHZpZXdCb3g9IjAgMCA2NCA2NCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iNjQiIGhlaWdodD0iNjQiIGZpbGw9IiNjY2MiLz48L3N2Zz4=';
                }
            }

            createEquipmentGrid(type, equipment, playerData) {
                const grid = document.createElement('div');
                grid.className = 'equipment-grid';

                // Verificar se os dados de equipamentos existem
                if (!equipment || typeof equipment !== 'object') {
                    console.warn('Dados de equipamentos inválidos para tipo:', type);
                    const noDataMsg = document.createElement('div');
                    noDataMsg.style.cssText = `
                padding: 40px;
                text-align: center;
                color: #888;
                font-size: 16px;
            `;
                    noDataMsg.textContent = `Nenhum equipamento ${type} disponível.`;
                    grid.appendChild(noDataMsg);
                    return grid;
                }

                Object.entries(equipment).forEach(([itemId, item]) => {
                    // Verificar se o item tem os dados necessários
                    if (!item || !item.name || typeof item.cost !== 'number') {
                        console.warn('Item de equipamento inválido:', itemId, item);
                        return;
                    }

                    const isOwned = playerData.ownedEquipment && playerData.ownedEquipment[type] &&
                        playerData.ownedEquipment[type].includes(itemId);
                    const isEquipped = playerData.equippedEquipment && playerData.equippedEquipment[type] === itemId;
                    const canAfford = (playerData.soulOrbs || 0) >= item.cost;

                    // Convert SVG ID to data URL for display
                    const imageDataUrl = this.svgIdToDataUrl(item.image);

                    const itemElement = document.createElement('div');
                    itemElement.className = `equipment-item ${isOwned ? 'owned' : ''} ${isEquipped ? 'equipped' : ''}`;
                    itemElement.innerHTML = `
                <div class="equipment-image">
                    <img src="${imageDataUrl}" alt="${item.name}" style="
                        max-width: 100%;
                        max-height: 100%;
                        object-fit: contain;
                        border-radius: 4px;
                        opacity: 1;
                    ">
                    ${isEquipped ? '<div class="equipped-badge">EQUIPADO</div>' : ''}
                </div>
                <div class="equipment-info">
                    <h3 class="equipment-name">${item.name}</h3>
                    <p class="equipment-description">${item.description || 'Sem descrição'}</p>
                    <div class="equipment-effects">
                        ${this.formatEquipmentEffects(item.effects || {})}
                    </div>
                    <div class="equipment-cost">
                        <span class="cost-icon">💎</span>
                        <span class="cost-value">${item.cost}</span>
                    </div>
                </div>
                <div class="equipment-actions">
                    ${this.createEquipmentActionButton(itemId, type, item, isOwned, isEquipped, canAfford)}
                </div>
            `;

                    grid.appendChild(itemElement);
                });

                return grid;
            }

            formatEquipmentEffects(effects) {
                const effectsHTML = [];

                Object.entries(effects).forEach(([key, value]) => {
                    let effectText = '';
                    let effectClass = '';

                    switch (key) {
                        case 'damage':
                            effectText = `+${value}% Dano`;
                            effectClass = 'damage-effect';
                            break;
                        case 'defense':
                            effectText = `+${value}% Defesa`;
                            effectClass = 'defense-effect';
                            break;
                        case 'speed':
                            effectText = `+${value}% Velocidade`;
                            effectClass = 'speed-effect';
                            break;
                        case 'critChance':
                            effectText = `+${value}% Chance Crítica`;
                            effectClass = 'crit-effect';
                            break;
                        case 'hp':
                            effectText = `+${value} HP`;
                            effectClass = 'hp-effect';
                            break;
                        case 'xpBonus':
                            effectText = `+${value}% XP`;
                            effectClass = 'xp-effect';
                            break;
                        case 'specialCooldown':
                            effectText = `-${value}% Cooldown Especial`;
                            effectClass = 'cooldown-effect';
                            break;
                        case 'fireRate':
                            effectText = `+${value}% Taxa de Tiro`;
                            effectClass = 'firerate-effect';
                            break;
                        default:
                            effectText = `${key}: ${value}`;
                            effectClass = 'generic-effect';
                    }

                    effectsHTML.push(`<div class="effect ${effectClass}">${effectText}</div>`);
                });

                return effectsHTML.join('');
            }

            createEquipmentActionButton(itemId, type, item, isOwned, isEquipped, canAfford) {
                if (isEquipped) {
                    return `<button class="equipment-btn equipped-btn" disabled>EQUIPADO</button>`;
                } else if (isOwned) {
                    return `<button class="equipment-btn equip-btn" data-action="equip" data-type="${type}" data-id="${itemId}">EQUIPAR</button>`;
                } else if (canAfford) {
                    return `<button class="equipment-btn buy-btn" data-action="buy" data-type="${type}" data-id="${itemId}">COMPRAR</button>`;
                } else {
                    return `<button class="equipment-btn disabled-btn" disabled>SEM ORBS</button>`;
                }
            }

            setupShopControls(playerData, equipmentData) {
                console.log('setupShopControls chamado com:', { playerData, equipmentData }); // Debug
                
                // Controle das abas
                const tabButtons = document.querySelectorAll('.shop-tab');
                const tabContents = document.querySelectorAll('.shop-tab-content');

                console.log('Configurando', tabButtons.length, 'botões de aba'); // Debug
                
                tabButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const tabId = button.dataset.tab;
                        console.log('Aba clicada:', tabId); // Debug

                        // Remover classe active de todas as abas
                        tabButtons.forEach(btn => btn.classList.remove('active'));
                        tabContents.forEach(content => content.classList.remove('active'));

                        // Ativar aba selecionada
                        button.classList.add('active');
                        document.getElementById(`${tabId}-tab`).classList.add('active');
                    });
                });

                // Controles de compra e equipar
                const equipmentButtons = document.querySelectorAll('.equipment-btn');
                console.log('Configurando', equipmentButtons.length, 'botões de equipamento'); // Debug
                
                equipmentButtons.forEach(button => {
                    button.addEventListener('click', (e) => {
                        const action = e.target.dataset.action;
                        const type = e.target.dataset.type;
                        const itemId = e.target.dataset.id;

                        console.log('Botão de equipamento clicado:', { action, type, itemId }); // Debug

                        if (action === 'buy') {
                            this.emit('buyEquipment', { type, itemId });
                        } else if (action === 'equip') {
                            this.emit('equipItem', { type, itemId });
                        }
                    });
                });

                // Botão fechar
                const closeBtn = document.getElementById('closeShopBtn');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => {
                        console.log('Botão fechar loja clicado'); // Debug
                        this.closeModal('shop-modal');
                    });
                }
            }

            // Atualizar loja após compra ou equipar
            updateShop(playerData, equipmentData) {
                console.log('updateShop chamado com:', { playerData, equipmentData }); // Debug
                
                const shopModal = document.getElementById('shop-modal');
                if (!shopModal) {
                    console.log('shopModal não encontrado'); // Debug
                    return;
                }

                // Atualizar contador de Soul Orbs
                const soulOrbsCount = shopModal.querySelector('.soul-orbs-count');
                if (soulOrbsCount) {
                    console.log('Atualizando Soul Orbs de', soulOrbsCount.textContent, 'para', playerData.soulOrbs); // Debug
                    soulOrbsCount.textContent = playerData.soulOrbs || 0;
                }

                // Recriar grids de equipamentos
                const hatsTab = document.getElementById('hats-tab');
                const staffsTab = document.getElementById('staffs-tab');

                if (hatsTab) {
                    console.log('Atualizando aba de chapéus'); // Debug
                    hatsTab.innerHTML = '';
                    hatsTab.appendChild(this.createEquipmentGrid('hats', equipmentData.hats, playerData));
                }

                if (staffsTab) {
                    console.log('Atualizando aba de cajados'); // Debug
                    staffsTab.innerHTML = '';
                    staffsTab.appendChild(this.createEquipmentGrid('staffs', equipmentData.staffs, playerData));
                }

                // Reconfigurar event listeners
                console.log('Reconfigurando event listeners da loja'); // Debug
                this.setupShopControls(playerData, equipmentData);
            }

            // Método para atualizar a loja dinamicamente após compra/equipar
            updateShopDisplay() {
                // Verificar se a loja está aberta
                const shopModal = document.getElementById('shop-modal');
                if (!shopModal) return;

                // Obter player do game instance global
                if (!window.game || !window.game.player) {
                    console.warn('Game ou player não existe durante updateShopDisplay');
                    return;
                }
                
                const player = window.game.player;

                // Garantir estruturas de equipamentos do player
                if (!player.ownedEquipment) {
                    player.ownedEquipment = { hats: ['wizardHat'], staffs: ['wizardStaff'] };
                }
                if (!player.equippedEquipment) {
                    player.equippedEquipment = { hats: 'wizardHat', staffs: 'wizardStaff' };
                }

                // Preparar dados atualizados do player
                const playerData = {
                    soulOrbs: player.soulOrbs || 0,
                    ownedEquipment: player.ownedEquipment,
                    equippedEquipment: player.equippedEquipment
                };

                // Obter dados dos equipamentos
                const equipmentData = {
                    hats: HAT_DEFINITIONS,
                    staffs: STAFF_DEFINITIONS
                };

                // Chamar o método updateShop existente
                this.updateShop(playerData, equipmentData);
            }

            // Adicionar estilos da loja
            addShopStyles() {
                if (document.getElementById('shop-styles')) return;

                const style = document.createElement('style');
                style.id = 'shop-styles';
                style.textContent = `
            .shop-content {
                padding: 20px;
                min-width: 800px;
                max-width: 1000px;
            }
            
            .shop-header {
                display: flex;
                justify-content: center;
                margin-bottom: 20px;
                padding: 15px;
                background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
                border-radius: 10px;
                border: 2px solid #333;
            }
            
            .soul-orbs-display {
                display: flex;
                align-items: center;
                gap: 10px;
                font-size: 18px;
                font-weight: bold;
            }
            
            .soul-orbs-icon {
                font-size: 24px;
                filter: drop-shadow(0 0 5px rgba(102, 255, 255, 0.5));
            }
            
            .soul-orbs-count {
                color: #66ffff;
                font-size: 24px;
            }
            
            .soul-orbs-label {
                color: #ccc;
            }
            
            .shop-tabs {
                display: flex;
                gap: 5px;
                margin-bottom: 20px;
                border-bottom: 2px solid #333;
            }
            
            .shop-tab {
                padding: 12px 24px;
                background: #222;
                border: none;
                border-radius: 8px 8px 0 0;
                color: #ccc;
                cursor: pointer;
                font-size: 16px;
                font-weight: bold;
                transition: all 0.3s ease;
            }
            
            .shop-tab:hover {
                background: #333;
                color: white;
            }
            
            .shop-tab.active {
                background: #4CAF50;
                color: white;
                border-bottom: 2px solid #4CAF50;
            }
            
            .shop-tabs-content {
                min-height: 400px;
            }
            
            .shop-tab-content {
                display: none;
            }
            
            .shop-tab-content.active {
                display: block;
            }
            
            .equipment-grid {
                display: grid;
                grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
                gap: 20px;
                padding: 20px;
            }
            
            .equipment-item {
                background: #222;
                border: 2px solid #333;
                border-radius: 12px;
                padding: 15px;
                transition: all 0.3s ease;
                position: relative;
                overflow: hidden;
            }
            
            .equipment-item:hover {
                border-color: #555;
                transform: translateY(-2px);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            }
            
            .equipment-item.owned {
                border-color: #4CAF50;
                background: linear-gradient(135deg, #222, #2a2a2a);
            }
            
            .equipment-item.equipped {
                border-color: #ffd700;
                background: linear-gradient(135deg, #2a2a2a, #333);
                box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
            }
            
            .equipment-image {
                position: relative;
                width: 100%;
                height: 120px;
                margin-bottom: 15px;
                background: #1a1a1a;
                border-radius: 8px;
                overflow: hidden;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            .equipment-image img {
                max-width: 100%;
                max-height: 100%;
                object-fit: contain;
                border-radius: 4px;
            }
            
            .equipped-badge {
                position: absolute;
                top: 5px;
                right: 5px;
                background: #ffd700;
                color: #000;
                padding: 4px 8px;
                border-radius: 4px;
                font-size: 10px;
                font-weight: bold;
            }
            
            .equipment-info {
                margin-bottom: 15px;
            }
            
            .equipment-name {
                font-size: 18px;
                font-weight: bold;
                color: white;
                margin-bottom: 8px;
            }
            
            .equipment-description {
                font-size: 14px;
                color: #ccc;
                margin-bottom: 12px;
                line-height: 1.4;
            }
            
            .equipment-effects {
                display: flex;
                flex-direction: column;
                gap: 4px;
                margin-bottom: 12px;
            }
            
            .effect {
                font-size: 12px;
                padding: 2px 6px;
                border-radius: 4px;
                font-weight: bold;
            }
            
            .damage-effect { background: #f44336; color: white; }
            .defense-effect { background: #2196f3; color: white; }
            .speed-effect { background: #4caf50; color: white; }
            .crit-effect { background: #ff9800; color: white; }
            .hp-effect { background: #e91e63; color: white; }
            .xp-effect { background: #9c27b0; color: white; }
            .cooldown-effect { background: #00bcd4; color: white; }
            .firerate-effect { background: #795548; color: white; }
            .generic-effect { background: #607d8b; color: white; }
            
            .equipment-cost {
                display: flex;
                align-items: center;
                gap: 5px;
                font-size: 16px;
                font-weight: bold;
                color: #66ffff;
                margin-bottom: 15px;
            }
            
            .cost-icon {
                font-size: 18px;
            }
            
            .equipment-actions {
                display: flex;
                justify-content: center;
            }
            
            .equipment-btn {
                padding: 10px 20px;
                border: none;
                border-radius: 6px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.3s ease;
                font-size: 14px;
                min-width: 100px;
            }
            
            .buy-btn {
                background: #4CAF50;
                color: white;
            }
            
            .buy-btn:hover {
                background: #45a049;
                transform: scale(1.05);
            }
            
            .equip-btn {
                background: #2196F3;
                color: white;
            }
            
            .equip-btn:hover {
                background: #1976D2;
                transform: scale(1.05);
            }
            
            .equipped-btn {
                background: #ffd700;
                color: #000;
                cursor: default;
            }
            
            .disabled-btn {
                background: #666;
                color: #999;
                cursor: not-allowed;
            }
            
            @media (max-width: 1000px) {
                .shop-content {
                    min-width: 600px;
                    padding: 15px;
                }
                
                .equipment-grid {
                    grid-template-columns: repeat(auto-fill, minmax(240px, 1fr));
                    gap: 15px;
                    padding: 15px;
                }
            }
            
            @media (max-width: 700px) {
                .shop-content {
                    min-width: 400px;
                    padding: 10px;
                }
                
                .equipment-grid {
                    grid-template-columns: 1fr;
                    gap: 15px;
                    padding: 10px;
                }
                
                .shop-tabs {
                    justify-content: center;
                }
                
                .shop-tab {
                    padding: 10px 16px;
                    font-size: 14px;
                }
            }
        `;

                document.head.appendChild(style);
            }

            // Hide the game UI elements (HUD, mobile controls, etc.)
            hideUI() {
                if (this.elements.gameHUD) {
                    this.elements.gameHUD.style.display = 'none';
                }
                if (this.elements.mobileControls) {
                    this.elements.mobileControls.style.display = 'none';
                }
            }

            // Show the game UI elements (HUD, mobile controls, etc.)
            showUI() {
                if (this.elements.gameHUD) {
                    this.elements.gameHUD.style.display = 'block';
                }
                if (this.elements.mobileControls) {
                    // Verificar se é dispositivo móvel de forma simples
                    const isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
                    if (isMobile) {
                        this.elements.mobileControls.style.display = 'flex';
                    }
                }
            }

            // Show new record popup notification
            showNewRecordPopup(position, entry) {
                const popup = document.createElement('div');
                popup.className = 'new-record-popup';
                popup.innerHTML = `
            <div class="popup-content">
                <h3>🏆 NOVO RECORDE! 🏆</h3>
                <p>Posição #${position} no ranking!</p>
                <p><strong>${entry.playerName}</strong></p>
                <p>Pontuação: ${RankingSystem.formatScore(entry.score)}</p>
                <button class="popup-close-btn">OK</button>
            </div>
        `;

                // Adicionar estilos inline
                popup.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: fadeIn 0.3s ease-in;
        `;

                const popupContent = popup.querySelector('.popup-content');
                popupContent.style.cssText = `
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            border: 3px solid #FFD700;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            color: white;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            max-width: 400px;
            animation: popIn 0.5s ease-out;
        `;

                // Adicionar estilos para animação se não existir
                if (!document.getElementById('popup-animations')) {
                    const style = document.createElement('style');
                    style.id = 'popup-animations';
                    style.textContent = `
                @keyframes fadeIn {
                    from { opacity: 0; }
                    to { opacity: 1; }
                }
                @keyframes popIn {
                    0% { transform: scale(0.7) translateY(-50px); opacity: 0; }
                    50% { transform: scale(1.05) translateY(0); opacity: 1; }
                    100% { transform: scale(1) translateY(0); opacity: 1; }
                }
                .popup-close-btn {
                    background: linear-gradient(135deg, #4CAF50, #45a049);
                    color: white;
                    border: none;
                    padding: 10px 20px;
                    border-radius: 5px;
                    cursor: pointer;
                    font-size: 16px;
                    font-weight: bold;
                    margin-top: 15px;
                    transition: all 0.3s ease;
                }
                .popup-close-btn:hover {
                    background: linear-gradient(135deg, #45a049, #4CAF50);
                    transform: translateY(-2px);
                }
            `;
                    document.head.appendChild(style);
                }

                // Adicionar ao DOM
                document.body.appendChild(popup);

                // Event listener para fechar
                popup.querySelector('.popup-close-btn').addEventListener('click', () => {
                    popup.remove();
                });

                // Fechar automaticamente após 5 segundos
                setTimeout(() => {
                    if (popup.parentNode) {
                        popup.remove();
                    }
                }, 5000);

                console.log('New record popup mostrado:', { position, entry });
            }
        }

        // Input Manager - Gerencia todos os tipos de input
        class InputManager extends EventEmitter {
            constructor() {
                super();

                this.keys = {};
                this.setupKeyboardInput();
                this.setupTouchInput();
            }

            setupKeyboardInput() {
                document.addEventListener('keydown', (e) => {
                    if (!this.keys[e.key]) {
                        this.keys[e.key] = true;
                        this.emit('keyDown', e.key);
                    }
                });

                document.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                    this.emit('keyUp', e.key);
                });

                // Prevenir ações padrão em certas teclas
                document.addEventListener('keydown', (e) => {
                    if ([' ', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                        e.preventDefault();
                    }
                });
            }

            setupTouchInput() {
                // Prevenir zoom duplo toque
                let lastTouchEnd = 0;
                document.addEventListener('touchend', (e) => {
                    const now = (new Date()).getTime();
                    if (now - lastTouchEnd <= 300) {
                        e.preventDefault();
                    }
                    lastTouchEnd = now;
                }, false);

                // Prevenir scroll em dispositivos móveis
                document.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                }, { passive: false });
            }

            isKeyPressed(keyCode) {
                return !!this.keys[keyCode];
            }

            // Métodos de conveniência
            isMovingLeft() {
                return this.isKeyPressed('a') || this.isKeyPressed('A') || this.isKeyPressed('ArrowLeft');
            }

            isMovingRight() {
                return this.isKeyPressed('d') || this.isKeyPressed('D') || this.isKeyPressed('ArrowRight');
            }

            isMovingUp() {
                return this.isKeyPressed('w') || this.isKeyPressed('W') || this.isKeyPressed('ArrowUp');
            }

            isMovingDown() {
                return this.isKeyPressed('s') || this.isKeyPressed('S') || this.isKeyPressed('ArrowDown');
            }

            isJumping() {
                return this.isKeyPressed(' ');
            }
        }

        // Adicionar estilos CSS para animações via JavaScript
        const style = document.createElement('style');
        style.textContent = `
    @keyframes shake {
        0%, 100% { transform: translateX(0); }
        25% { transform: translateX(-5px); }
        75% { transform: translateX(5px); }
    }
    
    @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
    }
    
    @keyframes criticalHit {
        0% {
            transform: translate(-50%, -50%) scale(0.5);
            opacity: 1;
        }
        50% {
            transform: translate(-50%, -50%) scale(1.2);
            opacity: 1;
        }
        100% {
            transform: translate(-50%, -50%) scale(1.5);
            opacity: 0;
        }
    }
    
    .landscape .mobile-buttons {
        flex-direction: row !important;
        gap: 10px !important;
    }
    
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 1000;
    }
    
    .modal-content {
        background: #1a1a1a;
        border: 2px solid #333;
        border-radius: 10px;
        max-width: 600px;
        max-height: 80vh;
        overflow-y: auto;
        color: white;
    }
    
    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 20px;
        border-bottom: 1px solid #333;
    }
    
    .modal-close {
        background: none;
        border: none;
        color: white;
        font-size: 24px;
        cursor: pointer;
    }
    
    .ranking-content {
        padding: 20px;
    }
    
    .ranking-list {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
    
    .rank-item {
        display: flex;
        align-items: center;
        padding: 15px;
        background: #222;
        border-radius: 8px;
        gap: 15px;
    }
    
    .rank-item.top-three {
        background: linear-gradient(135deg, #333, #444);
        border: 1px solid #555;
    }
    
    .rank-position {
        font-size: 24px;
        font-weight: bold;
        min-width: 40px;
        text-align: center;
    }
    
    .rank-item:nth-child(1) .rank-position { color: #ffd700; }
    .rank-item:nth-child(2) .rank-position { color: #c0c0c0; }
    .rank-item:nth-child(3) .rank-position { color: #cd7f32; }
    
    .rank-info {
        flex: 1;
    }
    
    .rank-name {
        font-size: 18px;
        font-weight: bold;
        margin-bottom: 5px;
    }
    
    .rank-stats {
        display: flex;
        gap: 15px;
        font-size: 14px;
        color: #ccc;
    }
    
    .rank-date {
        font-size: 12px;
        color: #888;
        margin-top: 5px;
    }
    
    .score { color: #4CAF50; }
    .level { color: #2196F3; }
    .kills { color: #FF5722; }
    .time { color: #FF9800; }
    
    .no-rankings {
        text-align: center;
        padding: 40px;
        color: #888;
    }
    
    .modal-buttons {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin-top: 20px;
    }
    
    .btn-primary, .btn-secondary {
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 16px;
    }
    
    .btn-primary {
        background: #4CAF50;
        color: white;
    }
    
    .btn-secondary {
        background: #757575;
        color: white;
    }
    
    .new-record-popup {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
        border: 3px solid #ffd700;
        border-radius: 15px;
        padding: 30px;
        text-align: center;
        color: white;
        z-index: 1001;
        box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
        animation: recordPopup 0.5s ease-out;
    }
    
    @keyframes recordPopup {
        from {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.8);
        }
        to {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }
    }
    
    .record-content h2 {
        color: #ffd700;
        margin-bottom: 20px;
        font-size: 32px;
    }
    
    .record-position {
        font-size: 24px;
        font-weight: bold;
        margin-bottom: 20px;
        color: #4CAF50;
    }
    
    .record-stats {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 15px;
        margin-bottom: 30px;
    }
    
    .stat {
        display: flex;
        flex-direction: column;
        align-items: center;
    }
    
    .stat-label {
        font-size: 14px;
        color: #ccc;
        margin-bottom: 5px;
    }
    
    .stat-value {
        font-size: 20px;
        font-weight: bold;
        color: white;
    }
    
    .settings-content {
        padding: 20px;
        min-width: 400px;
    }
    
    .setting-group {
        margin-bottom: 20px;
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    
    .setting-group label {
        font-weight: bold;
        color: #fff;
        font-size: 14px;
    }
    
    .setting-group input[type="text"] {
        padding: 8px 12px;
        border: 2px solid #333;
        border-radius: 5px;
        background: #222;
        color: white;
        font-size: 16px;
    }
    
    .setting-group input[type="text"]:focus {
        outline: none;
        border-color: #4CAF50;
    }
    
    .toggle-btn {
        padding: 10px 20px;
        border: none;
        border-radius: 5px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 14px;
    }
    
    .toggle-btn.enabled {
        background: #4CAF50;
        color: white;
    }
    
    .toggle-btn.disabled {
        background: #757575;
        color: white;
    }
    
    .slider-container {
        display: flex;
        align-items: center;
        gap: 15px;
    }
    
    .slider-container input[type="range"] {
        flex: 1;
        height: 6px;
        border-radius: 3px;
        background: #333;
        outline: none;
        -webkit-appearance: none;
    }
    
    .slider-container input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #4CAF50;
        cursor: pointer;
    }
    
    .slider-container input[type="range"]::-moz-range-thumb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: #4CAF50;
        cursor: pointer;
        border: none;
    }
    
    .slider-container span {
        min-width: 50px;
        text-align: right;
        color: #4CAF50;
        font-weight: bold;
    }
    
    .setting-help {
        color: #888;
        font-size: 12px;
        margin-top: 4px;
    }
    
    @media (max-width: 600px) {
        .settings-content {
            min-width: 300px;
            padding: 15px;
        }
        
        .slider-container {
            flex-direction: column;
            align-items: stretch;
            gap: 8px;
        }
        
        .slider-container span {
            text-align: center;
        }
    }
    
    .shop-content {
        padding: 20px;
        min-width: 800px;
        max-width: 1000px;
    }
    
    .shop-header {
        display: flex;
        justify-content: center;
        margin-bottom: 20px;
        padding: 15px;
        background: linear-gradient(135deg, #2a2a2a, #1a1a1a);
        border-radius: 10px;
        border: 2px solid #333;
    }
    
    .soul-orbs-display {
        display: flex;
        align-items: center;
        gap: 10px;
        font-size: 18px;
        font-weight: bold;
    }
    
    .soul-orbs-icon {
        font-size: 24px;
        filter: drop-shadow(0 0 5px rgba(102, 255, 255, 0.5));
    }
    
    .soul-orbs-count {
        color: #66ffff;
        font-size: 24px;
    }
    
    .soul-orbs-label {
        color: #ccc;
    }
    
    .shop-tabs {
        display: flex;
        gap: 5px;
        margin-bottom: 20px;
        border-bottom: 2px solid #333;
    }
    
    .shop-tab {
        padding: 12px 24px;
        background: #222;
        border: none;
        border-radius: 8px 8px 0 0;
        color: #ccc;
        cursor: pointer;
        font-size: 16px;
        font-weight: bold;
        transition: all 0.3s ease;
    }
    
    .shop-tab:hover {
        background: #333;
        color: white;
    }
    
    .shop-tab.active {
        background: #4CAF50;
        color: white;
        border-bottom: 2px solid #4CAF50;
    }
    
    .shop-tabs-content {
        min-height: 400px;
    }
    
    .shop-tab-content {
        display: none;
    }
    
    .shop-tab-content.active {
        display: block;
    }
    
    .equipment-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 20px;
        padding: 20px;
    }
    
    .equipment-item {
        background: #222;
        border: 2px solid #333;
        border-radius: 12px;
        padding: 15px;
        transition: all 0.3s ease;
        position: relative;
        overflow: hidden;
    }
    
    .equipment-item:hover {
        border-color: #555;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }
    
    .equipment-item.owned {
        border-color: #4CAF50;
        background: linear-gradient(135deg, #222, #2a2a2a);
    }
    
    .equipment-item.equipped {
        border-color: #ffd700;
        background: linear-gradient(135deg, #2a2a2a, #333);
        box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
    }
    
    .equipment-image {
        position: relative;
        width: 100%;
        height: 120px;
        margin-bottom: 15px;
        background: #1a1a1a;
        border-radius: 8px;
        overflow: hidden;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .equipment-image img {
        max-width: 100%;
        max-height: 100%;
        object-fit: contain;
        border-radius: 4px;
    }
    
    .equipped-badge {
        position: absolute;
        top: 5px;
        right: 5px;
        background: #ffd700;
        color: #000;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 10px;
        font-weight: bold;
    }
    
    .equipment-info {
        margin-bottom: 15px;
    }
    
    .equipment-name {
        font-size: 18px;
        font-weight: bold;
        color: white;
        margin-bottom: 8px;
    }
    
    .equipment-description {
        font-size: 14px;
        color: #ccc;
        margin-bottom: 12px;
        line-height: 1.4;
    }
    
    .equipment-effects {
        display: flex;
        flex-direction: column;
        gap: 4px;
        margin-bottom: 12px;
    }
    
    .effect {
        font-size: 12px;
        padding: 2px 6px;
        border-radius: 4px;
        font-weight: bold;
    }
    
    .damage-effect { background: #f44336; color: white; }
    .defense-effect { background: #2196f3; color: white; }
    .speed-effect { background: #4caf50; color: white; }
    .crit-effect { background: #ff9800; color: white; }
    .hp-effect { background: #e91e63; color: white; }
    .xp-effect { background: #9c27b0; color: white; }
    .cooldown-effect { background: #00bcd4; color: white; }
    .firerate-effect { background: #795548; color: white; }
    .generic-effect { background: #607d8b; color: white; }
    
    .equipment-cost {
        display: flex;
        align-items: center;
        gap: 5px;
        font-size: 16px;
        font-weight: bold;
        color: #66ffff;
        margin-bottom: 15px;
    }
    
    .cost-icon {
        font-size: 18px;
    }
    
    .equipment-actions {
        display: flex;
        justify-content: center;
    }
    
    .equipment-btn {
        padding: 10px 20px;
        border: none;
        border-radius: 6px;
        font-weight: bold;
        cursor: pointer;
        transition: all 0.3s ease;
        font-size: 14px;
        min-width: 100px;
    }
    
    .buy-btn {
        background: #4CAF50;
        color: white;
    }
    
    .buy-btn:hover {
        background: #45a049;
        transform: scale(1.05);
    }
    
    .equip-btn {
        background: #2196F3;
        color: white;
    }
    
    .equip-btn:hover {
        background: #1976D2;
        transform: scale(1.05);
    }
    
    .equipped-btn {
        background: #ffd700;
        color: #000;
        cursor: default;
    }
    
    .disabled-btn {
        background: #666;
        color: #999;
        cursor: not-allowed;
    }
    
    @media (max-width: 1000px) {
        .shop-content {
            min-width: 600px;
            padding: 15px;
        }
        
        .equipment-grid {
            grid-template-columns: repeat(auto-fill, minmax(240px,  1fr));
            gap: 15px;
            padding: 15px;
        }
    }
    
    @media (max-width: 700px) {
        .shop-content {
            min-width: 400px;
            padding: 10px;
        }
        
        .equipment-grid {
            grid-template-columns: 1fr;
            gap: 15px;
            padding: 10px;
        }
        
        .shop-tabs {
            justify-content: center;
        }
        
        .shop-tab {
            padding: 10px 16px;
            font-size: 14px;
        }
    }
`;

    </script>
    <!-- Game -->
    <script>
        // game.js - Core game loop e sistema principal
        // Última atualização: 2025-06-24 - Refatoração para remover duplicações
        // 
        // REFATORAÇÃO APLICADA:
        // 1. Removida duplicação do método showSettings() (linha 1692)
        // 2. Unificados os métodos hideAllMenus() e hideAllOtherMenus()
        // 3. Consolidados event listeners duplicados
        // 4. Criado sistema híbrido para compatibilidade entre menus HTML e modais
        // 5. Removidos event listeners redundantes de showRanking/showSettings em setupUI()

        class Game extends EventEmitter {
            constructor() {
                super();

                // Canvas e contexto
                this.canvas = document.getElementById('gameCanvas');
                if (!this.canvas) {
                    console.error('Canvas element not found! Make sure gameCanvas element exists in DOM.');
                    throw new Error('Canvas element not found');
                }

                this.ctx = this.canvas.getContext('2d');
                if (!this.ctx) {
                    console.error('Could not get 2D context from canvas!');
                    throw new Error('Could not get 2D context from canvas');
                }

                // Estado do jogo
                this.state = 'menu'; // menu, playing, paused, gameOver
                this.lastTime = 0;
                this.gameStartTime = 0;
                this.gameTime = 0;

                // Entidades do jogo
                this.player = null;
                this.waveSystem = null;
                this.soulOrbs = []; // Array para soul orbs coletáveis

                // Sistemas
                this.inputManager = new InputManager();
                this.ui = new UI();
                this.audioSystem = new AudioSystem();
                this.rankingSystem = new RankingSystem();
                this.playerNamePrompt = new PlayerNamePrompt();
                this.equipmentManager = new EquipmentManager();

                // Configurações
                this.targetFPS = 60;
                this.deltaTime = 1000 / this.targetFPS;

                // Configurações do jogo
                this.settings = {
                    playerName: 'Player',
                    audioEnabled: true,
                    masterVolume: 0.7,
                    sfxVolume: 0.8,
                    xpMultiplier: 1.0
                };

                // Pool de objetos para performance
                this.soulOrbPool = new ObjectPool(
                    () => ({ x: 0, y: 0, value: 1, size: 8, collected: false, alpha: 1.0 }),
                    (orb) => { orb.collected = false; orb.alpha = 1.0; }
                );

                this.init();
            }

            init() {
                console.log('Inicializando jogo...');
                this.setupCanvas();
                console.log('Canvas configurado');
                this.setupEventListeners();
                console.log('Event listeners configurados');
                this.setupUI();
                console.log('UI configurada');
                this.initializeShop();
                console.log('Loja inicializada');

                // Configurar event listeners dos menus uma única vez
                setTimeout(() => {
                    this.setupAllMenuListeners();
                    console.log('Menu listeners configurados');
                }, 100);

                // Começar com o menu
                this.showMainMenu();
                console.log('Menu principal mostrado');

                // Iniciar loop principal
                this.gameLoop();
                console.log('Game loop iniciado');
            }

            setupCanvas() {
                // Configurar tamanho do canvas
                this.resizeCanvas();

                // Configurações do contexto
                this.ctx.imageSmoothingEnabled = false; // Pixel art style
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';

                // Listener para redimensionamento
                window.addEventListener('resize', () => {
                    this.resizeCanvas();
                });
            }

            resizeCanvas() {
                const container = document.getElementById('gameContainer');

                // Definir tamanho base
                let width = 1024;
                let height = 768;
                let containerRect = null; // Declarar a variável no escopo correto

                // Se o container existir, usar suas dimensões
                if (container && container.getBoundingClientRect) {
                    try {
                        containerRect = container.getBoundingClientRect();
                        // Use container dimensions if available
                        if (containerRect.width > 0 && containerRect.height > 0) {
                            width = containerRect.width;
                            height = containerRect.height;
                        }
                    } catch (error) {
                        console.warn('Error getting container rect, using default size:', error);
                        containerRect = null; // Reset em caso de erro
                    }
                } else {
                    // Fallback para viewport ou valores padrão
                    width = window.innerWidth || 1024;
                    height = window.innerHeight || 768;
                }

                // Ajustar para dispositivos móveis
                if (typeof DeviceUtils !== 'undefined' && DeviceUtils.isMobile()) {
                    const viewport = DeviceUtils.getViewportSize();
                    if (viewport.width < viewport.height) {
                        // Portrait
                        width = Math.min(viewport.width, 480);
                        height = Math.min(viewport.height - 200, 640); // Espaço para controles
                    } else {
                        // Landscape
                        width = Math.min(viewport.width - 240, 800); // Espaço para controles
                        height = Math.min(viewport.height, 600);
                    }
                } else {
                    // Desktop: ajustar ao container apenas se containerRect estiver disponível
                    if (containerRect && containerRect.width > 0 && containerRect.height > 0) {
                        const maxWidth = containerRect.width * 0.9;
                        const maxHeight = containerRect.height * 0.9;

                        const aspectRatio = width / height;
                        if (maxWidth / maxHeight > aspectRatio) {
                            height = maxHeight;
                            width = height * aspectRatio;
                        } else {
                            width = maxWidth;
                            height = width / aspectRatio;
                        }
                    }
                }

                this.canvas.width = width;
                this.canvas.height = height;
                this.canvas.style.width = width + 'px';
                this.canvas.style.height = height + 'px';
            }

            setupEventListeners() {
                // Input events para controles de sidescroller
                this.inputManager.on('keyDown', (key) => {
                    this.handleKeyDown(key);
                });

                this.inputManager.on('keyUp', (key) => {
                    this.handleKeyUp(key);
                });

                // Mouse events para mira e tiro
                this.canvas.addEventListener('mousemove', (e) => {
                    if (this.player && this.state === 'playing') {
                        const rect = this.canvas.getBoundingClientRect();
                        const mouseX = e.clientX - rect.left;
                        const mouseY = e.clientY - rect.top;
                        this.player.setMousePosition(mouseX, mouseY);
                    }
                });

                this.canvas.addEventListener('mousedown', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    if (this.player && this.state === 'playing') {
                        e.preventDefault();
                        this.player.startShooting();
                    } else if (this.state === 'paused' && this.upgradeSystem && this.upgradeSystem.isUpgradeMenuOpen) {
                        // Verificar clique em carta de upgrade
                        e.preventDefault();
                        this.handleUpgradeCardClick(mouseX, mouseY);
                    }
                });

                this.canvas.addEventListener('mouseup', (e) => {
                    if (this.player && this.state === 'playing') {
                        e.preventDefault();
                        this.player.stopShooting();
                    }
                });

                // Mobile controls - DESABILITADOS para evitar conflitos
                // Os controles mobile agora são gerenciados pelos eventos joystickMove/Stop e botões específicos
                /*
                this.inputManager.on('mobileMove', (direction) => {
                    if (this.player) {
                        const controls = { left: false, right: false };
                        if (direction === 'left') controls.left = true;
                        if (direction === 'right') controls.right = true;
                        this.player.setMobileControls(controls);
                    }
                });
                
                this.inputManager.on('mobileJump', () => {
                    if (this.player) {
                        this.player.setMobileControls({ jump: true });
                    }
                });
                
                this.inputManager.on('mobileShoot', (aimX, aimY, shooting) => {
                    if (this.player) {
                        this.player.setMobileControls({ 
                            shooting: shooting,
                            aimX: aimX,
                            aimY: aimY 
                        });
                    }
                });
                */

                // Novos controles mobile - DESABILITADOS COMPLETAMENTE em desktop
                this.ui.on('joystickMove', (normalizedX, normalizedY) => {
                    // IGNORAR COMPLETAMENTE se não for dispositivo móvel
                    if (typeof DeviceUtils === 'undefined' || !DeviceUtils.isMobile()) {
                        console.log('Joystick event BLOCKED - not a mobile device'); // Debug
                        return; // Sair imediatamente
                    }

                    // Verificar se o jogo está rodando
                    if (this.player && this.state === 'playing') {
                        console.log('Joystick move (mobile only):', { normalizedX, normalizedY }); // Debug

                        // Zona morta para evitar movimento fantasma
                        const threshold = 0.3;

                        // Aplicar movimento apenas se estiver fora da zona morta
                        if (Math.abs(normalizedX) > threshold) {
                            if (normalizedX < -threshold) {
                                this.player.setInput('left', true);
                                this.player.setInput('right', false);
                                console.log('Mobile: Setting left input to true');
                            } else if (normalizedX > threshold) {
                                this.player.setInput('left', false);
                                this.player.setInput('right', true);
                                console.log('Mobile: Setting right input to true');
                            }
                        } else {
                            // Na zona morta - parar movimento
                            this.player.setInput('left', false);
                            this.player.setInput('right', false);
                            console.log('Mobile: In dead zone - stopping movement');
                        }

                        // Mira (apenas se houver movimento significativo)
                        if (Math.abs(normalizedX) > 0.2 || Math.abs(normalizedY) > 0.2) {
                            const centerX = this.canvas.width / 2;
                            const centerY = this.canvas.height / 2;
                            const aimX = centerX + normalizedX * 100;
                            const aimY = centerY + normalizedY * 100;
                            this.player.setMousePosition(aimX, aimY);
                        }
                    }
                });

                this.ui.on('joystickStop', () => {
                    // IGNORAR COMPLETAMENTE se não for dispositivo móvel
                    if (typeof DeviceUtils === 'undefined' || !DeviceUtils.isMobile()) {
                        console.log('Joystick stop BLOCKED - not a mobile device'); // Debug
                        return; // Sair imediatamente
                    }

                    if (this.player) {
                        console.log('Joystick stop - clearing movement (mobile only)'); // Debug
                        // Parar movimento completamente quando joystick for solto
                        this.player.setInput('left', false);
                        this.player.setInput('right', false);
                        // Garantir que a velocidade horizontal seja zerada
                        this.player.vx = 0;
                    }
                });

                this.ui.on('mobileShootStart', () => {
                    console.log('Mobile shoot start event received');
                    if (this.player) {
                        this.player.startShooting();
                    }
                });

                this.ui.on('mobileShootStop', () => {
                    console.log('Mobile shoot stop event received');
                    if (this.player) {
                        this.player.stopShooting();
                    }
                });

                this.ui.on('mobileJump', () => {
                    console.log('Mobile jump event received');
                    if (this.player) {
                        this.player.setInput('jump', true);
                        // Soltar o pulo após um tempo para simular tap
                        setTimeout(() => {
                            if (this.player) {
                                this.player.setInput('jump', false);
                            }
                        }, 100);
                    }
                });

                this.ui.on('pausePress', () => {
                    this.togglePause();
                });

                // UI events - estes elementos são criados dinamicamente
                // Os event listeners do menu principal são configurados no showMainMenu()

                // Event listeners para elementos que sempre existem - REMOVIDO duplicação
                // Os listeners de resumeBtn, restartBtn e mainMenuBtn são configurados em setupAllMenuListeners()
                const pauseBtn = document.getElementById('pauseBtn');
                if (pauseBtn) {
                    pauseBtn.addEventListener('click', () => {
                        this.togglePause();
                    });
                }
            }

            // Configurar todos os event listeners dos menus uma única vez
            setupAllMenuListeners() {
                console.log('Configurando listeners dos menus...');

                // Menu Principal - Botão Novo Jogo
                const startGameBtn = document.getElementById('startGameBtn');
                if (startGameBtn) {
                    startGameBtn.addEventListener('click', (e) => {
                        console.log('Botão Novo Jogo clicado');
                        e.preventDefault();
                        this.hideAllMenus();
                        this.startGame();
                    });
                    console.log('Listener do botão Novo Jogo configurado');
                } else {
                    console.error('Botão startGameBtn não encontrado');
                }

                // Menu Principal - Botão Carregar Jogo
                const loadGameBtn = document.getElementById('loadGameBtn');
                if (loadGameBtn) {
                    loadGameBtn.addEventListener('click', (e) => {
                        console.log('Botão Carregar Jogo clicado');
                        e.preventDefault();
                        this.loadGame();
                        this.hideAllMenus();
                        this.startGame();
                    });
                    console.log('Listener do botão Carregar Jogo configurado');
                }

                // Menu Principal - Botão Loja
                const shopBtn = document.getElementById('shopBtn');
                if (shopBtn) {
                    shopBtn.addEventListener('click', (e) => {
                        console.log('Botão Loja clicado');
                        e.preventDefault();
                        this.showShop();
                    });
                    console.log('Listener do botão Loja configurado');
                } else {
                    console.error('Botão shopBtn não encontrado');
                }

                // Menu Principal - Botão Ranking
                const rankingBtn = document.getElementById('rankingBtn');
                if (rankingBtn) {
                    rankingBtn.addEventListener('click', (e) => {
                        console.log('Botão Ranking clicado');
                        e.preventDefault();
                        this.showRanking();
                    });
                    console.log('Listener do botão Ranking configurado');
                } else {
                    console.error('Botão rankingBtn não encontrado');
                }

                // Menu Principal - Botão Configurações
                const settingsBtn = document.getElementById('settingsBtn');
                if (settingsBtn) {
                    settingsBtn.addEventListener('click', (e) => {
                        console.log('Botão Configurações clicado');
                        e.preventDefault();
                        this.showSettings();
                    });
                    console.log('Listener do botão Configurações configurado');
                } else {
                    console.error('Botão settingsBtn não encontrado');
                }

                // Menu de Pausa - Botão Continuar
                const resumeBtn = document.getElementById('resumeBtn');
                if (resumeBtn) {
                    resumeBtn.addEventListener('click', (e) => {
                        console.log('Botão Continuar clicado');
                        e.preventDefault();
                        this.resumeGame();
                    });
                }

                // Menu de Pausa - Botão Reiniciar
                const restartBtn = document.getElementById('restartBtn');
                if (restartBtn) {
                    restartBtn.addEventListener('click', (e) => {
                        console.log('Botão Reiniciar clicado');
                        e.preventDefault();
                        this.startGame();
                    });
                }

                // Menu de Pausa - Botão Menu Principal
                const mainMenuBtn = document.getElementById('mainMenuBtn');
                if (mainMenuBtn) {
                    mainMenuBtn.addEventListener('click', (e) => {
                        console.log('Botão Menu Principal clicado');
                        e.preventDefault();
                        this.showMainMenu();
                    });
                }

                // Botões de fechar menus
                const closeShopBtn = document.getElementById('closeShopBtn');
                if (closeShopBtn) {
                    closeShopBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        this.hideShop();
                    });
                }

                const closeRankingBtn = document.getElementById('closeRankingBtn');
                if (closeRankingBtn) {
                    closeRankingBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        this.hideRanking();
                    });
                }

                const closeSettingsBtn = document.getElementById('closeSettingsBtn');
                if (closeSettingsBtn) {
                    closeSettingsBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        this.hideSettings();
                    });
                }

                // Botões do Game Over Menu
                const playAgainBtn = document.getElementById('playAgainBtn');
                if (playAgainBtn) {
                    playAgainBtn.addEventListener('click', (e) => {
                        console.log('Botão Jogar Novamente clicado');
                        e.preventDefault();
                        this.startGame();
                    });
                }

                const backToMenuBtn = document.getElementById('backToMenuBtn');
                if (backToMenuBtn) {
                    backToMenuBtn.addEventListener('click', (e) => {
                        console.log('Botão Menu Principal clicado (Game Over)');
                        e.preventDefault();
                        this.showMainMenu();
                    });
                }

                console.log('Todos os listeners dos menus foram configurados');
            }

            // Métodos para lidar com input de teclado
            handleKeyDown(key) {
                // Handle game over state
                if (this.state === 'gameOver') {
                    switch (key.toLowerCase()) {
                        case 'r':
                            this.startGame();
                            break;
                        case 'escape':
                            this.showMainMenu();
                            break;
                    }
                    return;
                }

                // Handle playing state
                if (!this.player || this.state !== 'playing') return;

                switch (key.toLowerCase()) {
                    case 'a':
                    case 'arrowleft':
                        this.player.setInput('left', true);
                        break;
                    case 'd':
                    case 'arrowright':
                        this.player.setInput('right', true);
                        break;
                    case 'w':
                    case 'arrowup':
                    case ' ':
                        this.player.setInput('jump', true);
                        break;
                    case 'escape':
                        this.togglePause();
                        break;
                }
            }

            handleKeyUp(key) {
                if (!this.player || this.state !== 'playing') return;

                switch (key.toLowerCase()) {
                    case 'a':
                    case 'arrowleft':
                        this.player.setInput('left', false);
                        break;
                    case 'd':
                    case 'arrowright':
                        this.player.setInput('right', false);
                        break;
                    case 'w':
                    case 'arrowup':
                    case ' ':
                        this.player.setInput('jump', false);
                        break;
                }
            }

            setupUI() {
                // this.ui.on('hpUpdate', (hp, maxHp) => {
                //     this.updateHPBar(hp, maxHp);
                // });

                this.ui.on('soulOrbsUpdate', (count) => {
                    this.updateSoulOrbsDisplay(count);
                });

                this.ui.on('waveUpdate', (wave) => {
                    this.updateWaveDisplay(wave);
                });

                this.ui.on('timeUpdate', (time) => {
                    this.updateTimeDisplay(time);
                });

                // Event listeners para ranking
                this.ui.on('clearRanking', () => {
                    this.rankingSystem.clearRankings();
                });

                this.rankingSystem.on('newRecord', (entry, position) => {
                    this.ui.showNewRecordPopup(position, entry);
                });

                // Event listeners para loja - CONSOLIDADO (remove duplicação)
                this.ui.on('buyItem', (data) => {
                    console.log('Event buyItem recebido:', data); // Debug
                    const success = this.buyItem(data.type, data.itemId);
                    if (success) {
                        console.log('Compra bem-sucedida, atualizando loja'); // Debug
                        this.ui.updateShopDisplay();
                    }
                });

                this.ui.on('buyEquipment', (data) => {
                    console.log('Event buyEquipment recebido:', data); // Debug
                    const success = this.buyItem(data.type, data.itemId);
                    if (success) {
                        console.log('Compra de equipamento bem-sucedida, atualizando loja'); // Debug
                        this.ui.updateShopDisplay();
                    }
                });

                this.ui.on('equipItem', (data) => {
                    console.log('Event equipItem recebido:', data); // Debug
                    const success = this.equipItem(data);
                    if (success) {
                        console.log('Equipamento bem-sucedido, atualizando loja'); // Debug
                        this.ui.updateShopDisplay();
                    }
                });

                // Event listeners para configurações
                this.ui.on('audioToggled', (enabled) => {
                    if (enabled) {
                        this.audioSystem.unmute();
                    } else {
                        this.audioSystem.mute();
                    }
                    // Salvar configurações imediatamente
                    this.audioSystem.saveSettings();
                });

                this.ui.on('masterVolumeChanged', (volume) => {
                    this.audioSystem.setMasterVolume(volume);
                    // Salvar configurações imediatamente
                    this.audioSystem.saveSettings();
                });

                this.ui.on('sfxVolumeChanged', (volume) => {
                    this.audioSystem.setSfxVolume(volume);
                    // Salvar configurações imediatamente
                    this.audioSystem.saveSettings();
                });

                this.ui.on('xpMultiplierChanged', (multiplier) => {
                    this.settings.xpMultiplier = multiplier;
                    console.log('Multiplicador de XP alterado para:', multiplier);
                    // As configurações serão salvas quando o saveSettings for emitido
                });

                this.ui.on('saveSettings', () => {
                    console.log('Event saveSettings recebido - salvando configurações gerais');
                    this.saveGame(); // Salvar todas as configurações do jogo
                });

                this.ui.on('settingsSaved', (settings) => {
                    console.log('Event settingsSaved recebido:', settings); // Debug

                    // Salvar nome do jogador no PlayerNamePrompt
                    this.playerNamePrompt.savePlayerName(settings.playerName);

                    // Atualizar nome no player atual se existir
                    if (this.player) {
                        this.player.setPlayerName(settings.playerName);
                    }

                    // Aplicar configurações de áudio ANTES de salvar
                    if (this.audioSystem) {
                        if (settings.audioEnabled !== undefined) {
                            if (settings.audioEnabled) {
                                this.audioSystem.unmute();
                            } else {
                                this.audioSystem.mute();
                            }
                        }
                        
                        if (settings.masterVolume !== undefined) {
                            this.audioSystem.setMasterVolume(settings.masterVolume);
                        }
                        
                        if (settings.sfxVolume !== undefined) {
                            this.audioSystem.setSfxVolume(settings.sfxVolume);
                        }
                        
                        // Salvar configurações de áudio após aplicar mudanças
                        this.audioSystem.saveSettings();
                    }

                    // Salvar multiplicador de XP
                    this.setXpMultiplier(settings.xpMultiplier);

                    // Salvar jogo para persistir as mudanças
                    this.saveGame();

                    console.log('Configurações aplicadas e salvas'); // Debug
                    this.ui.showNotification('Configurações salvas com sucesso!', 'success', 2000);
                });

                this.ui.on('resetSettings', () => {
                    console.log('Event resetSettings recebido'); // Debug

                    // Restaurar configurações padrão
                    if (this.audioSystem) {
                        this.audioSystem.setMasterVolume(0.7);
                        this.audioSystem.setSfxVolume(0.8);
                        this.audioSystem.unmute();
                        this.audioSystem.saveSettings();
                    }
                    
                    this.setXpMultiplier(1.0);
                    this.playerNamePrompt.savePlayerName('Player');

                    // Atualizar nome no player atual se existir
                    if (this.player) {
                        this.player.setPlayerName('Player');
                    }

                    // Salvar jogo para persistir as mudanças
                    this.saveGame();

                    console.log('Configurações restauradas para o padrão'); // Debug
                    this.ui.showNotification('Configurações restauradas para o padrão!', 'success', 2000);
                });

                // Event listeners para ranking e configurações - REMOVIDOS (duplicação)
                // Estes são acionados pelos botões do menu principal já configurados em setupAllMenuListeners()

                // Event listeners para Soul Orbs (debug)
                this.ui.on('addSoulOrbs', (amount) => {
                    this.addSoulOrbs(amount);
                });

                this.ui.on('removeSoulOrbs', (amount) => {
                    this.removeSoulOrbs(amount);
                });
            }

            // Sistema de Loja de Equipamentos
            initializeShop() {
                console.log('Inicializando sistema de loja');

                // Event listeners para ações da loja são configurados em setupUI()
                // Não duplicar aqui para evitar conflitos

                // Inicializar player com equipamentos básicos se não existir
                if (!this.player) {
                    this.player = new Player(400, 300);
                }

                // Garantir que o player tenha as estruturas de equipamentos
                if (!this.player.ownedEquipment) {
                    this.player.ownedEquipment = {
                        hats: [],
                        staffs: []
                    };
                }

                if (!this.player.equippedEquipment) {
                    this.player.equippedEquipment = {
                        hats: null,
                        staffs: null
                    };
                }
            }

            // Equipment and shop methods
            buyItem(type, itemId) {
                console.log('buyItem chamado:', { type, itemId }); // Debug
                console.log('Estado do player antes da compra:', {
                    soulOrbs: this.player?.soulOrbs,
                    ownedEquipment: this.player?.ownedEquipment,
                    equippedEquipment: this.player?.equippedEquipment
                }); // Debug
                
                if (!this.player) {
                    console.error('Player not found');
                    this.ui.showNotification('Player não encontrado!', 'error', 2000);
                    return false;
                }

                const equipment = this.equipmentManager.getEquipment(type, itemId);
                if (!equipment) {
                    console.error('Equipment not found:', type, itemId);
                    this.ui.showNotification('Item não encontrado!', 'error', 2000);
                    return false;
                }

                // Check if player has enough soul orbs
                if (this.player.soulOrbs < equipment.cost) {
                    console.log('Soul Orbs insuficientes:', this.player.soulOrbs, '<', equipment.cost); // Debug
                    this.ui.showNotification('Soul Orbs insuficientes!', 'error', 2000);
                    return false;
                }

                // Check if player already owns this equipment
                if (this.player.ownedEquipment[type] && this.player.ownedEquipment[type].includes(itemId)) {
                    console.log('Player já possui este item:', itemId); // Debug
                    this.ui.showNotification('Você já possui este item!', 'error', 2000);
                    return false;
                }

                // Purchase the item
                this.player.soulOrbs -= equipment.cost;
                if (!this.player.ownedEquipment[type]) {
                    this.player.ownedEquipment[type] = [];
                }
                this.player.ownedEquipment[type].push(itemId);

                console.log('Estado do player após a compra:', {
                    soulOrbs: this.player.soulOrbs,
                    ownedEquipment: this.player.ownedEquipment,
                    equippedEquipment: this.player.equippedEquipment
                }); // Debug

                this.ui.showNotification(`${equipment.name} comprado com sucesso!`, 'success', 2000);
                this.saveGame();
                return true;
            }

            equipItem(data) {
                const { type, itemId } = data;

                console.log('equipItem chamado:', { type, itemId }); // Debug
                console.log('Estado do player antes de equipar:', {
                    ownedEquipment: this.player?.ownedEquipment,
                    equippedEquipment: this.player?.equippedEquipment
                }); // Debug

                if (!this.player) {
                    console.error('Player not found');
                    this.ui.showNotification('Player não encontrado!', 'error', 2000);
                    return false;
                }

                // Check if player owns the item
                if (!this.player.ownedEquipment[type] || !this.player.ownedEquipment[type].includes(itemId)) {
                    console.log('Player não possui este item:', itemId, 'em', this.player.ownedEquipment[type]); // Debug
                    this.ui.showNotification('Você não possui este item!', 'error', 2000);
                    return false;
                }

                // Equip the item
                if (!this.player.equippedEquipment) {
                    this.player.equippedEquipment = {};
                }
                this.player.equippedEquipment[type] = itemId;

                console.log('Estado do player após equipar:', {
                    ownedEquipment: this.player.ownedEquipment,
                    equippedEquipment: this.player.equippedEquipment
                }); // Debug

                // Update player sprites if method exists
                if (this.player.updateEquipmentSprites) {
                    this.player.updateEquipmentSprites();
                }

                // Update player stats
                if (this.player.updateStats) {
                    this.player.updateStats();
                }

                const equipment = this.equipmentManager.getEquipment(type, itemId);
                const equipmentName = equipment ? equipment.name : itemId;
                this.ui.showNotification(`${equipmentName} equipado!`, 'success', 2000);
                this.saveGame();
                return true;
            }

            // Also add buyEquipment method as alias
            buyEquipment(data) {
                return this.buyItem(data.type, data.itemId);
            }

            // Método UNIFICADO para esconder todos os outros menus - Remove duplicação
            hideAllOtherMenus() {
                // Lista completa de todos os menus do sistema
                const allMenus = [
                    'pauseMenu', 'shopMenu', 'rankingMenu', 'settingsMenu',
                    'gameOverMenu', 'upgradeMenu'
                ];

                allMenus.forEach(menuId => {
                    const menu = document.getElementById(menuId);
                    if (menu) {
                        menu.classList.add('hidden');
                        menu.style.display = 'none';
                    }
                });

                // Fechar modais também se estiver usando sistema moderno
                if (this.ui && this.ui.closeAllModals) {
                    this.ui.closeAllModals();
                }
            }

            // Método UNIFICADO para esconder todos os menus - consolida hideAllMenus e hideAllOtherMenus
            hideAllMenus() {
                console.log('Escondendo todos os menus - versão unificada');

                // Esconder menu principal também
                this.hideMainMenu();

                // Esconder todos os outros menus
                this.hideAllOtherMenus();

                // Esconder controles móveis
                const mobileControls = document.getElementById('mobileControls');
                if (mobileControls) {
                    mobileControls.style.display = 'none';
                }

                // Fechar menu de upgrades se estiver aberto
                if (this.upgradeSystem && this.upgradeSystem.isUpgradeMenuOpen) {
                    this.upgradeSystem.hideUpgradeMenu();
                }

                // Fechar menu de cartas se estiver aberto
                if (this.cardSystem && this.cardSystem.isChoosingCard) {
                    this.cardSystem.cancelCardChoice();
                }

                // Mostrar canvas do jogo
                this.canvas.style.display = 'block';

                console.log('Todos os menus foram escondidos - versão unificada');
            }

            // Método para mostrar loja - UNIFICADO
            showShop() {
                console.log('Mostrando loja - usando modal moderno...');

                // Garantir que o player existe e tem equipamentos iniciais configurados
                if (!this.player) {
                    // Criar player temporário apenas para a loja
                    this.player = new Player(400, 300);
                }

                // Garantir que o player tem estruturas de equipamentos
                if (!this.player.ownedEquipment) {
                    this.player.ownedEquipment = { hats: [], staffs: [] };
                }
                if (!this.player.equippedEquipment) {
                    this.player.equippedEquipment = { hats: null, staffs: null };
                }

                // Garantir que equipamentos padrão estão configurados
                if (!this.player.ownedEquipment.hats.includes('wizardHat')) {
                    this.player.ownedEquipment.hats.push('wizardHat');
                }
                if (!this.player.ownedEquipment.staffs.includes('wizardStaff')) {
                    this.player.ownedEquipment.staffs.push('wizardStaff');
                }
                if (!this.player.equippedEquipment.hats) {
                    this.player.equippedEquipment.hats = 'wizardHat';
                }
                if (!this.player.equippedEquipment.staffs) {
                    this.player.equippedEquipment.staffs = 'wizardStaff';
                }

                // Verificar se devemos usar o sistema modal moderno ou menus estáticos
                if (this.ui && this.ui.showShopModal && this.player) {
                    // Sistema moderno - usando modais
                    const playerData = {
                        soulOrbs: this.player.soulOrbs || 0,
                        ownedEquipment: this.player.ownedEquipment || { hats: [], staffs: [] },
                        equippedEquipment: this.player.equippedEquipment || { hats: null, staffs: null }
                    };

                    const equipmentData = this.equipmentManager ? this.equipmentManager.getAllEquipment() : { hats: {}, staffs: {} };

                    this.ui.showShopModal(playerData, equipmentData);
                } else {
                    // Sistema legado - usando menus HTML estáticos
                    this.hideAllOtherMenus();
                    const mainMenu = document.getElementById('mainMenu');
                    if (mainMenu) {
                        mainMenu.classList.add('hidden');
                        mainMenu.style.display = 'none';
                    }

                    const shopMenu = document.getElementById('shopMenu');
                    if (shopMenu) {
                        shopMenu.classList.remove('hidden');
                        shopMenu.style.display = 'flex';
                        console.log('Menu da loja mostrado (sistema legado)');
                    } else {
                        console.error('Elemento shopMenu não encontrado');
                    }
                }
            }

            // Método para esconder loja
            hideShop() {
                const shopMenu = document.getElementById('shopMenu');
                if (shopMenu) {
                    shopMenu.classList.add('hidden');
                    shopMenu.style.display = 'none';
                }
                this.showMainMenu();
            }

            // Método para esconder ranking
            hideRanking() {
                const rankingMenu = document.getElementById('rankingMenu');
                if (rankingMenu) {
                    rankingMenu.classList.add('hidden');
                    rankingMenu.style.display = 'none';
                }
                this.showMainMenu();
            }

            // Método para mostrar configurações - UNIFICADO
            showSettings() {
                console.log('Mostrando configurações - usando modal moderno...');

                // Verificar se devemos usar o sistema modal moderno ou menus estáticos
                if (this.ui && this.ui.showSettingsModal) {
                    // Sistema moderno - usando modais
                    // Carregar configurações atuais do sistema de áudio e jogador
                    const currentSettings = {
                        playerName: (this.player ? this.player.playerName : null) || this.playerNamePrompt.loadPlayerName() || 'Player',
                        audioEnabled: this.audioSystem ? !this.audioSystem.isMuted() : true,
                        masterVolume: this.audioSystem ? this.audioSystem.masterVolume : 0.7,
                        sfxVolume: this.audioSystem ? this.audioSystem.sfxVolume : 0.8,
                        xpMultiplier: this.expMultiplier || 1.0
                    };

                    console.log('Configurações atuais carregadas:', currentSettings); // Debug

                    this.ui.showSettingsModal(currentSettings);
                } else {
                    // Sistema legado - usando menus HTML estáticos
                    this.hideAllOtherMenus();
                    const mainMenu = document.getElementById('mainMenu');
                    if (mainMenu) {
                        mainMenu.classList.add('hidden');
                        mainMenu.style.display = 'none';
                    }

                    const settingsMenu = document.getElementById('settingsMenu');
                    if (settingsMenu) {
                        settingsMenu.classList.remove('hidden');
                        settingsMenu.style.display = 'flex';
                        console.log('Menu de configurações mostrado (sistema legado)');
                    } else {
                        console.error('Elemento settingsMenu não encontrado');
                    }
                }
            }

            // Método para esconder configurações
            hideSettings() {
                const settingsMenu = document.getElementById('settingsMenu');
                if (settingsMenu) {
                    settingsMenu.classList.add('hidden');
                    settingsMenu.style.display = 'none';
                }
                this.showMainMenu();
            }

            gameLoop(currentTime = 0) {
                // Calcular delta time
                if (this.lastTime === 0) {
                    this.lastTime = currentTime;
                }

                const deltaTime = Math.min(currentTime - this.lastTime, 1000 / 30); // Cap at 30fps minimum
                this.lastTime = currentTime;

                // Atualizar apenas se o jogo estiver rodando
                if (this.state === 'playing') {
                    this.update(deltaTime);
                }

                // Renderizar apenas se o jogo estiver ativo
                if (this.state === 'playing' || this.state === 'paused') {
                    this.render();
                }

                // Continuar loop
                requestAnimationFrame((time) => this.gameLoop(time));
            }

            update(deltaTime) {
                this.gameTime += deltaTime;

                // Atualizar entidades
                if (this.player && this.terrain) {
                    const platforms = this.terrain.getPlatforms();
                    this.player.update(deltaTime, this.enemySpawner.getEnemies(), this.canvas, platforms);

                    // Atualizar tempo de sobrevivência
                    this.player.updateSurvivalTime(deltaTime);
                }

                if (this.enemySpawner) {
                    this.enemySpawner.update(deltaTime, this.player, this.canvas);
                }

                // Atualizar soul orbs
                this.updateSoulOrbs(deltaTime);

                // Auto-save periódico (a cada 10 segundos)
                if (!this.lastAutoSave) this.lastAutoSave = 0;
                if (this.gameTime - this.lastAutoSave > 10000) { // 10 segundos
                    this.saveGame();
                    this.lastAutoSave = this.gameTime;
                    console.log('Auto-save realizado');
                }

                // Atualizar UI
                this.updateUI();

                // Verificar condições de game over
                if (this.player && this.player.hp <= 0) {
                    this.gameOver();
                }

                // Auto-save a cada 30 segundos
                if (this.gameTime % 30000 < deltaTime) {
                    this.autoSave();
                }
            }

            render() {
                // Limpar canvas
                this.ctx.fillStyle = '#0f0f23';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Renderizar baseado no estado
                switch (this.state) {
                    case 'playing':
                    case 'paused':
                        this.renderGame();
                        break;
                    case 'menu':
                        this.renderMenu();
                        break;
                    case 'gameOver':
                        // Game over é tratado via menu HTML, não precisa renderizar no canvas
                        break;
                }
            }

            renderGame() {
                // Background pattern
                this.renderBackground();

                // Renderizar terreno
                if (this.terrain) {
                    this.terrain.render(this.ctx);
                }

                // Renderizar entidades
                if (this.enemySpawner) {
                    this.enemySpawner.render(this.ctx);
                }

                if (this.player) {
                    this.player.render(this.ctx);
                }

                // Renderizar soul orbs
                this.renderSoulOrbs();

                // Renderizar HUD
                if (this.player) {
                    this.ui.renderHUD(this.ctx, this.player, this);
                }

                // Renderizar menu de upgrade se estiver aberto
                if (this.upgradeSystem) {
                    this.upgradeSystem.renderUpgradeMenu(this.ctx, this.canvas);
                }

                // Efeitos visuais
                this.renderEffects();

                // Debug info (removível)
                if (window.DEBUG) {
                    this.renderDebugInfo();
                }
            }

            renderBackground() {
                // Sistema de fundo com paralax e atmosfera dinâmica
                this.renderParallaxBackground();
            }
            
            renderParallaxBackground() {
                const time = this.gameTime * 0.001; // Converter para segundos
                const waveCount = this.waveSystem ? this.waveSystem.currentWave : 1;
                
                // 1. Céu com gradient dinâmico baseado no tempo/onda
                const skyGradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height * 0.6);
                
                // Cores mudam com as ondas para dar sensação de progresso
                const hue = (time * 2 + waveCount * 15) % 360;
                const saturation = Math.min(30 + waveCount * 5, 70);
                const lightness = Math.max(15 - waveCount * 2, 5);
                
                skyGradient.addColorStop(0, `hsl(${hue}, ${saturation}%, ${lightness + 10}%)`);
                skyGradient.addColorStop(0.5, `hsl(${hue + 30}, ${saturation}%, ${lightness + 5}%)`);
                skyGradient.addColorStop(1, `hsl(${hue + 60}, ${saturation}%, ${lightness}%)`);
                
                this.ctx.fillStyle = skyGradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height * 0.6);
                
                // 2. Montanhas distantes (camada mais lenta)
                this.renderMountains(time * 0.1, waveCount);
                
                // 3. Nuvens em movimento (camada média)
                this.renderClouds(time * 0.3, waveCount);
                
                // 4. Estrelas/partículas mágicas (camada rápida)
                this.renderMagicalParticles(time, waveCount);
                
                // 5. Névoa/atmosfera baixa
                this.renderAtmosphere(time * 0.5, waveCount);
                
                // 6. Grid mágico sutil (mais intenso com as ondas)
                this.renderMagicalGrid(time, waveCount);
            }
            
            renderMountains(offset, waveCount) {
                const mountainHeight = this.canvas.height * 0.3;
                const mountainY = this.canvas.height * 0.6;
                
                // Múltiplas camadas de montanhas com diferentes velocidades
                for (let layer = 0; layer < 3; layer++) {
                    const layerSpeed = (layer + 1) * 0.5;
                    const layerOffset = offset * layerSpeed;
                    const alpha = 0.1 + layer * 0.05 + waveCount * 0.01;
                    const hue = 240 + layer * 30 + waveCount * 10;
                    
                    this.ctx.fillStyle = `hsla(${hue}, 50%, 20%, ${alpha})`;
                    this.ctx.beginPath();
                    
                    // Gerar forma de montanhas suave
                    const points = 20;
                    const width = this.canvas.width + 200;
                    
                    for (let i = 0; i <= points; i++) {
                        const x = (i / points) * width - 100 + layerOffset;
                        const baseHeight = mountainHeight * (0.5 + layer * 0.2);
                        const noise = Math.sin((x + layerOffset) * 0.01) * baseHeight * 0.3;
                        const y = mountainY - baseHeight + noise;
                        
                        if (i === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                    
                    this.ctx.lineTo(width, this.canvas.height);
                    this.ctx.lineTo(-100, this.canvas.height);
                    this.ctx.closePath();
                    this.ctx.fill();
                }
            }
            
            renderClouds(offset, waveCount) {
                const cloudCount = 5 + waveCount;
                const cloudAlpha = 0.1 + waveCount * 0.01;
                
                for (let i = 0; i < cloudCount; i++) {
                    const cloudX = ((i * 200 + offset * (1 + i * 0.1)) % (this.canvas.width + 400)) - 200;
                    const cloudY = this.canvas.height * 0.2 + Math.sin(i + offset * 0.1) * 50;
                    const cloudSize = 80 + Math.sin(i + offset * 0.05) * 20;
                    
                    this.ctx.fillStyle = `rgba(255, 255, 255, ${cloudAlpha})`;
                    
                    // Desenhar nuvem com múltiplos círculos
                    for (let j = 0; j < 5; j++) {
                        const bubbleX = cloudX + (j - 2) * cloudSize * 0.3;
                        const bubbleY = cloudY + Math.sin(j) * cloudSize * 0.2;
                        const bubbleSize = cloudSize * (0.5 + Math.sin(j + offset) * 0.2);
                        
                        this.ctx.beginPath();
                        this.ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            }
            
            renderMagicalParticles(time, waveCount) {
                const particleCount = 30 + waveCount * 5;
                
                for (let i = 0; i < particleCount; i++) {
                    // Posição baseada em hash pseudo-aleatório para consistência
                    const hash = ((i * 73) % 997) / 997;
                    const x = (hash * this.canvas.width + time * (50 + hash * 30)) % this.canvas.width;
                    const y = ((i * 127) % 997) / 997 * this.canvas.height;
                    
                    // Intensidade varia com o tempo e onda
                    const intensity = (Math.sin(time + i) + 1) * 0.5;
                    const alpha = intensity * (0.3 + waveCount * 0.02);
                    
                    // Cor muda com as ondas - mais variedade
                    const hue = (180 + waveCount * 20 + i * 15 + time * 10) % 360;
                    const baseSize = 1 + intensity * 2;
                    
                    // Criar gradiente radial para cada partícula
                    const gradient = this.ctx.createRadialGradient(x, y, 0, x, y, baseSize * 4);
                    gradient.addColorStop(0, `hsla(${hue}, 80%, 70%, ${alpha})`);
                    gradient.addColorStop(0.5, `hsla(${hue}, 70%, 60%, ${alpha * 0.6})`);
                    gradient.addColorStop(1, `hsla(${hue}, 60%, 50%, 0)`);
                    
                    // Partícula principal com brilho
                    this.ctx.fillStyle = gradient;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, baseSize * 4, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Núcleo brilhante
                    this.ctx.fillStyle = `hsla(${hue}, 70%, 60%, ${alpha})`;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, baseSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Brilho central
                    this.ctx.fillStyle = `hsla(${hue}, 50%, 90%, ${alpha * 0.8})`;
                    this.ctx.beginPath();
                    this.ctx.arc(x - baseSize * 0.3, y - baseSize * 0.3, baseSize * 0.5, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Para partículas especialmente brilhantes, adicionar efeitos extras
                    if (intensity > 0.8) {
                        // Raios de luz
                        this.ctx.strokeStyle = `hsla(${hue}, 80%, 70%, ${alpha * 0.4})`;
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        
                        for (let ray = 0; ray < 6; ray++) {
                            const angle = (ray * Math.PI / 3) + time + i;
                            const rayLength = baseSize * (3 + Math.sin(time * 2 + i) * 2);
                            const startX = x + Math.cos(angle) * baseSize;
                            const startY = y + Math.sin(angle) * baseSize;
                            const endX = x + Math.cos(angle) * rayLength;
                            const endY = y + Math.sin(angle) * rayLength;
                            
                            this.ctx.moveTo(startX, startY);
                            this.ctx.lineTo(endX, endY);
                        }
                        this.ctx.stroke();
                        
                        // Halo externo pulsante
                        const pulseSize = baseSize * (4 + Math.sin(time * 3 + i) * 2);
                        const pulseGradient = this.ctx.createRadialGradient(x, y, 0, x, y, pulseSize);
                        pulseGradient.addColorStop(0, `hsla(${hue}, 60%, 80%, 0)`);
                        pulseGradient.addColorStop(0.7, `hsla(${hue}, 70%, 70%, ${alpha * 0.1})`);
                        pulseGradient.addColorStop(1, `hsla(${hue}, 80%, 60%, 0)`);
                        
                        this.ctx.fillStyle = pulseGradient;
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, pulseSize, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                    
                    // Partículas cintilantes menores
                    if (i % 3 === 0) {
                        const sparkleX = x + Math.sin(time * 2 + i) * 20;
                        const sparkleY = y + Math.cos(time * 2 + i) * 20;
                        const sparkleAlpha = alpha * 0.6 * (Math.sin(time * 4 + i) + 1) * 0.5;
                        
                        this.ctx.fillStyle = `hsla(${(hue + 60) % 360}, 90%, 80%, ${sparkleAlpha})`;
                        this.ctx.beginPath();
                        this.ctx.arc(sparkleX, sparkleY, 0.5, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                }
            }
            
            renderAtmosphere(offset, waveCount) {
                // Névoa baixa que se move
                const fogHeight = this.canvas.height * 0.3;
                const fogY = this.canvas.height - fogHeight;
                
                const fogGradient = this.ctx.createLinearGradient(0, fogY, 0, this.canvas.height);
                const fogAlpha = 0.1 + waveCount * 0.01;
                const fogHue = 220 + waveCount * 15;
                
                fogGradient.addColorStop(0, `hsla(${fogHue}, 30%, 10%, 0)`);
                fogGradient.addColorStop(0.5, `hsla(${fogHue}, 30%, 15%, ${fogAlpha})`);
                fogGradient.addColorStop(1, `hsla(${fogHue}, 30%, 20%, ${fogAlpha * 2})`);
                
                this.ctx.fillStyle = fogGradient;
                this.ctx.fillRect(0, fogY, this.canvas.width, fogHeight);
                
                // Ondas de névoa
                this.ctx.fillStyle = `hsla(${fogHue}, 30%, 15%, ${fogAlpha * 0.5})`;
                for (let i = 0; i < 3; i++) {
                    this.ctx.beginPath();
                    const waveY = this.canvas.height - (i + 1) * 20;
                    
                    for (let x = 0; x <= this.canvas.width; x += 10) {
                        const waveHeight = Math.sin((x + offset * (i + 1) * 20) * 0.01) * 10;
                        const y = waveY + waveHeight;
                        
                        if (x === 0) {
                            this.ctx.moveTo(x, y);
                        } else {
                            this.ctx.lineTo(x, y);
                        }
                    }
                    
                    this.ctx.lineTo(this.canvas.width, this.canvas.height);
                    this.ctx.lineTo(0, this.canvas.height);
                    this.ctx.closePath();
                    this.ctx.fill();
                }
            }
            
            renderMagicalGrid(time, waveCount) {
                // Grid mágico que pulsa e se intensifica com as ondas
                const gridSize = 50;
                const intensity = (Math.sin(time * 2) + 1) * 0.5;
                const alpha = (0.03 + waveCount * 0.005) * intensity;
                const hue = (time * 10 + waveCount * 30) % 360;
                
                this.ctx.strokeStyle = `hsla(${hue}, 60%, 50%, ${alpha})`;
                this.ctx.lineWidth = 1;
                
                // Linhas verticais
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    const offset = Math.sin(time + x * 0.01) * 5;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x + offset, 0);
                    this.ctx.lineTo(x + offset, this.canvas.height);
                    this.ctx.stroke();
                }
                
                // Linhas horizontais
                for (let y = 0; y < this.canvas.height; y += gridSize) {
                    const offset = Math.cos(time + y * 0.01) * 5;
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y + offset);
                    this.ctx.lineTo(this.canvas.width, y + offset);
                    this.ctx.stroke();
                }
                
                // Pontos de intersecção brilhantes ocasionais
                this.ctx.fillStyle = `hsla(${hue}, 80%, 70%, ${alpha * 2})`;
                for (let x = 0; x < this.canvas.width; x += gridSize) {
                    for (let y = 0; y < this.canvas.height; y += gridSize) {
                        const hash = ((x + y * this.canvas.width) * 0.001) % 1;
                        if (hash < 0.1 && intensity > 0.7) {
                            this.ctx.beginPath();
                            this.ctx.arc(x, y, 2, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                    }
                }
            }

            // Sistema de Soul Orbs
            createSoulOrb(x, y, value = 1) {
                const soulOrb = this.soulOrbPool.get();
                soulOrb.x = x + (Math.random() - 0.5) * 20; // Pequena variação na posição
                soulOrb.y = y + (Math.random() - 0.5) * 20;
                soulOrb.value = value;
                soulOrb.size = 8;
                soulOrb.collected = false;
                soulOrb.alpha = 1.0;
                soulOrb.lifetime = 30000; // 30 segundos
                soulOrb.createdAt = Date.now();

                this.soulOrbs.push(soulOrb);
            }

            updateSoulOrbs(deltaTime) {
                this.soulOrbs = this.soulOrbs.filter(orb => {
                    if (orb.collected) return false;

                    // Verificar coleta pelo jogador
                    if (this.player && this.isNearPlayer(orb.x, orb.y, this.player.x, this.player.y, this.player.size + 15)) {
                        this.player.collectSoulOrb(orb.value);
                        orb.collected = true;
                        this.audioSystem.playSound('soulOrb');
                        this.soulOrbPool.release(orb);
                        return false;
                    }

                    // Fade out após 25 segundos
                    const age = Date.now() - orb.createdAt;
                    if (age > 25000) {
                        orb.alpha = Math.max(0, 1 - (age - 25000) / 5000);
                        if (orb.alpha <= 0) {
                            this.soulOrbPool.release(orb);
                            return false;
                        }
                    }

                    return true;
                });
            }

            isNearPlayer(x1, y1, x2, y2, distance) {
                const dx = x1 - x2;
                const dy = y1 - y2;
                return Math.sqrt(dx * dx + dy * dy) < distance;
            }

            renderSoulOrbs() {
                for (let orb of this.soulOrbs) {
                    if (!orb.collected) {
                        this.ctx.globalAlpha = orb.alpha;

                        // Efeito de brilho pulsante
                        const time = Date.now() * 0.005;
                        const pulseSize = orb.size + Math.sin(time + orb.x * 0.01) * 2;

                        // Soul orb principal
                        this.ctx.fillStyle = '#66ffff';
                        this.ctx.beginPath();
                        this.ctx.arc(orb.x, orb.y, pulseSize, 0, Math.PI * 2);
                        this.ctx.fill();

                        // Núcleo brilhante
                        this.ctx.fillStyle = '#ffffff';
                        this.ctx.beginPath();
                        this.ctx.arc(orb.x, orb.y, pulseSize * 0.6, 0, Math.PI * 2);
                        this.ctx.fill();

                        // Halo externo
                        this.ctx.globalAlpha = orb.alpha * 0.3;
                        this.ctx.fillStyle = '#66ffff';
                        this.ctx.beginPath();
                        this.ctx.arc(orb.x, orb.y, pulseSize * 1.5, 0, Math.PI * 2);
                        this.ctx.fill();

                        this.ctx.globalAlpha = 1.0;
                    }
                }
            }

            renderEffects() {
                // Efeitos de partículas podem ser adicionados aqui
            }

            renderDebugInfo() {
                const info = [
                    `FPS: ${Math.round(1000 / this.deltaTime)}`,
                    `Enemies: ${this.waveSystem ? this.waveSystem.enemies.length : 0}`,
                    `Projectiles: ${this.player ? this.player.projectiles.length : 0}`,
                    `Soul Orbs: ${this.soulOrbs.length}`,
                    `Game Time: ${TimeUtils.formatTime(this.gameTime)}`
                ];

                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                this.ctx.fillRect(10, 10, 200, info.length * 20 + 10);

                this.ctx.fillStyle = '#ffffff';
                this.ctx.font = '12px monospace';
                this.ctx.textAlign = 'left';

                info.forEach((line, index) => {
                    this.ctx.fillText(line, 15, 25 + index * 20);
                });
            }

            renderMenu() {
                // Menu é renderizado via HTML/CSS
            }

            renderGameOver() {
                // Overlay escuro
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Texto de game over
                this.ctx.fillStyle = '#ff6666';
                this.ctx.font = 'bold 48px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('GAME OVER', this.canvas.width / 2, this.canvas.height / 2 - 100);

                // Final Score
                const finalScore = this.calculateScore();
                this.ctx.fillStyle = '#ffaa00';
                this.ctx.font = 'bold 32px Arial';
                this.ctx.fillText(`Pontuação Final: ${finalScore}`, this.canvas.width / 2, this.canvas.height / 2 - 50);

                // Estatísticas
                if (this.waveSystem) {
                    const stats = [
                        `Onda alcançada: ${this.waveSystem.currentWave}`,
                        `Inimigos derrotados: ${this.waveSystem.enemiesKilled}`,
                        `Tempo sobrevivido: ${TimeUtils.formatTime(this.gameTime)}`,
                        `Soul Orbs coletados: ${this.player ? this.player.soulOrbs : 0}`
                    ];

                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = '18px Arial';

                    stats.forEach((stat, index) => {
                        this.ctx.fillText(stat, this.canvas.width / 2, this.canvas.height / 2 + 10 + index * 25);
                    });
                }

                // Instruções
                this.ctx.fillStyle = '#aaaaaa';
                this.ctx.font = '16px Arial';
                this.ctx.fillText('Pressione R para reiniciar ou ESC para o menu',
                    this.canvas.width / 2, this.canvas.height - 50);
            }

            updateUI() {
                if (this.player) {
                    this.ui.emit('hpUpdate', this.player.hp, this.player.maxHp);
                    this.ui.emit('soulOrbsUpdate', this.player.soulOrbs);
                }

                if (this.waveSystem) {
                    this.ui.emit('waveUpdate', this.waveSystem.currentWave);
                }

                this.ui.emit('timeUpdate', this.gameTime);
            }

            // updateHPBar - DESABILITADO (usando HUD no canvas)
            // updateHPBar(hp, maxHp) {
            //     const hpFill = document.getElementById('hpFill');
            //     const hpText = document.getElementById('hpText');

            //     const percentage = (hp / maxHp) * 100;
            //     hpFill.style.width = percentage + '%';
            //     hpText.textContent = `${Math.ceil(hp)}/${maxHp}`;

            //     // Cor baseada na porcentagem
            //     if (percentage > 60) {
            //         hpFill.style.background = 'linear-gradient(90deg, #4CAF50 0%, #66BB6A 50%, #4CAF50 100%)';
            //     } else if (percentage > 30) {
            //         hpFill.style.background = 'linear-gradient(90deg, #FF9800 0%, #FFB74D 50%, #FF9800 100%)';
            //     } else {
            //         hpFill.style.background = 'linear-gradient(90deg, #F44336 0%, #EF5350 50%, #F44336 100%)';
            //     }
            // }

            updateSoulOrbsDisplay(count) {
                document.getElementById('soulOrbsText').textContent = `Orbes: ${count}`;
            }

            updateWaveDisplay(wave) {
                document.getElementById('waveText').textContent = `Onda: ${wave}`;
            }

            updateTimeDisplay(time) {
                document.getElementById('timerText').textContent = TimeUtils.formatTime(time);
            }

            // Controles do jogo
            startNewGame() {
                this.state = 'playing';
                this.gameStartTime = Date.now();
                this.gameTime = 0;

                // Incrementar contador de jogadas
                this.incrementGamesPlayed();

                // Criar terreno
                this.terrain = new Terrain(this.canvas.width, this.canvas.height);

                // REPOSICIONAR o player existente (não criar novo!)
                if (this.player) {
                    const spawnX = this.canvas.width / 2;
                    const spawnY = this.canvas.height - 100; // próximo ao chão
                    this.player.x = spawnX;
                    this.player.y = spawnY;
                    this.player.vx = 0;
                    this.player.vy = 0;
                    
                    // Resetar stats principais para o jogo atual
                    this.player.level = 1;
                    this.player.exp = 0;
                    this.player.expToNext = 100;
                    this.player.recalculateBaseStats(); // Recalcular stats baseado no level 1
                    this.player.hp = this.player.maxHp; // HP cheio baseado no novo maxHp
                    this.player.invulnerable = false;
                    this.player.invulnerabilityTime = 0;
                    
                    // Resetar estatísticas de pontuação
                    this.player.score = 0;
                    this.player.enemiesKilled = 0;
                    this.player.totalDamageDealt = 0;
                    this.player.shotsHit = 0;
                    this.player.shotsFired = 0;
                    this.player.criticalHits = 0;
                    this.player.survivalTime = 0;
                } else {
                    // Só criar novo player se não existir
                    console.warn('Player não existe, criando novo');
                    const spawnX = this.canvas.width / 2;
                    const spawnY = this.canvas.height - 100;
                    this.player = new Player(spawnX, spawnY);
                }

                // Atualizar sprites dos equipamentos (mantém equipamentos salvos)
                if (this.player.updateEquipmentSprites) {
                    this.player.updateEquipmentSprites();
                }

                // Garantir que o player aplique os efeitos dos equipamentos
                if (this.player.updateStats) {
                    this.player.updateStats();
                }

                // Limpar build anterior (nova partida = nova build)
                this.player.selectedCards = [];
                this.player.cardEffects = {};
                this.player.onKillEffects = [];
                this.player.cardStacks = {};
                
                // Limpar efeitos especiais
                this.player.lightningStrikes = [];
                this.player.projectiles = [];
                this.player.castingParticles = [];
                this.player.lightningEffect = null;
                
                // Resetar efeitos temporários de cartas
                this.player.onHitEffects = [];
                this.player.rarityBonus = 0;
                this.player.extraCardOptions = 0;
                this.player.lifesteal = 0;
                this.player.contactDamage = 0;
                this.player.extraLives = 0;

                // Limpar soul orbs
                this.soulOrbs = [];

                // Limpar todos os inputs para evitar movimento automático
                if (this.player && this.player.clearAllInputs) {
                    this.player.clearAllInputs();
                }

                // Desabilitar controles mobile permanentemente em desktop
                if ((typeof DeviceUtils === 'undefined' || !DeviceUtils.isMobile()) && this.player && this.player.disableMobileControls) {
                    this.player.disableMobileControls();
                }

                // Criar sistema de spawn de inimigos
                this.enemySpawner = new EnemySpawner();

                // O waveSystem é o mesmo que o enemySpawner (compatibilidade)
                this.waveSystem = this.enemySpawner;

                // Criar sistema de upgrades
                this.upgradeSystem = new UpgradeSystem();

                // Event listeners
                this.setupGameEventListeners();

                // Esconder menu
                this.hideAllMenus();

                // Mostrar canvas e ocultar HUD HTML (usamos HUD no canvas)
                this.canvas.style.display = 'block';
                const gameHUD = document.getElementById('gameHUD');
                if (gameHUD) {
                    gameHUD.style.display = 'none';
                }

                // Mostrar controles móveis se necessário
                if (typeof DeviceUtils !== 'undefined' && DeviceUtils.isMobile()) {
                    const mobileControls = document.getElementById('mobileControls');
                    if (mobileControls) {
                        mobileControls.style.display = 'block';
                    }
                }
            }

            startGame() {
                // Inicializar o player se não existir
                if (!this.player) {
                    const spawnX = 400;
                    const spawnY = 300;
                    this.player = new Player(spawnX, spawnY);
                }

                // Carregar dados salvos DEPOIS de criar o player
                const loadedData = this.loadGame();

                // Apenas configurar equipamentos iniciais se não carregou dados salvos
                if (!loadedData) {
                    // Garantir que o player tenha equipamentos iniciais
                    if (!this.player.ownedEquipment.hats.includes('wizardHat')) {
                        this.player.ownedEquipment.hats.push('wizardHat');
                    }
                    if (!this.player.ownedEquipment.staffs.includes('wizardStaff')) {
                        this.player.ownedEquipment.staffs.push('wizardStaff');
                    }

                    // Equipar itens iniciais se não tiver nada equipado
                    if (!this.player.equippedEquipment.hats) {
                        this.player.equippedEquipment.hats = 'wizardHat';
                    }
                    if (!this.player.equippedEquipment.staffs) {
                        this.player.equippedEquipment.staffs = 'wizardStaff';
                    }
                }

                // Atualizar sprites dos equipamentos
                if (this.player.updateEquipmentSprites) {
                    this.player.updateEquipmentSprites();
                }

                // Limpar todos os inputs para garantir que não há movimento automático
                if (this.player.clearAllInputs) {
                    this.player.clearAllInputs();
                }

                // Desabilitar controles mobile permanentemente em desktop
                if ((typeof DeviceUtils === 'undefined' || !DeviceUtils.isMobile()) && this.player.disableMobileControls) {
                    this.player.disableMobileControls();
                }

                // Garantir que o nome do player está atualizado
                const savedPlayerName = this.playerNamePrompt.loadPlayerName();
                if (savedPlayerName) {
                    this.player.setPlayerName(savedPlayerName);
                }

                // Atualizar stats do player com equipamentos
                this.player.updateStats();

                // Iniciar novo jogo
                this.startNewGame();
            }

            setupGameEventListeners() {
                // Player events
                this.player.on('death', () => {
                    this.gameOver();
                });

                this.player.on('levelUp', (level) => {
                    this.handlePlayerLevelUp(level);
                });

                this.player.on('expGained', (amount, currentExp, expToNext) => {
                    // A barra de EXP é atualizada automaticamente no renderHUD do UI
                    // this.updateExpBar(currentExp, expToNext);
                });

                this.player.on('critical', () => {
                    this.audioSystem.playSound('critical');
                });

                // Enemy spawner events
                this.enemySpawner.on('enemyKilled', (enemy) => {
                    this.audioSystem.playSound('enemyDeath');

                    // Criar soul orb na posição do inimigo
                    this.createSoulOrb(enemy.x, enemy.y, 1);

                    // Atualizar estatísticas do player
                    if (this.player) {
                        this.player.addKill(enemy);
                    }
                });

                // Player events para estatísticas
                this.player.on('hit', (enemy, damage) => {
                    // Verificar se foi crítico
                    const isCritical = damage > this.player.damage;
                    this.player.addDamage(damage, isCritical);
                    this.player.addShot(true); // Tiro que acertou
                });

                this.player.on('shot', () => {
                    this.player.addShot(false); // Tiro disparado
                });

                // Salvar quando Soul Orbs são coletados
                this.player.on('soulOrbCollected', (totalOrbs) => {
                    console.log(`Soul Orbs coletados: ${totalOrbs}. Salvando jogo...`);
                    this.saveGame();
                });

                // Upgrade system events
                this.upgradeSystem.on('upgradeMenuOpened', (options) => {
                    this.state = 'paused'; // Pausar sem mostrar menu de pausa
                    this.showUpgradeMenu(options);
                });

                this.upgradeSystem.on('upgradeSelected', (upgrade) => {
                    this.hideUpgradeMenu();
                    this.state = 'playing'; // Retomar sem usar resumeGame
                    this.audioSystem.playSound('upgradeSelected');
                });
            }

            handlePlayerLevelUp(level) {
                this.audioSystem.playSound('levelUp');

                // Pausar o jogo antes de mostrar o menu
                this.state = 'paused';

                // Mostrar menu de upgrade
                this.upgradeSystem.showUpgradeMenu(this.player);
            }

            // Método para mostrar menu de upgrade
            showUpgradeMenu(options) {
                if (this.upgradeSystem) {
                    this.upgradeSystem.renderUpgradeMenu(this.ctx, this.canvas);
                }
            }

            // Método para esconder menu de upgrade
            hideUpgradeMenu() {
                // O upgrade system cuida da lógica de esconder
                if (this.upgradeSystem) {
                    this.upgradeSystem.hideUpgradeMenu();
                }
            }

            // Método para lidar com cliques em cartas de upgrade
            handleUpgradeCardClick(mouseX, mouseY) {
                if (this.upgradeSystem && this.upgradeSystem.isUpgradeMenuOpen) {
                    const cardId = this.upgradeSystem.handleClick(mouseX, mouseY);
                    if (cardId) {
                        // Processar a seleção da carta
                        const success = this.upgradeSystem.selectUpgrade(cardId, this.player);
                        if (success) {
                            // Retomar o jogo após seleção
                            this.state = 'playing';
                        }
                    }
                }
            }

            togglePause() {
                if (this.state === 'playing') {
                    this.pauseGame();
                } else if (this.state === 'paused') {
                    this.resumeGame();
                }
            }

            pauseGame() {
                this.state = 'paused';

                // Limpar inputs do player quando pausar
                if (this.player && this.player.clearAllInputs) {
                    this.player.clearAllInputs();
                }

                const pauseMenu = document.getElementById('pauseMenu');
                if (pauseMenu) {
                    pauseMenu.classList.remove('hidden');
                    pauseMenu.style.display = 'flex';
                    pauseMenu.style.zIndex = '9999';
                    console.log('Menu de pausa mostrado'); // Debug
                } else {
                    console.error('Elemento pauseMenu não encontrado'); // Debug
                }
            }

            resumeGame() {
                this.state = 'playing';

                // Limpar inputs do player quando retomar
                if (this.player && this.player.clearAllInputs) {
                    this.player.clearAllInputs();
                }

                const pauseMenu = document.getElementById('pauseMenu');
                if (pauseMenu) {
                    pauseMenu.classList.add('hidden');
                    pauseMenu.style.display = 'none';
                    console.log('Menu de pausa escondido'); // Debug
                }
            }

            gameOver() {
                // Prevent multiple game over calls
                if (this.state === 'gameOver') return;

                this.state = 'gameOver';

                // Limpar inputs do player quando o jogo acabar
                if (this.player && this.player.clearAllInputs) {
                    this.player.clearAllInputs();
                }

                // Atualizar tempo de sobrevivência
                if (this.player) {
                    this.player.updateSurvivalTime(Date.now() - this.gameStartTime);
                }

                // Adicionar ao ranking (faz o save internamente)
                this.addToRanking();

                // Limpar save game
                Storage.remove('seraphsLastStand_save');

                // Mostrar menu de game over HTML
                this.showGameOverMenu();
            }

            // Adicionar pontuação ao ranking
            addToRanking() {
                if (!this.player) return;

                // Calculate final score
                const score = this.calculateScore();

                // Create stats entry
                const stats = {
                    playerName: this.player.playerName || 'Player',
                    score: score,
                    level: this.player.level,
                    survivalTime: this.gameTime,
                    enemiesKilled: this.waveSystem?.enemiesKilled || 0,
                    build: this.player.selectedCards || [],
                    date: new Date().toLocaleDateString('pt-BR')
                };

                // Always add to ranking (let the ranking system handle duplicates/limits)
                if (this.rankingSystem) {
                    this.rankingSystem.addScore(stats);
                    console.log('Score added to ranking:', stats);
                }
            }

            showMainMenu() {
                console.log('Mostrando menu principal...');
                this.state = 'menu'; // Garantir que o estado seja menu
                this.currentScreen = 'mainMenu';

                // Ocultar canvas e HUD do jogo
                this.canvas.style.display = 'none';
                const gameHUD = document.getElementById('gameHUD');
                if (gameHUD) {
                    gameHUD.style.display = 'none';
                }

                // Ocultar controles móveis
                const mobileControls = document.getElementById('mobileControls');
                if (mobileControls) {
                    mobileControls.style.display = 'none';
                }

                // Fechar todos os outros menus primeiro
                this.hideAllOtherMenus();

                // Adicionar estilos do menu moderno
                this.addMainMenuStyles();

                // Mostrar menu principal
                const mainMenu = document.getElementById('mainMenu');
                if (mainMenu) {
                    mainMenu.classList.remove('hidden');
                    mainMenu.style.display = 'flex';
                    console.log('Menu principal mostrado');
                } else {
                    console.error('Elemento mainMenu não encontrado');
                }

                // Inicializar player se não existir para mostrar stats
                if (!this.player) {
                    this.player = new Player(400, 300);
                    this.loadGame(); // Carregar dados salvos
                }

                // Carregar nome atualizado do PlayerNamePrompt
                const savedPlayerName = this.playerNamePrompt.loadPlayerName();
                if (savedPlayerName && this.player) {
                    this.player.setPlayerName(savedPlayerName);
                }

                // Atualizar estatísticas do menu
                this.updateMenuStats();
            }

            // Método para atualizar as estatísticas exibidas no menu
            updateMenuStats() {
                try {
                    // Soul Orbs do player
                    const soulOrbsElement = document.getElementById('menuSoulOrbs');
                    if (soulOrbsElement && this.player) {
                        soulOrbsElement.textContent = this.player.soulOrbs || 0;
                    }

                    // Melhor pontuação do ranking
                    const bestScoreElement = document.getElementById('menuBestScore');
                    if (bestScoreElement && this.rankingSystem) {
                        const rankings = this.rankingSystem.getRankings();
                        const bestScore = rankings.length > 0 ? rankings[0].score : 0;
                        bestScoreElement.textContent = bestScore.toLocaleString();
                    }

                    // Número de jogadas (pode ser salvo em localStorage)
                    const gamesPlayedElement = document.getElementById('menuGamesPlayed');
                    if (gamesPlayedElement) {
                        const gamesPlayed = localStorage.getItem('totalGamesPlayed') || 0;
                        gamesPlayedElement.textContent = gamesPlayed;
                    }
                } catch (error) {
                    console.warn('Erro ao atualizar estatísticas do menu:', error);
                }
            }

            // Método para incrementar contador de jogadas
            incrementGamesPlayed() {
                try {
                    const currentCount = parseInt(localStorage.getItem('totalGamesPlayed') || '0');
                    localStorage.setItem('totalGamesPlayed', (currentCount + 1).toString());
                } catch (error) {
                    console.warn('Erro ao incrementar contador de jogadas:', error);
                }
            }

            hideMainMenu() {
                const mainMenu = document.getElementById('mainMenu');
                if (mainMenu) {
                    mainMenu.classList.add('hidden');
                    mainMenu.style.display = 'none';
                }
            }

            // Método removido - consolidado no hideAllMenus() acima para evitar duplicação

            addMainMenuStyles() {
                if (document.getElementById('main-menu-styles')) return;

                const style = document.createElement('style');
                style.id = 'main-menu-styles';
                style.textContent = `
            /* Menu Principal Moderno */
            .main-menu {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: 
                    radial-gradient(circle at 20% 80%, rgba(120, 50, 180, 0.4) 0%, transparent 50%),
                    radial-gradient(circle at 80% 20%, rgba(50, 120, 180, 0.4) 0%, transparent 50%),
                    linear-gradient(135deg, #0a0a1a 0%, #1a0a2a 25%, #0a1a2a 50%, #1a0a0a 75%, #0a0a1a 100%);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 9000;
                overflow: hidden;
                animation: menuFadeIn 1s ease-out;
            }

            /* Partículas de fundo animadas */
            .main-menu::before {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-image: 
                    radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.1) 1px, transparent 1px),
                    radial-gradient(circle at 75% 75%, rgba(255, 255, 255, 0.1) 1px, transparent 1px);
                background-size: 100px 100px, 150px 150px;
                animation: particleFloat 20s linear infinite;
                opacity: 0.3;
            }

            /* Container principal com glassmorphism */
            .menu-container {
                text-align: center;
                background: rgba(15, 15, 30, 0.8);
                backdrop-filter: blur(20px);
                border: 2px solid rgba(255, 255, 255, 0.1);
                padding: 50px 40px;
                border-radius: 25px;
                box-shadow: 
                    0 25px 50px rgba(0, 0, 0, 0.6),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1);
                min-width: 450px;
                max-width: 500px;
                position: relative;
                z-index: 1;
                animation: containerSlideUp 0.8s ease-out 0.2s both;
            }

            /* Efeito de brilho no container */
            .menu-container::before {
                content: '';
                position: absolute;
                top: -2px;
                left: -2px;
                right: -2px;
                bottom: -2px;
                background: linear-gradient(45deg, 
                    rgba(120, 50, 180, 0.3), 
                    rgba(50, 120, 180, 0.3),
                    rgba(180, 120, 50, 0.3),
                    rgba(120, 50, 180, 0.3));
                border-radius: 27px;
                z-index: -1;
                animation: borderGlow 3s ease-in-out infinite;
                filter: blur(5px);
            }
            
            /* Título do jogo com efeitos avançados */
            .game-title {
                font-size: 52px;
                font-weight: 900;
                color: #fff;
                margin-bottom: 40px;
                text-shadow: 
                    0 0 20px rgba(255, 255, 255, 0.4),
                    0 0 40px rgba(120, 50, 180, 0.3),
                    0 0 60px rgba(50, 120, 180, 0.2);
                background: linear-gradient(45deg, 
                    #ff6b6b, #4ecdc4, #45b7d1, #f9ca24, #f0932b, #eb4d4b, #6c5ce7);
                background-size: 400% 400%;
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                animation: titleGradient 4s ease-in-out infinite, titleFloat 3s ease-in-out infinite;
                letter-spacing: 2px;
                position: relative;
            }

            /* Subtítulo */
            .game-subtitle {
                font-size: 16px;
                color: rgba(255, 255, 255, 0.7);
                margin-bottom: 35px;
                letter-spacing: 4px;
                text-transform: uppercase;
                animation: subtitleFade 1s ease-out 0.5s both;
            }
            
            /* Container dos botões */
            .menu-buttons {
                display: flex;
                flex-direction: column;
                gap: 20px;
                margin-bottom: 40px;
            }
            
            /* Botões modernos com efeitos visuais */
            .menu-btn {
                padding: 18px 35px;
                font-size: 18px;
                font-weight: 600;
                background: linear-gradient(135deg, 
                    rgba(40, 40, 60, 0.8), 
                    rgba(60, 40, 80, 0.8));
                color: white;
                border: 2px solid rgba(255, 255, 255, 0.1);
                border-radius: 15px;
                cursor: pointer;
                transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
                position: relative;
                overflow: hidden;
                backdrop-filter: blur(10px);
                text-transform: uppercase;
                letter-spacing: 1px;
                box-shadow: 
                    0 8px 25px rgba(0, 0, 0, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.1);
            }

            /* Efeito de ondas nos botões */
            .menu-btn::before {
                content: '';
                position: absolute;
                top: 0;
                left: -100%;
                width: 100%;
                height: 100%;
                background: linear-gradient(90deg, 
                    transparent, 
                    rgba(255, 255, 255, 0.2), 
                    transparent);
                transition: left 0.5s;
            }

            .menu-btn:hover::before {
                left: 100%;
            }
            
            .menu-btn:hover {
                border-color: rgba(76, 175, 80, 0.6);
                transform: translateY(-3px) scale(1.02);
                box-shadow: 
                    0 15px 35px rgba(76, 175, 80, 0.2),
                    0 5px 15px rgba(0, 0, 0, 0.3),
                    inset 0 1px 0 rgba(255, 255, 255, 0.2);
                background: linear-gradient(135deg, 
                    rgba(60, 80, 60, 0.9), 
                    rgba(40, 100, 80, 0.9));
                color: #e8f5e8;
            }
            
            .menu-btn:active {
                transform: translateY(-1px) scale(1.01);
                transition: all 0.1s;
            }

            /* Botões específicos com cores personalizadas */
            .menu-btn.start-game {
                background: linear-gradient(135deg, 
                    rgba(40, 80, 40, 0.8), 
                    rgba(60, 120, 60, 0.8));
                border-color: rgba(76, 175, 80, 0.3);
            }

            .menu-btn.shop {
                background: linear-gradient(135deg, 
                    rgba(80, 40, 80, 0.8), 
                    rgba(120, 60, 120, 0.8));
                border-color: rgba(150, 80, 150, 0.3);
            }

            .menu-btn.ranking {
                background: linear-gradient(135deg, 
                    rgba(80, 60, 40, 0.8), 
                    rgba(120, 90, 60, 0.8));
                border-color: rgba(255, 193, 7, 0.3);
            }

            .menu-btn.settings {
                background: linear-gradient(135deg, 
                    rgba(40, 60, 80, 0.8), 
                    rgba(60, 90, 120, 0.8));
                border-color: rgba(33, 150, 243, 0.3);
            }
            
            /* Estatísticas do menu */
            .menu-stats {
                display: flex;
                justify-content: space-between;
                gap: 25px;
                margin-top: 30px;
                padding-top: 25px;
                border-top: 1px solid rgba(255, 255, 255, 0.1);
                animation: statsSlideUp 1s ease-out 0.8s both;
            }
            
            .stat-item {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 8px;
                padding: 15px;
                background: rgba(255, 255, 255, 0.05);
                border-radius: 12px;
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.1);
                transition: all 0.3s ease;
                flex: 1;
            }

            .stat-item:hover {
                background: rgba(255, 255, 255, 0.1);
                transform: translateY(-2px);
                box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            }
            
            .stat-label {
                font-size: 12px;
                color: rgba(255, 255, 255, 0.6);
                text-transform: uppercase;
                letter-spacing: 1px;
                font-weight: 500;
            }
            
            .stat-value {
                font-size: 20px;
                font-weight: 700;
                color: #4CAF50;
                text-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
            }

            /* Animações */
            @keyframes menuFadeIn {
                from {
                    opacity: 0;
                    backdrop-filter: blur(0px);
                }
                to {
                    opacity: 1;
                    backdrop-filter: blur(5px);
                }
            }

            @keyframes containerSlideUp {
                from {
                    transform: translateY(50px) scale(0.95);
                    opacity: 0;
                }
                to {
                    transform: translateY(0) scale(1);
                    opacity: 1;
                }
            }

            @keyframes titleGradient {
                0%, 100% {
                    background-position: 0% 50%;
                }
                50% {
                    background-position: 100% 50%;
                }
            }

            @keyframes titleFloat {
                0%, 100% {
                    transform: translateY(0px);
                }
                50% {
                    transform: translateY(-5px);
                }
            }

            @keyframes subtitleFade {
                from {
                    opacity: 0;
                    transform: translateY(20px);
                }
                to {
                    opacity: 1;
                    transform: translateY(0);
                }
            }

            @keyframes statsSlideUp {
                from {
                    transform: translateY(30px);
                    opacity: 0;
                }
                to {
                    transform: translateY(0);
                    opacity: 1;
                }
            }

            @keyframes borderGlow {
                0%, 100% {
                    opacity: 0.3;
                    filter: blur(5px);
                }
                50% {
                    opacity: 0.6;
                    filter: blur(2px);
                }
            }

            @keyframes particleFloat {
                0% {
                    transform: translateY(0px);
                }
                100% {
                    transform: translateY(-100px);
                }
            }

            /* Responsividade móvel */
            @media (max-width: 600px) {
                .menu-container {
                    padding: 30px 25px;
                    min-width: 320px;
                    max-width: 90vw;
                    margin: 20px;
                }
                
                .game-title {
                    font-size: 36px;
                    margin-bottom: 25px;
                }

                .game-subtitle {
                    font-size: 14px;
                    margin-bottom: 25px;
                    letter-spacing: 2px;
                }
                
                .menu-btn {
                    padding: 15px 25px;
                    font-size: 16px;
                }

                .menu-stats {
                    gap: 15px;
                    margin-top: 20px;
                    padding-top: 20px;
                }

                .stat-item {
                    padding: 12px 8px;
                }

                .stat-value {
                    font-size: 18px;
                }

                .stat-label {
                    font-size: 11px;
                }
            }

            /* Efeitos especiais para elementos interativos */
            .menu-btn, .stat-item {
                --glow-color: rgba(76, 175, 80, 0.4);
            }

            .menu-btn.shop {
                --glow-color: rgba(150, 80, 150, 0.4);
            }

            .menu-btn.ranking {
                --glow-color: rgba(255, 193, 7, 0.4);
            }

            .menu-btn.settings {
                --glow-color: rgba(33, 150, 243, 0.4);
            }
        `;

                document.head.appendChild(style);
            }

            // Sistema de save/load
            saveGame() {
                const gameData = {
                    player: {
                        soulOrbs: this.player.soulOrbs,
                        level: this.player.level,
                        experience: this.player.exp,
                        ownedEquipment: this.player.ownedEquipment,
                        equippedEquipment: this.player.equippedEquipment,
                        playerName: this.player.playerName,
                        selectedCards: this.player.selectedCards || [] // Salvar build
                    },
                    settings: {
                        audioEnabled: !this.audioSystem.isMuted(),
                        masterVolume: this.audioSystem.masterVolume,
                        sfxVolume: this.audioSystem.sfxVolume,
                        musicVolume: this.audioSystem.musicVolume,
                        expMultiplier: this.expMultiplier || 1
                    },
                    timestamp: Date.now()
                };

                localStorage.setItem('seraphsLastStandSave', JSON.stringify(gameData));
                console.log('Jogo salvo:', gameData);
            }

            // Auto-save method
            autoSave() {
                try {
                    this.saveGame();
                    console.log('Auto-save concluído');
                } catch (error) {
                    console.error('Erro no auto-save:', error);
                }
            }

            loadGame() {
                try {
                    const saveData = localStorage.getItem('seraphsLastStandSave');
                    if (!saveData) return false;

                    const gameData = JSON.parse(saveData);
                    console.log('Carregando jogo:', gameData);

                    // Aplicar dados do jogador
                    if (gameData.player) {
                        this.player.soulOrbs = gameData.player.soulOrbs || 0;
                        this.player.level = gameData.player.level || 1;
                        this.player.exp = gameData.player.experience || 0;
                        this.player.setPlayerName(gameData.player.playerName || this.playerNamePrompt.loadPlayerName() || 'Player');

                        // Equipamentos
                        if (gameData.player.ownedEquipment) {
                            this.player.ownedEquipment = gameData.player.ownedEquipment;
                        }
                        if (gameData.player.equippedEquipment) {
                            this.player.equippedEquipment = gameData.player.equippedEquipment;
                        }

                        // Build (cartas escolhidas)
                        if (gameData.player.selectedCards) {
                            this.player.selectedCards = gameData.player.selectedCards;
                        }
                    } else {
                        // Se não há dados salvos, carregar nome do PlayerNamePrompt
                        const savedName = this.playerNamePrompt.loadPlayerName();
                        if (savedName && this.player) {
                            this.player.setPlayerName(savedName);
                        }
                    }

                    // Aplicar configurações
                    if (gameData.settings) {
                        if (gameData.settings.audioEnabled === false) {
                            this.audioSystem.mute();
                        } else {
                            this.audioSystem.unmute();
                        }
                        this.audioSystem.setMasterVolume(gameData.settings.masterVolume || 0.7);
                        this.audioSystem.setSfxVolume(gameData.settings.sfxVolume || 0.8);
                        this.audioSystem.setMusicVolume(gameData.settings.musicVolume || 0.5);
                        this.expMultiplier = gameData.settings.expMultiplier || 1;
                        
                        // Atualizar a interface das configurações se estiver carregada
                        if (this.ui && this.ui.updateSettingsUI) {
                            this.ui.updateSettingsUI(gameData.settings);
                        }
                        
                        // Salvar configurações de áudio para garantir persistência
                        this.audioSystem.saveSettings();
                    } else {
                        // Se não há configurações salvas, carregar configurações do AudioSystem
                        if (this.audioSystem) {
                            this.audioSystem.loadSettings();
                        }
                    }

                    console.log('Jogo carregado com sucesso'); // Debug
                    return true;
                } catch (error) {
                    console.error('Erro ao carregar jogo:', error);
                    return false;
                }
            }

            // Método para mostrar ranking - UNIFICADO
            showRanking() {
                console.log('Mostrando ranking - usando modal moderno...');

                // Verificar se devemos usar o sistema modal moderno ou menus estáticos
                if (this.ui && this.ui.showRankingModal && this.rankingSystem) {
                    // Sistema moderno - usando modais
                    const rankings = this.rankingSystem.getRankings();
                    this.ui.showRankingModal(rankings);
                } else {
                    // Sistema legado - usando menus HTML estáticos
                    this.hideAllOtherMenus();
                    const mainMenu = document.getElementById('mainMenu');
                    if (mainMenu) {
                        mainMenu.classList.add('hidden');
                        mainMenu.style.display = 'none';
                    }

                    const rankingMenu = document.getElementById('rankingMenu');
                    if (rankingMenu) {
                        rankingMenu.classList.remove('hidden');
                        rankingMenu.style.display = 'flex';
                        console.log('Menu de ranking mostrado (sistema legado)');
                    } else {
                        console.error('Elemento rankingMenu não encontrado');
                    }
                }
            }

            // Método removido - duplicação da função em linha 728

            setXpMultiplier(multiplier) {
                this.expMultiplier = Math.max(0.5, Math.min(5.0, multiplier));
                console.log('XP Multiplier definido para:', this.expMultiplier);
            }

            // Métodos para adicionar/remover Soul Orbs (debug)
            addSoulOrbs(amount) {
                if (!this.player) {
                    console.warn('Player não existe, criando novo player');
                    this.player = new Player(400, 300);
                }

                const finalAmount = Math.max(0, parseInt(amount) || 0);
                this.player.soulOrbs = (this.player.soulOrbs || 0) + finalAmount;

                console.log(`Adicionados ${finalAmount} Soul Orbs. Total: ${this.player.soulOrbs}`);
                this.ui.showNotification(`+${finalAmount} Soul Orbs adicionados! Total: ${this.player.soulOrbs}`, 'success', 2000);

                // Salvar mudanças
                this.saveGame();

                // Atualizar menu principal se estiver aberto
                if (this.state === 'menu') {
                    const soulOrbsValue = document.querySelector('.stat-value');
                    if (soulOrbsValue) {
                        soulOrbsValue.textContent = this.player.soulOrbs;
                    }
                }
            }

            removeSoulOrbs(amount) {
                if (!this.player) {
                    console.warn('Player não existe');
                    this.ui.showNotification('Nenhum player encontrado!', 'error', 2000);
                    return;
                }

                const finalAmount = Math.max(0, parseInt(amount) || 0);
                const oldAmount = this.player.soulOrbs || 0;
                this.player.soulOrbs = Math.max(0, oldAmount - finalAmount);
                const actualRemoved = oldAmount - this.player.soulOrbs;

                console.log(`Removidos ${actualRemoved} Soul Orbs. Total: ${this.player.soulOrbs}`);
                this.ui.showNotification(`-${actualRemoved} Soul Orbs removidos! Total: ${this.player.soulOrbs}`, 'info', 2000);

                // Salvar mudanças
                this.saveGame();

                // Atualizar menu principal se estiver aberto
                if (this.state === 'menu') {
                    const soulOrbsValue = document.querySelector('.stat-value');
                    if (soulOrbsValue) {
                        soulOrbsValue.textContent = this.player.soulOrbs;
                    }
                }
            }

            // Método para obter multiplicador de XP
            getXpMultiplier() {
                // Retorna o multiplicador de XP configurado ou padrão
                return this.settings?.xpMultiplier || 1.0;
            }

            // Calcular pontuação final
            calculateScore() {
                if (!this.player) return 0;

                let score = 0;
                score += this.player.level * 100;
                score += (this.waveSystem?.enemiesKilled || 0) * 10;
                score += Math.floor(this.gameTime / 1000) * 5;
                score += this.player.soulOrbs;

                return score;
            }

            showGameOverMenu() {
                console.log('Mostrando menu de game over...');

                // Ocultar canvas e HUD do jogo
                this.canvas.style.display = 'none';
                const gameHUD = document.getElementById('gameHUD');
                if (gameHUD) {
                    gameHUD.style.display = 'none';
                }

                // Ocultar controles móveis
                const mobileControls = document.getElementById('mobileControls');
                if (mobileControls) {
                    mobileControls.style.display = 'none';
                }

                // Fechar todos os outros menus primeiro
                this.hideAllOtherMenus();

                // Mostrar menu de game over
                const gameOverMenu = document.getElementById('gameOverMenu');
                if (gameOverMenu) {
                    gameOverMenu.classList.remove('hidden');
                    gameOverMenu.style.display = 'flex';

                    // Preencher estatísticas
                    this.populateGameOverStats();

                    console.log('Menu de game over mostrado');
                } else {
                    console.error('Elemento gameOverMenu não encontrado');
                }
            }

            populateGameOverStats() {
                const statsContainer = document.getElementById('gameOverStats');
                if (!statsContainer || !this.player) return;

                const finalScore = this.calculateScore();
                const survivalTimeFormatted = TimeUtils.formatTime(this.gameTime);
                const accuracy = this.player.shotsFired > 0 ?
                    Math.round((this.player.shotsHit / this.player.shotsFired) * 100) : 0;

                statsContainer.innerHTML = `
            <div class="stat-item">
                <span class="stat-label">Pontuação Final:</span>
                <span class="stat-value">${finalScore}</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Nível Alcançado:</span>
                <span class="stat-value">${this.player.level}</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Tempo de Sobrevivência:</span>
                <span class="stat-value">${survivalTimeFormatted}</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Inimigos Eliminados:</span>
                <span class="stat-value">${this.player.enemiesKilled}</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Precisão:</span>
                <span class="stat-value">${accuracy}%</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Críticos:</span>
                <span class="stat-value">${this.player.criticalHits}</span>
            </div>
            <div class="stat-item">
                <span class="stat-label">Soul Orbs:</span>
                <span class="stat-value">${this.player.soulOrbs}</span>
            </div>
            <div class="controls-hint">
                <p><strong>R</strong> - Jogar Novamente | <strong>ESC</strong> - Menu Principal</p>
            </div>
        `;
            }
        }

        // Classe para pré-carregar todas as imagens do jogo
        class ImagePreloader {
            constructor() {
                this.images = {};
                this.loadedCount = 0;
                this.totalCount = 0;
                this.onAllLoadedCallback = null;
            }

            preloadImages(imagePaths, onAllLoaded) {
                this.onAllLoadedCallback = onAllLoaded;
                this.totalCount = imagePaths.length;
                this.loadedCount = 0;

                imagePaths.forEach(imagePath => {
                    const img = new Image();
                    img.onload = () => {
                        this.loadedCount++;
                        console.log(`Imagem carregada: ${imagePath} (${this.loadedCount}/${this.totalCount})`);
                        if (this.loadedCount === this.totalCount && this.onAllLoadedCallback) {
                            this.onAllLoadedCallback();
                        }
                    };
                    img.onerror = () => {
                        console.error(`Erro ao carregar imagem: ${imagePath}`);
                        this.loadedCount++;
                        if (this.loadedCount === this.totalCount && this.onAllLoadedCallback) {
                            this.onAllLoadedCallback();
                        }
                    };
                    img.src = imagePath;
                    this.images[imagePath] = img;
                });
            }

            getImage(path) {
                return this.images[path];
            }
        }

        // Instância global do pré-carregador
        const imagePreloader = new ImagePreloader();

        // Pré-carregar todas as imagens de equipamentos ao carregar a página
        document.addEventListener('DOMContentLoaded', () => {
            const equipmentImages = [
                'img/player/mago.png',
                'img/chapeus/1_ChapeudeMago.png',
                'img/chapeus/2_Capacete.png',
                'img/chapeus/3_GorroHelice.png',
                'img/chapeus/4._ChapeuIncomum.png',
                'img/chapeus/5_ChapeudoDesafiante.png',
                'img/chapeus/6_Fedora.png',
                'img/cajados/1_CajadodoMago.png',
                'img/cajados/2_CajadodeEsmeralda.png',
                'img/cajados/3_Tridente.png',
                'img/cajados/4_Boomstaff.png',
                'img/cajados/5_CajadodoTrovao.png',
                'img/cajados/6_PontaCongelada.png',
                'img/cajados/7_CajadoArco-Iris.png'
            ];

            imagePreloader.preloadImages(equipmentImages, () => {
                console.log('Todas as imagens de equipamentos foram carregadas!');
            });
        });

        // Sistema de inicialização do jogo - UNIFICADO para evitar duplicação
        function initializeGame() {
            if (!window.game) {
                console.log('Inicializando jogo...');
                window.game = new Game();
                console.log('Jogo inicializado:', window.game);
            }
        }

        // Inicializar jogo quando DOM estiver carregado
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM carregado');
            initializeGame();
        });

        // Fallback para navegadores mais antigos
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeGame);
        } else {
            // DOM já carregou
            console.log('DOM já carregado - inicializando imediatamente');
            initializeGame();
        }

    </script>
</body>

</html>